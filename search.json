[{"title":"测试评论专用","path":"/2023/06/16/测试评论专用/","content":"这篇文章专门用来测试博客的评论功能(giscus)"},{"title":"使用TypeScript编写一个简单而实用的网页爬虫","path":"/2023/04/27/使用TypeScript编写一个简单而实用的网页爬虫/","content":"在这篇博客中，我们将深入探讨如何使用TypeScript编写一个简洁实用的网页爬虫，用于抓取指定页面中特定标签的内容。网络爬虫在互联网领域具有广泛的应用，它们可以帮助我们从各种网站上获取有价值的… 在这篇博客中，我们将深入探讨如何使用TypeScript编写一个简洁实用的网页爬虫，用于抓取指定页面中特定标签的内容。 网络爬虫在互联网领域具有广泛的应用，它们可以帮助我们从各种网站上获取有价值的信息。在本文中，我们将介绍如何使用TypeScript和一些流行的库来构建一个简单的爬虫，用于抓取指定页面中特定标签的内容。 准备工作首先，我们需要确保已经安装了Node.js和npm。接下来，我们将安装两个库：axios 和 cheerio。axios 是一个用于发送HTTP请求的库，而 cheerio 是一个用于解析HTML并提取数据的库。您可以使用以下命令安装这两个库： 1npm install axios cheerio 同时，安装TypeScript及其类型定义： 1npm install typescript @types/axios @types/cheerio 编写爬虫代码接下来，让我们看看如何使用这些库编写我们的爬虫。以下是一个简单的TypeScript爬虫脚本： 123456789101112131415161718192021222324252627282930313233343536import axios from &#x27;axios&#x27;;import cheerio from &#x27;cheerio&#x27;;interface ScrapedData &#123; title: string link: string&#125;async function fetchHTML(url: string): Promise&lt;string&gt; &#123; try &#123; const &#123; data &#125; = await axios.get(url); return data; &#125; catch (error) &#123; console.error(`Error fetching HTML from $&#123;url&#125;:`, error); return &#x27;&#x27; &#125;&#125;function extractDataFromHTML(html: string, target: string = &#x27;a&#x27;): ScrapedData[] &#123; const $ = cheerio.load(html); const scrapedData: ScrapedData[] = []; // 选取要抓取的元素,这里以 &lt;a&gt; 标签为例 $(target).each((_index, element) =&gt; &#123; const _element = $(element); scrapedData.push(&#123; title: _element.text(), link: _element.attr(&#x27;href&#x27;) || &#x27;&#x27; &#125;); &#125;) return scrapedData;&#125;export async function scrapeWebsite(url: string, targetName: string): Promise&lt;ScrapedData[]&gt; &#123; const html = await fetchHTML(url); return extractDataFromHTML(html, targetName);&#125; 在上面的脚本中，我们首先定义了一个ScrapedData接口，用于存储爬取到的数据。接着，我们实现了两个核心函数：fetchHTML 和 extractDataFromHTML。fetchHTML 函数用于从指定的URL获取HTML内容，而 extractDataFromHTML 函数则用于从HTML中提取指定标签的数据。 我们在extractDataFromHTML函数中使用了cheerio库，它提供了类似于jQuery的API，使得提取数据变得更加简单。在这个例子中，我们以&lt;a&gt;标签为例，但您可以根据需要修改extractDataFromHTML函数以提取其他类型的标签。 最后，我们导出了一个名为scrapeWebsite的函数，它接受一个URL和一个目标标签名称作为参数，并返回一个包含抓取到的数据的数组。这个函数封装了前面的fetchHTML和extractDataFromHTML函数，使得爬虫的使用变得简单明了。 使用示例以下是如何使用我们编写的爬虫从一个网站抓取所有&lt;a&gt;标签的示例： 123456789101112import &#123; scrapeWebsite &#125; from &#x27;./your_crawler_file&#x27;;async function main() &#123; const url = &#x27;https://www.example.com&#x27;; const targetTag = &#x27;a&#x27;; const scrapedData = await scrapeWebsite(url, targetTag); console.log(&#x27;Scraped data:&#x27;, scrapedData);&#125;main(); 这个例子中，我们导入了scrapeWebsite函数，并传入了一个示例网站的URL和目标标签&lt;a&gt;。爬虫将抓取该页面上所有&lt;a&gt;标签的文本内容和链接，然后将结果输出到控制台。 总结通过本文，我们学习了如何使用TypeScript和一些流行的库（axios和cheerio）来编写一个简单而实用的网页爬虫。虽然这个爬虫示例相对简单，但它可以作为编写更复杂爬虫的基础。您可以根据实际需求对其进行扩展，以提取更多类型的数据和处理更多种类的网页。 希望本文能对您有所帮助，祝您编程愉快！ 写在最后:这篇文章是由GPT自动生成了我只提供了关键代码片段,上面的案例也是GPT自动生成 另外,此案例的repo地址caoxicheng&#x2F;scrape-demo (github.com)"},{"title":"「瞎搞」-微信连接GPT","path":"/2023/04/22/「瞎搞」-微信连接GPT/","content":"前言最近在和GPT疯狂的聊天,想起来之前也想研究微信的自动应答,那么理论上是可以支持把GPT接入微信的,那么开干就干,下面展开说说…因为最近一直在和GPT闲聊,所以第一时间想到也是的直接问G… 前言最近在和GPT疯狂的聊天,想起来之前也想研究微信的自动应答,那么理论上是可以支持把GPT接入微信的,那么开干就干,下面展开说说… 因为最近一直在和GPT闲聊,所以第一时间想到也是的直接问GPT 图1 图1 因为提到了ichat,去搜索了相关的内容,不过说是代码很简陋+有封号危险,另外寻到了 Wechaty wechaty官方 中文文档 通过阅读 github 启动了一个 demo 小试牛刀按照介绍,直接 12pnpm install // 我习惯了pnpm,npm也可pnpm start 扫码登陆…… 事情没这么简单图2 图2 我直接愣住 图3 图3 我寻思这也能遇到Angualr(angualr大法好),不过我想到自己也是个angular开发,试试看能不能自己解决问题.进到问题点去看了一下,得是我没用过的内容 算了,直接去看issue,省略10mins 原因是微信的安全策略问题,需要配置 uos 模式[scode type&#x3D;”blue” size&#x3D;””]具体表现来说就是电脑登陆的话,手机扫码你电脑会被挤掉线[&#x2F;scode] 搞定ok,解决了这个小问题,我们直接开始测试,里面就判断一个很简单的内容,如果接收到信息为“ding”,则回复一个“dong”确实很入门 👇代码 图4 图4 👇效果 图5 图5 高阶玩法按照正常的流程接下来要开始研究文档,然后匹配自己的逻辑了,不过我这个比较鸡贼,想快速看到结果,就去搜索了一下关键字 微信 GPT hhhh,然后给我看了一个现成的应用ChatGPT-wechat-bot 其实是对于上文提到的 wechaty的一层封装 那么按照文档一步一步来(这里就把我之前遇到的 uos给默认打开了,但是官方的例子竟然没有修复!!!) 获取&#x2F;配置key……安装依赖……登陆……问答…… 图6 图6 后续api的方式调用的是GPT-3.5版本用起来确实没有GPT-4来的丝滑,不过最初的功能已经达成了 后期的设想 [ ] 商务的自动问答 [ ] 自动同意好友申请 [ ] 自动拉人进群 [ ] 更多 当然也有问题,就是群聊如果@你,不过你有群聊的备注,那么匹配不到,因为插件只会匹配你的微信名字,但是群聊@你是你群聊中的备注.当然这个可以通过改规则的正则来修复,我是比较简单的把我群聊的备注给删了.只是测试能成就行~ 顺便给我的微信好友们体验了一小时GPT的对话 图7 图7"},{"title":"使用GPT当作代码片段仓库","path":"/2023/04/17/使用GPT当作代码片段仓库/","content":"有些简单的代码片段其实是想保存下来的,之前有了解过一些工具,不过想用的性质不高,一方面是要收费,一方面积极性不高,也是因为一些内容一搜就知道了.不过今天在问GPT一个问题的时候,我突然想到:既然… 有些简单的代码片段其实是想保存下来的,之前有了解过一些工具,不过想用的性质不高,一方面是要收费,一方面积极性不高,也是因为一些内容一搜就知道了.不过今天在问GPT一个问题的时候,我突然想到:既然GPT是保存上下文的,那我能不能用它来保存代码片段呢?并且询问也比较方面,而且就算有我没有保存的片段,我也可以直接让它智能提示给我.那么即刻开干! […]"},{"title":"2023年2月阅读清单","path":"/2023/03/03/2023年2月阅读清单/","content":"weekly&#x2F;4.精读《AsyncAwait 优越之处》.md at master · ascoders&#x2F;weekly (github.com)weekly&#x2F;6.精读《JavaScript 错误… weekly&#x2F;4.精读《AsyncAwait 优越之处》.md at master · ascoders&#x2F;weekly (github.com) weekly&#x2F;6.精读《JavaScript 错误堆栈处理》.md at master · ascoders&#x2F;weekly (github.com) weekly&#x2F;36.精读《When You “Git” in Trouble- a Version Control Story》.md at master · ascoders&#x2F;weekly (github.com) weekly&#x2F;11.精读《前端调试技巧》.md at master · ascoders&#x2F;weekly (github.com) 条件JavaScript - JavaScript - 开发提示 (umaar.com)"},{"title":"2022年11月阅读列表","path":"/2023/02/22/2022年11月阅读列表/","content":"2022年11月阅读列表略读# 如何创建可重用和可配置的 Angular 组件# 使用 RxJs 停止对用户输入更改的冗余和不必要的 API 调用angular &amp; vite# 如何在 2022… 2022年11月阅读列表略读 # 如何创建可重用和可配置的 Angular 组件 # 使用 RxJs 停止对用户输入更改的冗余和不必要的 API 调用 angular &amp; vite # 如何在 2022 年成为 Angular Pro 开发人员——遵循 11 个简单步骤。 # 您可能从未使用过的最有用的 Angular 功能 # 使用两行代码在 Angular 中延迟加载图像 # Angular 中要避免的订阅和实践 Traits You Can Change, and Traits You Can’t | Stay SaaSy 细读 # Angular DOM 操作：ElementRef、TemplateRef 和 ViewContainerRef # 使用 @Log() 装饰器进行 Angular 方法日志记录 # 不要在 Angular 中绑定方法！ # 性能优化技术——角度方式。 # 深入研究 RxJs switchMap 运算符：它是如何工作的？ # 高阶 RxJs 映射运算符综合指南：switchMap、mergeMap、concatMap（和 excludeMap [# 角度变化检测——它是如何工作的？]("},{"title":"微前端实施方案","path":"/2023/01/31/微前端实施方案/","content":"介绍微前端微前端的概念是由 ThoughtWorks 在2016年提出的，它借鉴了微服务的架构理念，核心在于将一个庞大的前端应用拆分成多个独立灵活的小型应用，每个应用都可以独立开发、独立运行、独… 介绍微前端微前端的概念是由 ThoughtWorks 在2016年提出的，它借鉴了微服务的架构理念，核心在于将一个庞大的前端应用拆分成多个独立灵活的小型应用，每个应用都可以独立开发、独立运行、独立部署，再将这些小型应用融合为一个完整的应用，或者将原本运行已久、没有关联的几个应用融合为一个应用。微前端既可以将多个项目融合为一，又可以减少项目之间的耦合，提升项目扩展性，相比一整块的前端仓库，微前端架构下的前端仓库倾向于更小更灵活。 它主要解决了两个问题： 1、随着项目迭代应用越来越庞大，难以维护。 2、跨团队或跨部门协作开发项目导致效率低下的问题。 image.png image.png 开源框架字节跳动: Garfish 京东: micro-app 蚂蚁金服: qiankun (qiankun是基于 single-spa 的一层封装) 比较Garfish优势 自实现 提供缓存 沙盒功能 劣势 需要配置的配置项较多 基座应用必须为react 懒加载、刷新有时有奇怪的问题 不支持嵌套(子应用不能既是主又是子) micro-app优势 基于webComponent技术 嵌入无需新增依赖 应用无限制 沙盒功能 预加载 劣势 静态资源有时会有问题 angular子应用无法使用懒加载 不支持嵌套(子应用不能既是主又是子) 鉴于实际上手难度以及使用场景我们决定基于micro-app来实现我们的微前端方案 实操主应用(预算planning项目)1、安装依赖1npm i @micro-zoe/micro-app --save 2、在入口处引入123456789101112131415161718// index.jsimport microApp from &#x27;@micro-zoe/micro-app&#x27;microApp.start()// 实际代码(main.js)import &#123; enableProdMode &#125; from &#x27;@angular/core&#x27;;import &#123; platformBrowserDynamic &#125; from &#x27;@angular/platform-browser-dynamic&#x27;;import &#123; AppModule &#125; from &#x27;./app/app.module&#x27;;import &#123; environment &#125; from &#x27;./environments/environment&#x27;;// entryimport microApp from &#x27;@micro-zoe/micro-app&#x27;microApp.start()if (environment.production) &#123; enableProdMode();&#125;platformBrowserDynamic().bootstrapModule(AppModule) .catch((err) =&gt; console.error(err)); 3、增加对WebComponent的支持在app/app.module.ts中添加CUSTOM_ELEMENTS_SCHEMA到@NgModule.schemas 12345// app/app.module.tsimport &#123; NgModule, CUSTOM_ELEMENTS_SCHEMA &#125; from &#x27;@angular/core&#x27;;@NgModule(&#123; schemas: [CUSTOM_ELEMENTS_SCHEMA],&#125;) 4、分配路由给子应用1234567891011121314151617181920212223242526272829303132333435// app/app-routing.module.tsimport &#123; NgModule &#125; from &#x27;@angular/core&#x27;;import &#123; RouterModule, Routes &#125; from &#x27;@angular/router&#x27;;import &#123; MyAngularComponent &#125; from &quot;./my-angular/my-angular.component&quot;;import &#123; MyReactComponent &#125; from &quot;./my-react/my-react.component&quot;;import &#123; MyVueComponent &#125; from &quot;./my-vue/my-vue.component&quot;;const routes: Routes = [ &#123; // 👇 非严格匹配，/examples/angular/* 都指向 my-angular 页面 path: &#x27;examples/angular&#x27;, children: [&#123; path: &#x27;**&#x27;, component: MyAngular &#125;] &#125;, &#123; path: &#x27;examples/react&#x27;, children: [&#123; path: &#x27;**&#x27;, component: MyReactComponent &#125;] &#125;, &#123; path: &#x27;examples/vue&#x27;, children: [&#123; path: &#x27;**&#x27;, component: MyVueComponent &#125;] &#125;,];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule],&#125;)export class AppRoutingModule &#123; &#125; 5、在页面中嵌入子应用 123456789&lt;micro-app disableScopecss name=&#x27;app-angular&#x27; url=&#x27;http://localhost:3000/&#x27; baseroute=&#x27;/examples/angular&#x27;&gt;&lt;/micro-app&gt;&lt;!-- app/my-vue/my-vue.component.html --&gt;&lt;micro-app disableScopecss name=&#x27;app-vue&#x27; url=&#x27;http://localhost:8080/&#x27; baseroute=&#x27;/examples/vue&#x27;&gt;&lt;/micro-app&gt;&lt;!-- app/my-react/my-react.component.html --&gt;&lt;micro-app disableScopecss name=&#x27;app-react&#x27; url=&#x27;http://localhost:3001/&#x27; baseroute=&#x27;/examples/react&#x27;&gt;&lt;/micro-app&gt; 子应用Angular1、关闭热更新123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;ng serve --live-reload false&quot;,&#125;, 2、设置基础路由(如果基座是history路由，子应用是hash路由，这一步可以省略)123456789101112131415161718// app/app-routing.module.tsimport &#123; NgModule &#125; from &#x27;@angular/core&#x27;;import &#123; RouterModule, Routes &#125; from &#x27;@angular/router&#x27;;import &#123; APP_BASE_HREF &#125; from &#x27;@angular/common&#x27;;const routes: Routes = [...];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule], // 👇 设置基础路由 providers: [&#123; provide: APP_BASE_HREF, // angular子应用实测需要此中方式获取路径,可能是文档更新不齐全 // @ts-ignore __MICRO_APP_BASE_ROUTE__ 为micro-app传入的基础路由 useValue: (window[&quot;__MICRO_APP_PROXY_WINDOW__&quot;] &amp;&amp; window[&quot;__MICRO_APP_PROXY_WINDOW__&quot;][&quot;__MICRO_APP_BASE_ROUTE__&quot;]) || &#x27;/&#x27;, &#125;]&#125;)export class AppRoutingModule &#123; &#125; 3、设置publicPath步骤1: 在子应用src目录下创建名称为public-path.js的文件，并添加如下内容 12345// __MICRO_APP_ENVIRONMENT__和__MICRO_APP_PUBLIC_PATH__是由micro-app注入的全局变量if (window[&quot;__MICRO_APP_PROXY_WINDOW__&quot;] &amp;&amp; window[&quot;__MICRO_APP_PROXY_WINDOW__&quot;][&quot;__MICRO_APP_ENVIRONMENT__&quot;]) &#123; // eslint-disable-next-line __webpack_public_path__ = window[&quot;__MICRO_APP_PROXY_WINDOW__&quot;][&quot;__MICRO_APP_PUBLIC_PATH__&quot;]&#125; 步骤2: 在子应用入口文件的最顶部引入public-path.js 12// entryimport &#x27;./public-path&#x27; 4、监听卸载子应用被卸载时会接受到一个名为unmount的事件，在此可以进行卸载相关操作。 123456789101112// main.tslet app = null;platformBrowserDynamic() .bootstrapModule(AppModule) .then((res: NgModuleRef&lt;AppModule&gt;) =&gt; &#123; app = res &#125;)// 监听卸载操作window.addEventListener(&#x27;unmount&#x27;, function () &#123; app.destroy(); app = null;&#125;) React1、设置基础路由(如果基座是history路由，子应用是hash路由，这一步可以省略)12345678// router.jsimport &#123; BrowserRouter, Switch, Route &#125; from &#x27;react-router-dom&#x27;export default function AppRoute () &#123; return ( // 👇 设置基础路由，如果没有设置baseroute属性，则window.__MICRO_APP_BASE_ROUTE__为空字符串 &lt;BrowserRouter basename=&#123;window.__MICRO_APP_BASE_ROUTE__ || &#x27;/&#x27;&#125;&gt; ... &lt;/BrowserRouter&gt; )&#125; 或者 1234567891011// index.jsconst router = createBrowserRouter([ &#123; path: &#x27;/&#x27;, element: &lt;App /&gt; &#125;], &#123; // @ts-ignore basename: (window[&#x27;__MICRO_APP_BASE_ROUTE__&#x27;]) || &#x27;/&#x27; &#125;) 2、设置publicPath步骤1: 在子应用src目录下创建名称为public-path.js的文件，并添加如下内容 12345// __MICRO_APP_ENVIRONMENT__和__MICRO_APP_PUBLIC_PATH__是由micro-app注入的全局变量if (window.__MICRO_APP_ENVIRONMENT__) &#123; // eslint-disable-next-line __webpack_public_path__ = window.__MICRO_APP_PUBLIC_PATH__&#125; 步骤2: 在子应用入口文件的最顶部引入public-path.js 12// entryimport &#x27;./public-path&#x27; 3、监听卸载123456子应用被卸载时会接受到一个名为unmount的事件，在此可以进行卸载相关操作。window.addEventListener(&#x27;unmount&#x27;, function () &#123; root.unmount() // react 18 // ReactDOM.unmountComponentAtNode(document.getElementById(&#x27;root&#x27;))&#125;) Vue1、设置跨域支持1234567891011在vue.config.js中添加配置const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, devServer: &#123; headers: &#123; &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;, &#125; &#125;&#125;) 2、设置基础路由(如果基座是history路由，子应用是hash路由，这一步可以省略)12345678// main.jsimport &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;import routes from &#x27;./router&#x27;const router = createRouter(&#123; // 👇 __MICRO_APP_BASE_ROUTE__ 为micro-app传入的基础路由 history: createWebHistory(window.__MICRO_APP_BASE_ROUTE__ || process.env.BASE_URL), routes,&#125;) 3、设置publicPath步骤1: 在子应用src目录下创建名称为public-path.js的文件，并添加如下内容 12345// __MICRO_APP_ENVIRONMENT__和__MICRO_APP_PUBLIC_PATH__是由micro-app注入的全局变量if (window.__MICRO_APP_ENVIRONMENT__) &#123; // eslint-disable-next-line __webpack_public_path__ = window.__MICRO_APP_PUBLIC_PATH__&#125; 步骤2: 在子应用入口文件的最顶部引入public-path.js 12// entryimport &#x27;./public-path&#x27; 4、监听卸载123456789子应用被卸载时会接受到一个名为unmount的事件，在此可以进行卸载相关操作。// main.jsconst app = createApp(App)app.mount(&#x27;#app&#x27;)// 监听卸载操作window.addEventListener(&#x27;unmount&#x27;, function () &#123; app.unmount()&#125;) 数据通信一、子应用获取来自基座应用的数据micro-app会向子应用注入名称为microApp的全局对象，子应用通过这个对象和基座应用进行数据交互。 有两种方式获取来自基座应用的数据： 方式1：直接获取数据 1const data = window.microApp.getData() // 返回基座下发的data数据 方式2：绑定监听函数 1234567891011121314151617function dataListener (data) &#123; console.log(&#x27;来自基座应用的数据&#x27;, data)&#125;/**- 绑定监听函数，监听函数只有在数据变化时才会触发- dataListener: 绑定函数- autoTrigger: 在初次绑定监听函数时如果有缓存数据，是否需要主动触发一次，默认为false- !!!重要说明: 因为子应用是异步渲染的，而基座发送数据是同步的，- 如果在子应用渲染结束前基座应用发送数据，则在绑定监听函数前数据已经发送，在初始化后不会触发绑定函数，- 但这个数据会放入缓存中，此时可以设置autoTrigger为true主动触发一次监听函数来获取数据。 */ window.microApp.addDataListener(dataListener: Function, autoTrigger?: boolean) // 解绑监听函数 window.microApp.removeDataListener(dataListener: Function) // 清空当前子应用的所有绑定函数(全局数据函数除外) window.microApp.clearDataListener() 二、子应用向基座应用发送数据12// dispatch只接受对象作为参数window.microApp.dispatch(&#123;type: &#x27;子应用发送的数据&#x27;&#125;) 三、基座应用向子应用发送数据基座应用向子应用发送数据有两种方式： 方式1: 通过data属性发送数据Vue(Angular类似)12345678910111213141516&lt;template&gt; &lt;micro-app name=&#x27;my-app&#x27; url=&#x27;xx&#x27; :data=&#x27;dataForChild&#x27; // data只接受对象类型，数据变化时会重新发送 /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; dataForChild: &#123;type: &#x27;发送给子应用的数据&#x27;&#125; &#125; &#125;&#125;&lt;/script&gt; React在React中我们需要引入一个polyfill。 在元素所在的文件顶部添加polyfill(注释也要复制)。 123/** @jsxRuntime classic *//** @jsx jsxCustomEvent */import jsxCustomEvent from &#x27;@micro-zoe/micro-app/polyfill/jsx-custom-event&#x27; 开始使用 12345&lt;micro-app name=&#x27;my-app&#x27; url=&#x27;xx&#x27; data=&#123;this.state.dataForChild&#125; // data只接受对象类型，采用严格对比(===)，当传入新的data对象时会重新发送/&gt; 方式2: 手动发送数据手动发送数据需要通过name指定接受数据的子应用，此值和元素中的name一致。 123import microApp from &#x27;@micro-zoe/micro-app&#x27;// 发送数据给子应用 my-app，setData第二个参数只接受对象类型microApp.setData(&#x27;my-app&#x27;, &#123;type: &#x27;新的数据&#x27;&#125;) 四、基座应用获取来自子应用的数据基座应用获取来自子应用的数据有三种方式： 方式1：直接获取数据12import microApp from &#x27;@micro-zoe/micro-app&#x27;const childData = microApp.getData(appName) // 返回子应用的data数据 方式2: 监听自定义事件 (datachange)Vue(Angular同理)1234567891011121314151617&lt;template&gt; &lt;micro-app name=&#x27;my-app&#x27; url=&#x27;xx&#x27; // 数据在事件对象的detail.data字段中，子应用每次发送数据都会触发datachange @datachange=&#x27;handleDataChange&#x27; /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; handleDataChange (e) &#123; console.log(&#x27;来自子应用的数据：&#x27;, e.detail.data) &#125; &#125;&#125;&lt;/script&gt; React在React中我们需要引入一个polyfill。 在元素所在的文件顶部添加polyfill(注释也要复制)。 123/** @jsxRuntime classic *//** @jsx jsxCustomEvent */import jsxCustomEvent from &#x27;@micro-zoe/micro-app/polyfill/jsx-custom-event&#x27; 开始使用 123456&lt;micro-app name=&#x27;my-app&#x27; url=&#x27;xx&#x27; // 数据在event.detail.data字段中，子应用每次发送数据都会触发datachange onDataChange=&#123;(e) =&gt; console.log(&#x27;来自子应用的数据：&#x27;, e.detail.data)&#125;/&gt; 方式3: 绑定监听函数123456789101112131415161718绑定监听函数需要通过name指定子应用，此值和&lt;micro-app&gt;元素中的name一致。import microApp from &#x27;@micro-zoe/micro-app&#x27;function dataListener (data) &#123; console.log(&#x27;来自子应用my-app的数据&#x27;, data)&#125;/**- 绑定监听函数- appName: 应用名称- dataListener: 绑定函数- autoTrigger: 在初次绑定监听函数时如果有缓存数据，是否需要主动触发一次，默认为false */ microApp.addDataListener(appName: string, dataListener: Function, autoTrigger?: boolean) // 解绑监听my-app子应用的函数 microApp.removeDataListener(appName: string, dataListener: Function) // 清空所有监听appName子应用的函数 microApp.clearDataListener(appName: string) DEMO 依赖版本: “@micro-zoe&#x2F;micro-app”: “^0.8.10” 内部项目就不展示了 Angular主应用(预算) React子应用 Vue子应用 Angular子应用"},{"title":"2022年10月阅读列表","path":"/2022/11/01/2022年10月阅读列表/","content":"2022年10月阅读列表略读一文看懂any，never，void和unknown的区别 - 掘金科技爱好者周刊（第 222 期）：四十年编程感想 - 阮一峰的网络日志科技爱好者周刊（第 223 … 2022年10月阅读列表略读 一文看懂any，never，void和unknown的区别 - 掘金 科技爱好者周刊（第 222 期）：四十年编程感想 - 阮一峰的网络日志 科技爱好者周刊（第 223 期）：程序员需要担心裁员吗？ - 阮一峰的网络日志 从选购到使用，让 3D 打印机打开新世界的大门 - 少数派 科技爱好者周刊（第 224 期）：Figma 为什么赢了 Sketch - 阮一峰的网络日志 Why Are We Addicted To Our Phones? https://staysaasy.com/product/2022/09/16/why-figma-is-special.html Build Your Career on Dirty Work | Stay SaaSy Node CLI工具原理解析 - 掘金 【前端&amp;运维那点事儿】八：迈向Shell的第四步：算数运算与数组 - 掘金 https://blog.angular.io/modern-css-in-angular-layouts-4a259dca9127 《 关于我用拓展运算符把项目搞崩这件事 》 - 掘金 细读 面试官问我什么是浏览器层爆炸？ - 掘金 https://alumni.media.mit.edu/~cahn&#x2F;life&#x2F;gian-carlo-rota-10-lessons.html"},{"title":"如何在Angular中兼容CommonJS/AMD/UMD","path":"/2022/10/27/如何在Angular中兼容CommonJS-AMD-UMD/","content":"在导入类似 moment 这样的开发工具时,因为没有es的import导入,所以我们可能会使用import * as moment from ‘moment 在导入类似 moment 这样的开发工具时,因为没有es的import导入,所以我们可能会使用 1import * as moment from &#x27;moment […]"},{"title":"2022年9月阅读清单","path":"/2022/09/30/2022年9月阅读清单/","content":"2022年9月阅读清单收获Promise永久Pending状态造成内存泄漏 - 掘金💯💯💯 原来 Base64 如此简单！！！ - 掘金硬核基础编码篇（一）烫烫烫烫烫烫 - 掘金淦，为什么 &amp;q… 2022年9月阅读清单收获 Promise永久Pending状态造成内存泄漏 - 掘金 💯💯💯 原来 Base64 如此简单！！！ - 掘金 硬核基础编码篇（一）烫烫烫烫烫烫 - 掘金 淦，为什么 “𠮷𠮷𠮷”.length !&#x3D;&#x3D; 3 - 掘金 TS 类型体操还能这么玩，太秀了！ - 掘金 git为什么文件换名后会丢失跟踪记录？ - 知乎 https:&#x2F;&#x2F;medium.com&#x2F;@alet.aurelien&#x2F;hexagonal-architecture-with-angular-7e4d070155ea 闲谈 ResizeObserver Api监听DOM尺寸变化 - 掘金 https://sergeygultyayev.medium.com/sass-variables-vs-css-custom-properties-c0adc01c0624 科技爱好者周刊（第 221 期）：全世界最繁荣的行业 - 阮一峰的网络日志 利用console提高写bug的效率 - 掘金 What is the Event Loop in JavaScript? - 30 seconds of code 为什么B站的弹幕可以不挡人物 - 掘金 非大厂的我们，要如何去搞前端基建？ - 掘金 CHALK - 美化 node 输出的神器 - 掘金 前端实现docx、pdf格式文件在线预览 - 掘金 不会时间管理、手摸手带你开发一个提效工具！！！ - 掘金 扯淡 你会用RxJS吗？【细说 RxJS中的 Operators】 - 掘金 你会用RxJS吗？【初识 RxJS中的Observable和Observer】 - 掘金 2022年国内外前端发展态势 - 掘金 硬核基础二进制篇（二）位运算 - 掘金 Electron的用武之地 - 掘金"},{"title":"2022年8月阅读清单","path":"/2022/09/01/2022年8月阅读清单/","content":"2022年8月阅读清单收获淘系前端团队DNS 查询原理详解 - 阮一峰的网络日志异或运算 XOR 教程 - 阮一峰的网络日志How SHA-256 Works Step-by-Step | Bo… 2022年8月阅读清单收获 淘系前端团队 DNS 查询原理详解 - 阮一峰的网络日志 异或运算 XOR 教程 - 阮一峰的网络日志 How SHA-256 Works Step-by-Step | Boot.dev The Front-End Developer’s Guide to the Terminal https://lambdaisland.com/blog/2022-02-17-the-fg-command Angular 2 Decorators(装饰器) - part 1 · Issue #9 · semlinker&#x2F;angular2-ionic2 · GitHub 雷军2022年度最新演讲：熬过绝望低谷，你便无人能敌_盘古_金山_公司 Thread by @coolXiao on Thread Reader App – Thread Reader App 数据流是否需要在ngOnInit中初始化 How to Be a Senior Leader | Stay SaaSy Management Scrutiny | Stay SaaSy ::ng-deep 的替代方法之css变量 如何说出坏消息 Small Performance Cues | Stay SaaSy npm 如何处理依赖与依赖冲突 · 语雀 闲谈 Understanding Volta | Volta https://medium.com/generic-ui/the-new-way-of-subscribing-in-an-angular-component-f74ef79a8ffc https://sergeygultyayev.medium.com/how-to-make-angular-applications-more-robust-855deec98fbc https://javascript.plainenglish.io/angular-interceptors-a-complete-guide-7294e2317ecf 科技爱好者周刊（第 212 期）：人生不短 - 阮一峰的网络日志 The Most Important Performance Management Rule For Software Engineers | Stay SaaSy Be less technical https://www.1024nav.com/front-news/rush-is-furture Browser in the Dark: flashlights with CSS and canvas https://gitexplorer.com/ 2022-30: 如何维护一个开源项目 科技爱好者周刊（第 218 期）：葡萄酒，樱花，全球变暖 - 阮一峰的网络日志 Ways to Expand Your SaaS Business | Stay SaaSy 设计更好的 Angular 组件 徐辛承：快手增长团队的前端工程化思考 JavaScript Source Map 详解 - 阮一峰的网络日志 A closer look at SharedModule| Chau Tran 你不知道的 import type toLocaleString 也太好用了吧！ - 掘金 面试官：说说哪些浏览器事件不会冒泡 - 掘金 扯淡 浅谈：为啥vue和react都选择了Hooks🏂？ - 掘金 字节序探析：大端与小端的比较 - 阮一峰的网络日志 容错，高可用和灾备 - 阮一峰的网络日志 Debugging My Work Health | Stay SaaSy I was wrong. CRDTs are the future RxAngular State, The Component Reactive Store | Marmicode Tasting Session #1 - YouTube 改善角度初始加载时间 科技爱好者周刊（第 219 期）：如何防止帐号被黑 - 阮一峰的网络日志 ReScript 与 TypeScript，谁是前端圈的“当红辣子鸡” - 掘金 网易严选多端组件库OSSA正式开源 - 掘金 TypeScript Monorepo 最佳实践 - 掘金"},{"title":"创建前端PNPM自定义Docker镜像并上传至服务器使用","path":"/2022/08/18/创建前端PNPM自定义Docker镜像并上传至服务器使用/","content":"本地创建node镜像并提前安装pnpm环境背景因为需要在项目中使用pnpm包管理工具，并且通过only-allow强制使用pnpm 引出 ci 也需要使用 pnpm 但是介于网络问题，安装一直错误，并且因为安全问题，也不能使服务器连接外网。 解决方案在一台网络正常的机器上构建一个已经预装好pnpm的docker镜像，并上传到服务器，使用本地镜像来解决问题 环境要求 docker 网络正常 步骤构建自定义镜像本地新建目录来进行如下操作 12345# 基于基础的node镜像FROM node:16.13.2RUN curl -f https://get.pnpm.io/v6.16.js | node - add --global pnpm@7 \\ &amp;&amp; pnpm config set store-dir ~/.pnpm-store 开始构建 1docker build -t name:tag . 验证 123456$ docker run -itd --name test node16:pnpm$ docker ps // 获取id$ docker exec -it id /bin/bash// node -v &amp;&amp; pnpm -v work! 开始创建镜像文件 1$ docker save -o exampleName.tar name:tag 传输至服务器 1$ scp exampleName.tar root@hostname:/data 服务器导入镜像 1$ docker load &lt; exampleName.tar 查看 1$ docker images 可能需要重命名 $ $docker tag IMAGEID(镜像id) REPOSITORY:TAG(仓库：标签) 删除 $ $docker rmi IMAGEID 或者 docker rmi REPOSITORY:TAG"},{"title":"CI 中 Cypress 下载超时处理方案","path":"/2022/08/18/CI-中-Cypress-下载超时处理方案/","content":"前言在项目中我们依赖了cypress，在跑ci&#x2F;cd时，时常遇到超时错误。 最终定位问题，我们发现时这个cypress插件会自己下载二进制版本，或者直接超时。 排查错误毫无疑问，我们一开始就定位到了网络问题。并且也通过日志定位了到了这个问题 1234567891011121314151617181920212223242526272829.../cypress@9.7.0/node_modules/cypress postinstall$ node index.js --exec install.../cypress@9.7.0/node_modules/cypress postinstall: Installing Cypress (version: 9.7.0).../cypress@9.7.0/node_modules/cypress postinstall: [STARTED] Task without title..../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] The Cypress App could not be downloaded..../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] .../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] Does your workplace require a proxy to be used to access the Internet? If so, you must configure the HTTP_PROXY environment variable before downloading Cypress. Read more: https://on.cypress.io/proxy-configuration.../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] .../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] Otherwise, please check network connectivity and try again:.../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] .../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] ----------.../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] .../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] URL: https://download.cypress.io/desktop/9.7.0?platform=linux&amp;arch=x64.../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] Error: read ETIMEDOUT.../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] .../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] ----------.../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] .../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] Platform: linux-x64 (Debian - 10.11).../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] Cypress Version: 9.7.0.../cypress@9.7.0/node_modules/cypress postinstall: The Cypress App could not be downloaded..../cypress@9.7.0/node_modules/cypress postinstall: Does your workplace require a proxy to be used to access the Internet? If so, you must configure the HTTP_PROXY environment variable before downloading Cypress. Read more: https://on.cypress.io/proxy-configuration.../cypress@9.7.0/node_modules/cypress postinstall: Otherwise, please check network connectivity and try again:.../cypress@9.7.0/node_modules/cypress postinstall: ----------.../cypress@9.7.0/node_modules/cypress postinstall: URL: https://download.cypress.io/desktop/9.7.0?platform=linux&amp;arch=x64.../cypress@9.7.0/node_modules/cypress postinstall: Error: read ETIMEDOUT.../cypress@9.7.0/node_modules/cypress postinstall: ----------.../cypress@9.7.0/node_modules/cypress postinstall: Platform: linux-x64 (Debian - 10.11).../cypress@9.7.0/node_modules/cypress postinstall: Cypress Version: 9.7.0.../cypress@9.7.0/node_modules/cypress postinstall: Failed ELIFECYCLE Command failed with exit code 1. 当然，比较简单的办法就是给服务器开通网络代理，不过，出于安全问题，不允采用。 通过查看cypress的官方文档，也得知了几种方案 跳过安装 缓存 CDN 镜像 社区论坛上反馈 cypress 的版本检查程序有问题，可以通过固定版本号来绕开一部分超时错误 当然比较实在的就是跳过和缓存，缓存的话，可以参考我的其他文章如何提供pnpm镜像环境[post cid&#x3D;”690” &#x2F;] 跳过安装比较实在，因为我们已经安装了node版本的cypress不再需要安装二进制版本了 妙手方案敲定，直接修改ci文件 12variables: CYPRESS_INSTALL_BINARY: 0 遗留问题安装一些依赖的时候依旧很吃网络环境。公司内部也通过verdaccio部署了自己的注册表，并且天然的提供缓存服务。所以乘着这次修改，直接一起转移过去吧。"},{"title":"2022年7月阅读清单","path":"/2022/08/11/2022年7月阅读清单/","content":"2022年7月阅读清单收获 如何移除你项目中99%的JS代码 - 掘金 解决跨域的几种方法 - 掘金 https://javascript.plainenglish.io/angular-route-parameters-a-simple-guide-88c69d54102c 小程序不让用 JS 解释器？那我再肛一次鹅厂 - 掘金 11+ chrome高级调试技巧，学会效率直接提升666% - 掘金 weekly&#x2F;191.精读《高性能表格》.md at master · ascoders&#x2F;weekly · GitHub https://www.telerik.com/blogs/angular-on-desktop https://www.telerik.com/blogs/how-to-desktop-2022 闲谈 如果能重来，你要选 Vite 还是 Webpack ？ - 掘金 无虚拟 DOM 版 Vue 即将到来 - 掘金 花十分钟，迅速了解ES13的全部特性 - 掘金 如何实现字体小于 12px 以及边框 0.5 px？ - 掘金 前端新宠 Svelte 带来哪些新思想？赶紧学起来！ - 掘金 扯淡 谈谈干前端三年的几点感受 - 掘金 雷军做程序员时写的博客，太牛了。。 - 掘金 前端必备知识之Nginx - 掘金 API 请求慢？这次锅真不在后端 - 掘金 高级前端必须掌握的package.json字段知识 - 掘金 前端开发者的登天梯 - babel - 掘金 JavaScript写一个 once 函数，让传入函数只执行一次 - 掘金 33个非常实用的JavaScript一行代码，建议收藏！ - 掘金"},{"title":"storybook 编写指南","path":"/2022/08/11/storybook-编写指南/","content":"storybook 编写指南 所有story相关的导入导出以及文件名称，官方推荐首字母大写 storybook 指南 argTypes 参数详情 overview 举个 🌰 e.g. 控件参数详解 再举个 🌰 e.g. 不想&#x2F;想全部给你看 👀 code source 部分 描述部分 我想写独立的文档 argTypes 参数详情 overview 字段 说明 name 同字段名,可省略 type.required boolean description 描述 defaultValue 数据:默认值 table.disable 不在文档中出现 table.category 分类分组名称 table.type.summary 类型的简单描述 table.type.detail 类型的长描述 table.defaultValue.summary 显示:默认值 table.defaultValue.detail 显示:默认值详细说明 control 禁用控制器 e.g false control.type 控件类型(需要有[数据]默认值) e.g. null \\ options 控件类型为 radio 时的值数组 举个 🌰 e.g.1234567891011121314151617181920Primary.argTypes = &#123; fNotFoundImage: &#123; name: &#x27;fNotFoundImage&#x27;, type: &#123; required: false, &#125;, table: &#123; disable: true, defaultValue: &#123; summary: &#x27;null&#x27;, &#125;, type: &#123; summary: &#x27;string | TemplateRef&lt;void&gt;&#x27; &#125; &#125;, description: &#x27;图片url&#x27;, defaultValue: null, options: [null, &#x27;https://www.sass.hk/images/sass.png&#x27;], control: &#123; type: &#x27;radio&#x27; &#125;, // 可简写成 =&gt; control: &#x27;radio&#x27; &#125;&#125;; 控件参数详解 data type 数据类型 control type 控件类型 description 描述 options 选项 array array serialize array into a comma-separated string inside a textbox separator boolean boolean checkbox input - number number a numberic text box input min, max, step - range a range slider input min, max, step object object json editor text input - enum radio radio buttons input options - inline-radio inline radio buttons input options - check multi-select checkbox input options - inline-check multi-select inline checkbox input options - select select dropdown input options - multi-select multi-select dropdown input options string text simple text input - - color color picker input that assumes strings are color values - - date date picker input - 再举个 🌰 e.g.123456789101112export default &#123; title: &#x27;Gizmo&#x27;, component: Gizmo, argTypes: &#123; width: &#123; type: &#x27;range&#x27;, min: 400, max: 1200, step: 50 &#125;; &#125;,&#125;; 不想&#x2F;想全部给你看 👀有些内容很隐私&#x2F;重要，你就是不想&#x2F;需要给调用的人看到。 那么你可以使用 include 和 exclude 配置 controls, 可以写数字串数组或正则表达式 举个 🌰 e.g. 123456789101112131415161718192021222324252627282930313233343536373839import &#123; YourComponent &#125; from &#x27;./YourComponent&#x27;; export default &#123; title: &#x27;YourComponent&#x27;, component: YourComponent,&#125;;const Template = (args) =&gt; (&#123; //👇 Your template goes here&#125;);ArrayInclude = Template.bind(&#123;&#125;)ArrayInclude.parameters = &#123; controls: &#123; include: [&#x27;foo&#x27;, &#x27;bar&#x27;] &#125;&#125;;RegexInclude = Template.bind(&#123;&#125;)RegexInclude.parameters = &#123; controls: &#123; include: /^hello*/ &#125;&#125;;ArrayExclude = Template.bind(&#123;&#125;)ArrayExclude.parameters = &#123; controls: &#123; exclude: [&#x27;foo&#x27;, &#x27;bar&#x27;] &#125;&#125;; RegexExclude = Template.bind(&#123;&#125;)RegexExclude.parameters = &#123; controls: &#123; exclude: /^hello*/ &#125;&#125;; 当然比较本的办法隐藏起来就是在 ts 文件中追加注释 @ignore code source 部分有时候自动带出 code source 并不足以满足我们的要求，需要我们自定义这个时候就可以使用 docs.source.code 和可选参数 docs.source.language 123456789101112131415161718192021222324// Button.stories.js|jsx|ts|tsx import &#123; Button &#125; from &#x27;./Button&#x27;; export default &#123; /* 👇 The title prop is optional. * See https://storybook.js.org/docs/react/configure/overview#configure-story-loading * to learn how to generate automatic titles */ title: &#x27;Button&#x27;, component: Button,&#125;; export const Template = (args) =&gt; (&#123; //👇 Your template goes here&#125;); export const CustomSource = Template.bind(&#123;&#125;); CustomSource.parameters = &#123; docs: &#123; language: &#x27;ts&#x27;, // 高亮语言 format: true, // 格式化 source: &#123; code: &#x27;Some custom string here&#x27;, &#125;, &#125;,&#125;; 描述部分 Storybook 提取组件的描述并将其呈现在页面顶部。它是从 docgen 组件自动生成的支持的框架基于组件的源代码。下面是一个精简的例子和可用的选项。 12345678910111213141516171819202122232425262728293031// Button.stories.js|jsx|ts|tsx import &#123; Button &#125; from &#x27;./Button&#x27;; export default &#123; /* 👇 The title prop is optional. * See https://storybook.js.org/docs/react/configure/overview#configure-story-loading * to learn how to generate automatic titles */ title: &#x27;Button&#x27;, component: Button, parameters: &#123; docs: &#123; description: &#123; component: &#x27;Some component _markdown_&#x27;, &#125;, &#125;, &#125;,&#125;; const Template = (args) =&gt; (&#123; //👇 Your template goes here&#125;); export const WithStoryDescription = Template.bind(&#123;&#125;);WithStoryDescription.parameters = &#123; docs: &#123; description: &#123; story: &#x27;Some story **markdown**&#x27;, &#125;, &#125;,&#125;; 选项 描述 component 覆盖默认组件描述。description: { component:’An example component description’ } story 覆盖故事描述。 description: { story: ‘An example story description’ } 我想写独立的文档 有的同学想写和本文档同级别的内容 在项目中你觉得适合的任意位置创建一个 MyComponent.stories.mdx 文件的内容 名称MyComponent自行修改 123456789&lt;!-- MyComponent.stories.mdx --&gt; import &#123; Meta &#125; from &#x27;@storybook/addon-docs&#x27;; # Some header And Markdown here &lt;Meta title=&quot;Docs/MyComponent&quot;/&gt;"},{"title":"Angular中库与应用共享服务遇到的问题以及解决方案","path":"/2022/07/08/Angular中库与应用共享服务遇到的问题以及解决方案/","content":"Angular中库与应用共享服务遇到的问题以及解决方案背景随着项目的功能越来越多，我们计划抽离一些基础服务作为单一的库来整理优化项目结构，并且可以方便后期新开应用时更加方便的开发。 问题服务中涉及到国际化，我们想要的程度是： 能够一键切换语种 能够所有抽离的服务共享一个服务来设置国际化 用户使用时尽可能的不需要自己设置，或者只需要设置一次 方案方案一使用拓展fone-ui的翻译服务，但是舍弃了，不能一键，并且如果使用了此种方案，必须强制依赖fone-ui，这是我不能接受的。 方案二应用中常用的国际化方案是ngx-translate,并且通过查看文档，也是支持拓展的，支持一键切换（应用天然使用此库） demo核心库代码 1234567891011121314import &#123; Injectable, &#125; from &#x27;@angular/core&#x27;;import &#123; TranslateService &#125; from &#x27;@ngx-translate/core&#x27;;import zh_CN from &#x27;./zh-CN&#x27;;import en_US from &#x27;./en-US&#x27;;@Injectable(&#123; providedIn: &#x27;root&#x27;,&#125;)export class TestService &#123; constructor(private translate: TranslateService) &#123; this.translate.setTranslation(&#x27;zh-CN&#x27;, zh_CN, true); this.translate.setTranslation(&#x27;en-US&#x27;, en_US, true); &#125;&#125; 构建之后npm link 应用核心代码AppComponent 12345678910111213141516171819202122import &#123; Component &#125; from &#x27;@angular/core&#x27;;import &#123; TranslateService &#125; from &#x27;@ngx-translate/core&#x27;;const zh_CN = &#123; lindo: &#x27;lindo11111&#x27;,&#125;;const en_US = &#123; lindo: &#x27;lindo2222&#x27;,&#125;;@Component(&#123; selector: &#x27;my-test-app-root&#x27;, templateUrl: &#x27;./app.component.html&#x27;, styleUrls: [&#x27;./app.component.scss&#x27;],&#125;)export class AppComponent &#123; title = &#x27;test&#x27;; constructor(private translate: TranslateService) &#123; this.translate.setTranslation(&#x27;zh-CN&#x27;, zh_CN); this.translate.setTranslation(&#x27;en-US&#x27;, en_US); &#125;&#125; SubComponentComponent 1234567891011121314import &#123; Component, OnInit &#125; from &#x27;@angular/core&#x27;;import &#123; TranslateService &#125; from &#x27;@ngx-translate/core&#x27;;import &#123; TestService &#125; from &#x27;@caoxicheng/test&#x27;;@Component(&#123; selector: &#x27;my-test-app-sub-component&#x27;, templateUrl: &#x27;./sub-component.component.html&#x27;, styleUrls: [&#x27;./sub-component.component.scss&#x27;],&#125;)export class SubComponentComponent implements OnInit &#123; constructor(private translate: TranslateService, private test: TestService) &#123;&#125; ngOnInit(): void &#123;&#125;&#125; 项目启动之后直接错误 image.png 也去官方查看这个问题的描述 https://angular.cn/errors/NG0203 通过正常的办法没办法正常的注入依赖 也尝试过绕过去的办法，比如说 image.png 或者使用forwardRef关键字，均无效 曙光在查看官方的依赖提供者一章时看到了这段文字 要想根据运行前尚不可用的信息创建可变的依赖值，可以使用工厂提供者。 感觉可行，无非就是绕呗 修改后代码(SubComponentModule) 12345678910111213141516171819import &#123; NgModule &#125; from &#x27;@angular/core&#x27;;import &#123; CommonModule &#125; from &#x27;@angular/common&#x27;;import &#123; SubComponentComponent &#125; from &#x27;./sub-component.component&#x27;;import &#123; TranslateService &#125; from &#x27;@ngx-translate/core&#x27;;import &#123; TestService &#125; from &#x27;@lindo/test&#x27;;@NgModule(&#123; declarations: [SubComponentComponent], imports: [CommonModule], exports: [SubComponentComponent], providers: [ &#123; provide: TestService, useFactory: (translate: TranslateService) =&gt; new TestService(translate), deps: [TranslateService], &#125;, ],&#125;)export class SubComponentModule &#123;&#125; 遗留问题对于用户而言在注入的地方需要手动提供工厂函数，这一点也不优雅这是不能接受的。 所以说是否可以优化这个问题？"},{"title":"2022年6月阅读清单","path":"/2022/07/08/2022年6月阅读清单/","content":"2022年6月阅读清单收获 https://juejin.cn/post/7103905846337224711 浅聊偏函数 - 掘金 你还在直接用 localStorage 么？该提升下逼格了 - 掘金 Monorepo 原理浅探 - 掘金 https://mp.weixin.qq.com/s/qtIu-NHml_8wT3APDyuzXg Create a static file server with Node.js - 30 seconds of code 在uni-app中使用微软的文字转语音服务 - 掘金 图片优化不完全指北 - 掘金 如何快速在团队内做一次技术分享？ - 掘金 给女友写的，每日自动推送暖心消息 - 掘金 前端web实现（@、At、艾特）选人或引用数据 - 掘金 现代 CSS 解决方案：CSS 数学函数 前端监控的搭建步骤，别再一头雾水了！ 基于设计稿识别的可视化低代码系统实践 css伪类函数 :is() 和 :where() - 掘金 落地qiankun的诸多问题—-父子应用样式污染 - 掘金 为什么模块循环依赖不会导致死循环？CommonJS和ES Module的解决办法有什么不同？ - 掘金 My Wonderful HTML Email Workflow, using MJML and MDX for responsive emails GitHub - alivebao&#x2F;clean-code-js: JavaScript风格指南 闲谈Kafka到底有多高可靠？（RNG NB） - 掘金 冴羽答读者问：如果有机会，你会选择脱产学习深造吗？ - 掘金 JavaScript设计模式-适配器模式（11） - 掘金 oh-my-zsh让你的终端体验起飞！ - 掘金 为什么程序员应该有一台Mac个人电脑 - 掘金 Angular 项目里使用 scss 文件的一些技巧 - 掘金 取代前端er？PyScript到底是何方神圣！ - 掘金 我本地明明是好的啊？前端怎么本地复现线上问题？ - 掘金 🦊【通用体系】你司暴露的上传接口被黑产用来上传小视频？做一套安全的上传体系来防范吧！🦄️ - 掘金 好用不卡，这些插件和配置让你的 Webstorm 更牛逼！ - 掘金 line-height用了这么久，你真的了解他么 - 掘金 扯淡【架构师（第三十二篇）】 通用上传组件开发及测试用例 - 掘金 技术团队为什么要坚持开展技术分享会以及落地实施 - 掘金 前方高能！一个前端程序员的 README 能写到多好看 - 掘金 TypeScript查漏补缺(基础类型) - 掘金 【一库】妙啊！👺这个库组织npm脚本简直爆炸！ - 掘金"},{"title":"Error: Cannot call a namespace (moment) 的处理方案","path":"/2022/06/07/Error-Cannot-call-a-namespace-moment-的处理方案/","content":"提供一种曲线救国的思路 123import * as moment_ from &#x27;moment&#x27;;const moment = moment_;// 曲线救国 酌情修改下面参数 allowSyntheticDefaultImports skipLibCheck 参考 [scode type&#x3D;”share” size&#x3D;””]https://stackoverflow.com/questions/59735280/angular-8-moment-error-cannot-call-a-namespace-moment[/scode]"},{"title":"2022年5月阅读清单","path":"/2022/05/30/2022年5月阅读清单/","content":"2022年5月阅读清单收获 can x!&#x3D;&#x3D;x ? 你可能不知道的 Chrome Devtools 实用功能 - 掘金 如何根据后端返回的url下载json文件 - 掘金 type 和 interface 傻傻分不清楚？ - 掘金 https://mp.weixin.qq.com/s/UobubFEiukXrCmQu7OZIgQ The Surprising Truth About Pixels and Accessibility: should I use pixels or rems? Angular Community Meetup | May 2022 | Mini Bhati, Jeffry Houser, &amp; Colum Ferry - YouTube CSS 变量自动变色技术 - 掘金 闲谈 Taming Code Organization with Module Boundaries in Nx - YouTube 【第三十七期】2022-05-15 · Issue #39 · Geekhyt&#x2F;weekly · GitHub 扯淡"},{"title":"git提交时自动检测信息是否合法·中文指南","path":"/2022/03/10/git提交时自动检测信息是否合法·中文指南/","content":"安装1.依赖 1npm install --save-dev @commitlint/config-conventional @commitlint/cli husky 2.配置文件 在工程根目录下新建配置文件，名称为 commitlint.config.js。 当然也能直接一行命令 1echo &quot;module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125;&quot; &gt; commitlint.config.js commitlint.config.js 中添加配置信息 1module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125; 然后使用命令创建拦截脚本(可能会出错，建议检查一下内容) 1npx husky add .husky/commit-msg &quot;npx --no -- commitlint --edit $1&quot; 你会发现在.husky文件夹内出现一个commit-msg文件，里面内容是npx --no -- commitlint --edit &quot;$1&quot; 至此结束！ 小说明：如果某次提交想禁用 husky，可以添加参数 –no-verify 。git commit --no-verify -m &quot;xxx&quot;"},{"title":"2022年3月阅读清单","path":"/2022/03/03/2022年3月阅读清单/","content":"精读收获 互联网上如何快速找到资源 - 掘金 👨‍💻‍程序员如何提高工作效率+程序员健康指南👨‍💻‍ - 掘金 【敏捷5.1】规划的核心：用户故事 - 掘金 在使用地理定位API时，你需要知道什么？ - 掘金 npm发布包教程（一）：从npm说起 npm发布包教程（二）：发布包 npm发布包教程（三）：安装和加载原理 剖析npm的包管理机制（完整版） | ConardLi的blog 一篇文章教你搭建一个前后端分离（gitlab-cicd+docker+vue+django）的自动化部署的网站，干货满满！ - 掘金 GitLab CI&#x2F;CD+Gitlab-runner+docker的介绍与踩坑 - 掘金 https://zhuanlan.zhihu.com/p/184936276 你不知道的JavaScript中的5个JSON秘密功能 - 掘金 从 Google 离职了！ - 掘金 https://segmentfault.com/a/1190000018714929 webpack构建速度和体积优化策略 - 掘金 闲谈 我提交了一个 pr，竟然是为了吃 - 掘金 不要把政治带进开源项目 - 掘金 快24岁了，没什么目标（不才的21年年终总结） - 掘金 从头梳理，看看中国的 ICP 备案制度 - 掘金 程序员迁坟指南【西安 -&gt;上海之行实录】 - 掘金 产品线 - MBA智库百科 展望 分享几个你可能不知道的交互式Git命令 - 掘金 CPU调度算法 - 掘金 同事提出个我从未想过的问题，为什么Kubernetes要&amp;#34;多此一举&amp;#34;推出静态Pod概念？ - 掘金 计算机网络–物理层 - 掘金 https://jotadeveloper.medium.com/five-use-cases-where-a-npm-private-proxy-fits-in-your-workflow-632a81779c14 一次代码审计实战案例【思路流程】 - 掘金 https://mp.weixin.qq.com/s/6QJvzDroVPAy6KXd2hhvCw 「前端CI&#x2F;CD系列」第三篇：如何用建木CI构建前端项目并部署到CDN - 掘金 GitLab CI&#x2F;CD - 废物大师兄 - 博客园 TypeScript 官方：JavaScript 中直接支持类型！ - 掘金 GitHub - giltayar&#x2F;proposal-types-as-comments: ECMAScript proposal for type syntax that is erased - Stage 0 关于core-js的分包设计 - 掘金"},{"title":"如何编写好的提交信息","path":"/2022/02/25/如何编写好的提交信息/","content":"如何编写好的提交信息简介本文用来介绍在组件库开发的过程中，如何提交一个符合语法规则、团队约定和具有高可行性的提交信息。 接下来的操作默认读者使用 git 作为代码仓库。 快速上手12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt;// 空一行&lt;footer&gt; 进阶篇其中，Header是必需的，Body和Footer可以省略。 不管是哪一个部分，任何一行都不得超过72个字符。这是为了避免自动换行影响美观。 HeaderHeader部分只有一行，包括三个字段： type （必需）、scope（可选）、subject（必需） 1） type type 用于说明 commit 的类型，只允许使用下面的标识 feat：新功能 fix：修复一个错误 style：与样式相关的功能和更新 refactor：重构代码 test：与测试相关的一切提交 docs：与文档相关的一切提交 chore：不包含生产代码变动的定期代码维护 perf:：与性能优化相关的 build：与构建相关 ci：持续集成相关的一切提交 revert：回退代码（一般由程序自动带出） 如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test、perf、build、ci、revert）在我们项目中不会放入 Change Log 中 2）scope scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 3） subject subject是 commit 目的的简短描述，不超过50个字符。 主题和内容以一个空行分隔 主题行结束不用标点 主题行使用祈使语气 仅使用必要的标点符号 BodyBody 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。 1234567More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent 有3个注意点。 （1）使用第一人称现在时，比如使用change而不是changed或changes。 （2）应该说明代码变动的动机，以及与以前行为的对比。 （3）应该默认你的读者不了解问题的初衷。 FooterFooter 部分提供相关文章和其它资源的链接和第三方工具的关键字 注意点 内容每行72个字 永远不要认为大家都知道或理解最初的问题是什么，尽可能添加他的描述 确保你的代码新人也能快速理解 遵循团队的提交约定 参阅 Commit message 和 Change log 编写指南 - 阮一峰的网络日志 GitHub - conventional-changelog&#x2F;commitlint: 📓 Lint commit messages How to Write a Git Commit Message"},{"title":"「SEMVER」语义版本规范","path":"/2022/02/16/「SEMVER」语义版本规范/","content":"[SEMVER]语义版本规范semver&#x2F;semver.org提出一个语义版本规范，用于规范版本的生成和设置 英文版：Semantic Versioning 2.0.0 中文版：语义化版本 2.0.0 优势 标识当前应用版本信息 管理代码仓库 管理外部依赖 版本格式版本号命名如下: 英文版MAJOR.MINOR.PATCH 中文版主版本号.次版本号.修订号 版本号递增规则： 主版本号(MAJOR version)：出现不兼容的API变化 次版本号(MINOR version)：新增向后兼容的功能 修订号(补丁版本号，PATCH version)：修复向后兼容的bug 规范 使用语义版本控制的软件必须(MUST)声明公共API。API可以在代码本身中声明，或者严格存在于文档中。不管怎样，它都应该是精确和全面的 正常版本号必须(MUST)采用X.Y.Z格式，其中X、Y和Z是非负整数，并且必须不(MUST NOT)包含前导零。X是主版本，Y是次版本，Z是补丁版本。每个元素必须(MUST)以数字形式增加。例如：1.9.0 -&gt; 1.10.0 -&gt; 1.11.0 一旦发布了版本化的包，就不能再(MUST NOT)修改该版本的内容。任何修改都必须作为新版本重新发布 主版本号为0(0.y.z)表示初始开发阶段，可以执行任意的修改。这个阶段的公共API不应该(SHOULD NOT)被视为稳定版。 从版本1.0.0定义的公共API开始，之后版本号的递增方式依赖于此公共API的更改方式 只要有向后兼容的bug被修复，就必须(MUST)递增补丁版本号Z(x.y.Z | x&gt;0)。错误修复被定义为修复错误行为的内部更改 只要有向后兼容的功能被引入公共API，就必须(MUST)递增次版本号Y(x.Y.z | x&gt;0)。只要有任何公共API被标记为舍弃(deprecated)，就必须(MUST)递增次版本号。如果在私有代码中引入了大量新功能或改进，其中可以(MAY)包括补丁级别的改变，那么可以(MAY)递增次版本号。当次版本号递增时必须(MUST)设置补丁版本号为0 只要有不向后兼容的改变被引入公共API，就必须(MUST)递增主版本号X(X.y.z | x&gt;0)，其中可以(MAY)包括次版本和补丁级别的修改。当主版本号递增时，必须(MUST)设置次版本号和补丁版本号为0 预发布版本可以(MAY)通过在补丁版本之后附加连字符(-)和一系列点(.)分隔的标识符来表示。标识符必须(MUST)只包含ASCII字母数字和连字符[0-9a-za-z-]。标识符必须不(MUST NOT)为空。数字标识符必须不(MUST NOT)包含前导0。预发布版本的优先级低于相关的正常版本。预发布版本表示该版本尚不稳定，可能不满足与其关联的正常版本预期的兼容性要求。比如，1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92 构建元数据可以(MAY)通过在补丁或预发布版本之后立即附加一个加号和一系列点分隔的标识符来表示。标识符必须(MUST)只包含ASCII字母数字和连字符[0-9a-za-z-]。标识符必须不(MUST NOT)为空。在确定版本优先级时应该(SHOULD)忽略构建元数据。因此如果有两个版本仅在构建元数据上有区别，那么这两个版本优先级相同。比如，1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85 优先级是指在排序时版本之间如何进行比较。必须(MUST)按顺序将版本分离为主、次、补丁和预发布标识符来计算优先级（构建元数据不包含在优先级中）。当从左到右比较每个标识符时，优先级由第一个差异决定，如下所示：主、次和补丁版本总是用数字进行比较。比如，1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主、次和补丁的大小相同时，预编译版本的优先级低于正常版本。比如，1.0.0-alpha &lt; 1.0.0。具有相同主版本、次版本和补丁版本的两个预发布版本的优先级必须(MUST)通过从左到右比较每个点分隔的标识符来确定，直到发现以下差异：仅由数字组成的标识符用数字进行比较，带字母或连字符的标识符按ASCII排序顺序在词法上进行比较。数字标识符总是优先级低于非数字标识符。如果前面的所有标识符都相同，则拥有更长字段集的预发布版本的优先级高于较小字段集的预发布版本。比如，1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0 FAQ问：应该如何处理0.y.z初始开发阶段的修订？ 最简单的方式是初始开发版本从0.1.0开始，然后在每一个后续的阶段递增次版本号 问：什么时候发布1.0.0版本？ 下列情况可用于发布1.0.0版本 软件已经在生产中使用 已经有用户依赖于稳定的API 开发过程中非常担心向后兼容性 问：是否语义化规范不鼓励快速开发和快速迭代？ 主版本为0的初始开发阶段就是用于快速开发的。如果每天都在改变API，那么软件应该仍旧停留在0.y.z阶段或者在一个单独的开发分支上处理下一个主版本 问：是否对公共API小小的不兼容修改都要递增主版本，那这样的话很快就能达到42.0.0？ 这就要考验你的开发经验和开发远见。不应将不兼容的更改轻易地引入具有大量依赖代码的软件中，升级所需的成本可能很高。必须推出主版本以发布不兼容的更改意味着你已经考虑了更改的影响，并评估所涉及的成本&#x2F;效益比 问：为全部公共API生成文档需要做太多的工作了！ 为了其他人的使用而去文档化软件，这是作为职业开发者的责任。管理软件复杂性是保持项目高效的一个非常重要的部分，如果没有人知道如何使用您的软件，或者可以安全地调用哪些方法，这很难做到。从长远来看，语义版本控制以及对定义良好的公共API的坚持可以使每个人都能顺利运行 问：如果不小心在次版本发布了一个不兼容改变该怎么办？ 一旦意识到已经破坏了语义化版本规范，修复问题并发布一个新的次要版本，以纠正问题并恢复向后兼容性。即使在这种情况下，修改已发行的版本也是不可接受的。如果合适，记录违规版本并告知用户该问题，以便他们了解有问题的版本。 问：如果我更新了依赖，但是没有改变公共API，应该怎么做？ 这种方式是兼容的，因为它没有影响公共API。明确依赖于你的包的软件应该有它们自己的依赖规范，作者也会注意到任何冲突。决定是否这个修改是补丁级别还是次版本级别依赖于你更新你的依赖是为了修复bug还是添加新功能。我通常期待额外的代码是为了后一种，这种情况下明显是一个次版本级别递增 问：如果我不小心修改了公共API，但是不兼容于版本号的改变（比如在补丁版本中错误的引入了主版本级别的不兼容修改）？ 运用你最好的判断。如果有大量的用户会因为这个公共API的返回而受到影响，那么最好的策略是执行一次主版本发布，即使这次修复严格上被视为是补丁发布。记住，语义版本化就是通过版本号的变化来传达意义。如果这些更改对您的用户很重要，请使用版本号通知他们 问：应该如何处理待舍弃的功能? 舍弃已存在的功能是软件开发的常规动作，也是为了进一步发展所必须的。当你舍弃部分公共API，应该做两件事情：（1）更新文档让用户知道这次改变，（2）发布一个新的次版本，仍旧包含这个舍弃功能。在新的主版本发布中完全移除这些功能之前，应该至少发布一个包含这些舍弃功能的次版本，其目的是让用户能够平滑的迁移到新的API 问：语义规范对版本字符串有大小限制吗？ 没有限制，但是255个字符的版本号也太长了一点。此外，特定系统可能会对字符串的大小有限制 辅助工具semantic-release&#x2F;semantic-release conventional-changelog&#x2F;standard-version 参考链接 语义版本规范"},{"title":"2022年2月阅读清单","path":"/2022/02/11/2022年2月阅读清单/","content":"2022年2月阅读清单 毕业五年还在卷：2021 年终总结 - 掘金 [NGX]使用ViewContainerRef来操作Angular中的DOM - 掘金 你会用ES6，那倒是用啊！ - 掘金 Angular使用技巧：NgIf 非常规用法 - 掘金 【卷王的2021】前端：从995到965且涨薪40+%？ - 掘金 【手把手】学会VS Code&amp;#34;任务&amp;#34;神技，成为项目组最靓的崽！ - 掘金 一份前端够用的 Linux 命令 - 掘金 一文搞懂peerDependencies 5 个 JavaScript 写法小技巧分享 - 掘金 如何正确地评价 Angular? 国内研发管理工具PingCode和其他工具对比有什么特别之处？ - 知乎 Angular 真的需要状态管理么？ - 徐海峰的文章 - 知乎 # Angular 依赖注入 - 全面解析 前端生成二维码和条形码完整方案（附问题处理方案） - 掘金 仿微博@人员功能实现 - 掘金 10分钟，打造一个专属于你的cli - 掘金 使用 typescript 快速开发一个 cli - Jason Long - 博客园 如何向开源社区提问题 · Issue #545 · seajs&#x2F;seajs · GitHub How-To-Ask-Questions-The-Smart-Way&#x2F;README-zh_CN.md at main · ryanhanwu&#x2F;How-To-Ask-Questions-The-Smart-Way · GitHub # 如何向开源项目提交无法解答的问题 # 纯管道如何提高 Angular 应用程序的性能 # 使用 Angular 在您自己的库中创建自定义管道 TS入门之细说枚举enum - 掘金 GitHub - ruanyf&#x2F;document-style-guide: 中文技术文档的写作规范 Really Friendly Command Line Intro - Hello Web Books TLCL 杂谈 浅谈跨端技术 - 掘金 低代码的王国里，没有国王 - 掘金 通过fetch看跨域：是谁阻止了跨域请求？ - 掘金 # 这个17k star的拖拽库有点料 冻结JS对象方法技术详解 - 掘金 rxjs-shareReplay 你还在手写TS类型代码吗 - 掘金 关于自建组件库的思考 - 掘金 程序员必备技能之—Typescript - 掘金 GitHub - Anduin2017&#x2F;HowToCook: 程序员在家做饭方法指南。 别害羞，开源社区真的很需要你，教你如何参与开源社区！ - 掘金 影响了一代代前端人的 20 个里程碑式的顶级开源项目！2021 成为里程碑的项目又是哪个呢？ - 掘金 GitHub 上能挖矿的神仙技巧 - 如何发现优秀开源项目 · Issue #45 · biaochenxuying&#x2F;blog · GitHub 聊一聊技术人学习的方向 - 掘金 《重构·改善既有代码的设计》笔记整理 - 掘金 离谱！一个0行代码的库居然拿了50k star！ - 掘金 macOS-Security-and-Privacy-Guide&#x2F;README-cn.md at master · drduh&#x2F;macOS-Security-and-Privacy-Guide · GitHub 目前不适合我 transfom技术细节 - 掘金 # rrweb 带你还原问题现场 vscode 扩展插件开发——入门篇 - 掘金 妈妈再也不用担心我重装VSCode了 - 掘金 Tmux使用手册 | louis blog 你不知道的 WebSocket"},{"title":"安装并使用Verdaccio部署私有NPM仓库","path":"/2022/02/07/安装并使用Verdaccio部署私有NPM仓库/","content":"前言 需要搭建私有的NPM仓库，社区提供了两种方法，我们思考了一下，采用了Verdaccio「主要还是轻量吧」 使用nodejs 安装1yum install -y gcc-c++ make 1curl -sL https://rpm.nodesource.com/setup_14.x | sudo -E bash - 这里我们一开始安装了10.x版本的node，但是发现Cerdaccio不支持10.x的版本，但是yum已经有了缓存需要清除缓存，不然会404 1yum install -y nodejs 1npm install -g verdaccio 1nerdaccio --listen 0.0.0.0:4873 使用docker 安装 拉取最新的docker镜像 1docker pull verdaccio/verdaccio 在服务器/data/verdaccio/conf下创建一个config.yaml放置配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101## This is the config file used for the docker images.# It allows all users to do anything, so don&#x27;t use it on production systems.## Do not configure host and port under `listen` in this file# as it will be ignored when using docker.# see https://verdaccio.org/docs/en/docker#docker-and-custom-port-configuration## Look here for more config file examples:# https://github.com/verdaccio/verdaccio/tree/master/conf## path to a directory with all packagesstorage: /verdaccio/storage/data# path to a directory with plugins to includeplugins: /verdaccio/pluginsweb: # WebUI is enabled as default, if you want disable it, just uncomment this line #enable: false title: Verdaccio # comment out to disable gravatar support # gravatar: false # by default packages are ordercer ascendant (asc|desc) # sort_packages: asc # darkMode: true # logo: http://somedomain/somelogo.png # favicon: http://somedomain/favicon.ico | /path/favicon.ico # rateLimit: # windowMs: 1000 # max: 10000# translate your registry, api i18n not available yet# i18n:# list of the available translations https://github.com/verdaccio/ui/tree/master/i18n/translations# web: en-USmax_body_size: 20mbauth: htpasswd: file: /verdaccio/storage/htpasswd # Maximum amount of users allowed to register, defaults to &quot;+infinity&quot;. # You can set this to -1 to disable registration. # max_users: 1000# a list of other known repositories we can talk touplinks: npmjs: url: https://registry.npmjs.org/packages: &#x27;@*/*&#x27;: # scoped packages access: $all publish: $authenticated unpublish: $authenticated proxy: npmjs &#x27;**&#x27;: # allow all users (including non-authenticated users) to read and # publish all packages # # you can specify usernames/groupnames (depending on your auth plugin) # and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot; access: $all # allow all known users to publish/publish packages # (anyone can register by default, remember?) publish: $authenticated unpublish: $authenticated # if package is not available locally, proxy requests to &#x27;npmjs&#x27; registry proxy: npmjs# You can specify HTTP/1.1 server keep alive timeout in seconds for incoming connections.# A value of 0 makes the http server behave similarly to Node.js versions prior to 8.0.0, which did not have a keep-alive timeout.# WORKAROUND: Through given configuration you can workaround following issue https://github.com/verdaccio/verdaccio/issues/301. Set to 0 in case 60 is not enough.server: keepAliveTimeout: 60middlewares: audit: enabled: true# log settingslogs: &#123; type: stdout, format: pretty, level: http &#125;#experiments:# # support for npm token command# token: false# # enable tarball URL redirect for hosting tarball with a different server, the tarball_url_redirect can be a template string# tarball_url_redirect: &#x27;https://mycdn.com/verdaccio/$&#123;packageName&#125;/$&#123;filename&#125;&#x27;# # the tarball_url_redirect can be a function, takes packageName and filename and returns the url, when working with a js configuration file# tarball_url_redirect(packageName, filename) &#123;# const signedUrl = // generate a signed url# return signedUrl;# &#125;# This affect the web and api (not developed yet)#i18n:#web: en-US 3.运行命令 123456V_PATH=/data/verdaccio; docker run -it -d --rm --name verdaccio \\ -p 4873:4873 \\ -v $V_PATH/conf:/verdaccio/conf \\ -v $V_PATH/storage:/verdaccio/storage \\ -v $V_PATH/plugins:/verdaccio/plugins \\ verdaccio/verdaccio 4.授予文件权限 1sudo chown -R 10001:65533 /data/verdaccio"},{"title":"2022年2月阅读清单","path":"/2022/02/07/2022年2月阅读清单-1/","content":"2022年2月阅读清单 毕业五年还在卷：2021 年终总结 - 掘金 [NGX]使用ViewContainerRef来操作Angular中的DOM - 掘金 你会用ES6，那倒是用啊！ - 掘金 Angular使用技巧：NgIf 非常规用法 - 掘金 【卷王的2021】前端：从995到965且涨薪40+%？ - 掘金 【手把手】学会VS Code&amp;#34;任务&amp;#34;神技，成为项目组最靓的崽！ - 掘金 一份前端够用的 Linux 命令 - 掘金 一文搞懂peerDependencies 5 个 JavaScript 写法小技巧分享 - 掘金 如何正确地评价 Angular? 国内研发管理工具PingCode和其他工具对比有什么特别之处？ - 知乎 Angular 真的需要状态管理么？ - 徐海峰的文章 - 知乎 # Angular 依赖注入 - 全面解析 前端生成二维码和条形码完整方案（附问题处理方案） - 掘金 仿微博@人员功能实现 - 掘金 10分钟，打造一个专属于你的cli - 掘金 使用 typescript 快速开发一个 cli - Jason Long - 博客园 杂谈 浅谈跨端技术 - 掘金 低代码的王国里，没有国王 - 掘金 通过fetch看跨域：是谁阻止了跨域请求？ - 掘金 # 这个17k star的拖拽库有点料 冻结JS对象方法技术详解 - 掘金 目前不适合我但我还是中招了 transfom技术细节 - 掘金 # rrweb 带你还原问题现场"},{"title":"Docker 安装 gitlab-runner 实现 CI/CD","path":"/2022/01/29/Docker-安装-gitlab-runner-实现-CI-CD/","content":"Docker install gitlab-runner 拉取gitlab-runner镜像 1sudo docker pull gitlab/gitlab-runner:latest 添加gitlab-runner container 1234sudo docker run -d --name gitlab-runner --restart always \\ -v /srv/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest 注册runner 1sudo docker exec -it gitlab-runner gitlab-ci-multi-runner register 12345说明： 1、gitlab ci的地址以及token，从你要配置该runner到哪个项目，就去gitlab下该项目首页右侧设置—》CI/CD Pipelines—》Specific Runners下可以找到。 2、gitlab-ci tags这个很重要，在项目构建流程yaml文件里面指定tag，就是匹配使用哪个tag的runner，这里我定义了fone-ui，回头再配置文件里面就指定这个tag。 3、executor：执行者可以有很多种，这里我们使用docker，方便构建执行。 4、Docker image：构建Docker image时填写的image名称，根据项目代码语言不同，指定不同的镜像。我这里项目是node语言的，所以我使用官方node:16.13.2镜像。 设置运行脚本 1234567891011121314151617181920212223cache: paths: - node_modules/image: node:16.13.2build: stage: build tags: - fone-ui script: - echo &quot;show npm registry &amp; proxy...&quot; - npm get registry - npm config get proxy - echo &quot;Start building App...&quot; - npm ci - npm run build - echo &quot;Build successfully!&quot; only: refs: - merge_requests variables: - $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == &quot;develop&quot; || $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == &quot;master&quot; 如何删除呢？ gitlab设置页面，删除runner docker容器中的gitlab-runner中删除 第一个在注册步骤中的页面可以一键删除 第二个使用命令 进入runner容器内 1$ docker exec -it gitlab-runner bash 查看runner列表 1$ gitlab-runner list 使用指定的id和url删除验证 1gitlab-runner verify --delete -t [你的token，即第一步中的对应的token] -u http://git.xxxx.com/ 退出容器 1exit 环境参数 CentOs 7.9 docker 20.20.10 NodeJs 16.13.2 GitLab 社区版 13.12.0"},{"title":"2022年1月阅读清单","path":"/2022/01/27/2022年1月阅读清单/","content":"2022年1月阅读清单 淘系前端团队-karma 测试框架的前世今生 随着工作的进展，测试已经变得越来越迫切起来，之所以关注karma框架，可能还是因为angular默认支持的就是这个吧 淘系前端团队-VSCode原理解析 - 断点调试 淘系前端团队-揭秘浏览器远程调试技术 淘系前端团队-我的前端成长之路： 在阿里七年，我的成长和迷茫 淘系前端团队-VS Code 源码分析 - 多语言实现 jsDelivr 事故后的公共CDN故障自动切换思考 - 友人C [Angular]在Angular中和DOM打交道的正确姿势 - 掘金"},{"title":"「Mac」SourceTree 手动拉取代码每次都需要自己手动刷新列表","path":"/2022/01/05/「Mac」SourceTree-手动拉取代码每次都需要自己手动刷新列表/","content":"起因原本我的GIT是通过Xcode安装的,至于为什么不用brew安装,我已经忘记为什么了. 今天突然心血来潮,把Xcode给卸载了.然后 brew install git,很好,git也支持中文了! 既然版本最新了,那就顺手在SourceTree的Git使用自己下载的吧, 事发没想到这样一来就出问题了 image.png 无法自动更新代码了. 解决重新使用内置版本解决问题!"},{"title":"ng-deep的使用限制","path":"/2021/12/08/ng-deep的使用限制/","content":"对于ng-deep,感觉官方的态度是比较暧昧的,但是这个使用场景其实还是比较多的.特别是在组件内部使用其他组件,并且需要仅在当前组件下自定义样式的情况,ng-deep就显得比较迫切了. 但是以前以为在组件样式文件夹内直接使用::ng-deep是没有问题的,也会挂在当然组件下面,但是实际并不是如此 image.png image.png 如果直接在最外层使用::ng-deep是会直接加载至全局样式的,用户知道打开过此组件页面,就算后期关闭也会有此遗产存留. 本来是期望使用第二种使用方案,即外层包含一个保护类.这样即使加载了,也会因为angular的组件样式隔离而无法影响其他页面. 但是白天在交流的时候,有人提到了::host这个关键字特意去看了官方文档,其实官方已经想到了这种情况 已弃用 &#x2F;deep&#x2F;、&gt;&gt;&gt; 和 ::ng-deep 所以结论在使用::ng-deep的地方应该加上:host伪类选择器"},{"title":"Angular ChangeDetection:OnPush的视图更新策略","path":"/2021/09/23/Angular-ChangeDetection-OnPush的视图更新策略/","content":"默认更新策略 defaultAngular默认在三种情况下数据更新 事件驱动 事件: 页面 click、submit、mouse XHR: http 请求 Timer: setTimeout()、 setInterval() 都为异步且都是不同类型的webapi angular 通过zone.js, 而zone.js 通过猴子补丁的方式强制重写了浏览器关于异步事件的捕获处理. 推送策略 OnPush如果组件设置了 1234@Component(&#123; ..., changeDetection: ChangeDetectionStrategy.OnPush&#125;) 则需要手动触发变更检测 组件的@Input属性的引用发生变化. 组件内的 DOM 事件,包括它子组件的 DOM 组件内的 Observable 订阅事件,同时设置Asynv pipe, 即默认的订阅事件其实是不会被angular捕获的 组件内手动使用 ChangeDetectorRef.detectChanges()、ChangeDetectorRef.markForCheck()、ApplicationRef.tick() ChangeDetectorRef-官方指南 变更触发顺序在设置了@Input字段之后, 组件内更新的顺序根据模板中的变量前后顺序有关即 1&lt;app-demo [input1]=&quot;a&quot; [input2]=&quot;b&quot;&gt;&lt;/app-demo&gt; 先修改input1,然后再修改input2,特别在设置了setter方法之后,表现特别明显 参考资料"},{"title":"2021年9月阅读文稿.md","path":"/2021/09/08/2021年9月阅读文稿-md/","content":"#2021年9月阅读文稿.md 杂谈 跨浏览器窗口通讯,7种方式 css 实现单行居中,多行省略 如何做好 CodeReview Webpack 5.0新特性 模块联邦 如何比较Object 因为使用peerDependencies 而引发的 bug undefined 与 null 的区别 Typescript 4 用 Reduce 实现 Promise 串行执行 Cache API 技术 精通 console.log 手写JSON.parse 巧用 CSS filter,让你的网站更加炫酷 Angular 变更检测以及单项数据流 *Angular 2 Change Detection - 2 如何命名 angular 变更检测详解"},{"title":"永劫无间·胡桃·三排攻略","path":"/2021/08/16/永劫无间·胡桃·三排攻略/","content":"永劫无间·胡桃·三排攻略 S0赛季陨星守门员,指挥,专打固定三排(胡桃、和尚、宁红叶[特穆尔]) 打法!!!永远找机会多少打, 2v1, 3v1 排除遭遇战,先远程消耗,随后队友和尚和宁红叶[特穆尔]先手进场,胡桃在中等距离补充伤害和控制,[k头] 天赋 &amp; 技能天赋天赋是一个需要考虑队友的作战习惯,团队中胡桃的定位来折中考虑 精力·怒气·幸运·拉人 通用 (上左右精力,下钩索距离)这套就是纯打架拼操作的天赋 精力 + 幸运 (上左右精力,下幸运)这套放弃了追击能力,而补充了幸运,可以让你落地更快的拿到优质装备,也可以在第一条命浪费之后,打野发育效率增加,这套比较常用,精力的追加可以让你挨打的时候更好操作,幸运的增加也会让你落地更快的补充装备 怒气 + 精力 + 幸运 (左每秒努气, 上攻击怒气, 右精力上限, 下幸运)折中怒气和精力,因为毕竟分段越往上打,其实打得还是很谨慎,要么不打,一开打必须马上秒人. 怒气 + 精力 + 幸运 + 拉人 (左每秒怒气, 上攻击怒气, 右拉人速度, 下幸运)同理,去掉了精力,追加辅助能力,一般不需要胡桃拼操作的时候,而且队友落地很容易就暴毙的时候. 技能F1 + V3 武器 &amp; 魂玉武器选择长剑 + 连弩 长剑在近距离补充伤害,尽量在敌人视野盲区努力,也可看准备队友被振刀时,释放剑气打断对方振刀追击.连弩配合和尚或宁红叶[特穆尔]的控制完成点杀. 魂玉选择胡桃不需要绝大多数攻击魂玉,无论是是否为装备的金色魂玉,此类完全可以让给输出队友.优先保证村活.在保证自己存活的情况下,辅助队友.因为一般都会先杀辅助. 属性魂玉: 近抗 &gt; 体力(金色优先) 辅助魂玉: 虚影步,地堂霸脚,凌波,壁虎游墙(房区爬墙逃避伤害神器),妙手 小细节 不要落单 精准报点,遇人永远等队友|集合 不恋战,不贪伤害,要打就集火秒人,不然就不打"},{"title":"storybook doc-block argType 详解","path":"/2021/08/06/storybook-doc-block-argType-详解/","content":"storybook doc-block argType 详解参数详情 overview 字段 说明 name 同字段名,可省略 type.require boolean description 描述 defaultValue 数据:默认值 table.type.summary 类型的简单描述 table.type.detail 类型的长描述 table.defaultValue.summary 显示:默认值 table.defaultValue.detail 显示:默认值详细说明 control.type 控件类型(需要有[数据]默认值) e.g. null , radio , text , number options 控件类型为 radio 时的值数组 举个 🌰 e.g.1234567891011121314151617181920Primary.argTypes = &#123; fNotFoundImage: &#123; name: &#x27;fNotFoundImage&#x27;, type: &#123; required: false, &#125;, table: &#123; defaultValue: &#123; summary: &#x27;null&#x27;, &#125;, type: &#123; summary: &#x27;string | TemplateRef&lt;void&gt;&#x27; &#125; &#125;, description: &#x27;图片url&#x27;, defaultValue: null, options: [null, &#x27;https://www.sass.hk/images/sass.png&#x27;], control: &#123; type: &#x27;radio&#x27; &#125;, // 可简写成 =&gt; control: &#x27;radio&#x27; &#125;&#125;; 控件参数详解 data type &amp; 数据类型 control type &amp; 控件类型 description &amp; 描述 options &amp; 选项 array array serialize array into a comma-separated string inside a textbox separator boolean boolean checkbox input - number number a numberic text box input min, max, step - range a range slider input min, max, step object object json editor text input - enum radio radio buttons input Ï options - inline-radio inline radio buttons input options - check multi-select checkbox input options - inline-check multi-select inline checkbox input options - select select dropdown input options - multi-select multi-select dropdown input options string text simple text input - - color color picker input that assumes strings are color values - - date date picker input - 再举个 🌰 e.g.1234567export default &#123; title: &#x27;Gizmo&#x27;, component: Gizmo, argTypes: &#123; width: &#123; type: &#x27;range&#x27;, min: 400, max: 1200, step: 50 &#125;; &#125;,&#125;;"},{"title":"2021年8月阅读目录","path":"/2021/08/04/2021年8月阅读目录/","content":"2021年8月阅读目录.md杂项 When You “Git” in Trouble - a Version Control Story how we position and what we compare(可视化案例) async await 是把双刃剑 现代JS框架存在的根本原因 typescript 2.0-2.9文档 谈谈 web workers typescript 3.2 新特性 caches api 如何编译前端项目与组件 Scheduling in React 国际化布局-Logical Properties Nodejs V12 使用 css 变量 前端深水区 前端与 BI 用 grid 重新思考布局 我在阿里数据中台大前端 技术 图解 ES 模块 精读《插件化思维》 css 选择器 编写有弹性的组件 持续集成 vs 持续交付 vs 持续部署 Optional chaining – ts已支持 rxjs rxjs-cn RxJS：四种 Subject 的用法和区别 RxJS：所有订阅都需要调用 unsubscribe 取消订阅？ Nuxtjs 寻找框架设计的平衡点 基础知识 V8引擎 Lazy Parsing What’s new in javascript 前端未来展望 源码学习"},{"title":"七月随机阅读文章目录(2021Y)","path":"/2021/07/22/七月随机阅读文章目录-2021Y/","content":"七月随机阅读文章目录(2021Y) 记录一下自己七月份看到的一些前端文章(排名只分遇到之时间顺序) V8 引擎特性带来的 JS 性能变化 try-catch 越来越需要在工作中提高使用频次了。 2.便利依旧优先for-in 3.delete性能优化，不过在 ts 中其实并不怎么使用 正则表达式|MDN 没什么说的,正则确实不会. package-lock.json 需要提交到 git？ 版本控制相关的内容有错或者说不清晰,只能说看看里面文件结构以及字段的介绍吧 命令需要自己检查,作者提供的不准确 vscode 是怎么跑起来的 很大概的介绍,引入了一些依赖注入的思想 以及现代前端需要了解和学习的两大技术栈node、chromium GitHub、GitLab、Git 操作的一些规范 介绍了一下 angular-commit 规范 比较需要留意的是 git reflog、ignore 一篇讲透自研的前端错误监控 涉及的知识点很多 全面的错误捕获 错误定位,sourceMap 后端的错误搜集 加班粗略看了一下.想有收获应该还是需要精读一番 如何从前端小白进化为带队大佬 其实就涉及到一些软技能了 精读《API》设计原则 不想写好 API 的开发不是一个好开发 但是具体方法还是得从模仿优秀的开源框架开始 你真的了解package.json 讲解很详细,并且是中文友好 确实英文能力不好人.对于看文档有一种隐式的推脱 简化你的JavaScript 使用some &amp; find 两者都是查找即停,而不会全量遍历 如何快速学习东西如何永远记住任何事情在Angular中取消订阅的6种办法 ngOnDestroy() async Pipe Rxjs take* operator(需要注意确认在component生命周期内触发完成) Rxjs first 装饰器自动调用销毁(非订阅会很麻烦) 使用ts&#x2F;eslint Angular重构示例业务系统的稳定性建设 搭建一套错误收集系统需要思考的点 2021年前端趋势预测 前端&amp;AI 基建即node&amp;webpack重点关注 前端机器学习的利器,更快的Pipcook 现在JavaScript概述null &gt;&#x3D; 0 &#x3D;&#x3D;&#x3D; true 介绍了一下比较的逻辑判断 最复杂的反而是&#x3D;&#x3D;,所以项目优先使用显式的真等和显式类型转换 2017年前端性能优化备忘录css-in-js 杀鸡用牛刀ja 中的内存管理 虽然是个老生常谈的问题,不过还是会点开看看 DOM 引用 闭包 Javascript 事件循环与异步Ant Design 3.0 背后的故事 看这个只是因为最近在写自己的组件库"},{"title":"如何优化angular-cli构建速度","path":"/2021/07/15/如何优化angular-cli构建速度/","content":"优化 angular cli build 速度增加内存一般会增加一个nodejs命令来提高打包时分配的内存,比如说 1node --max_old_space_size=8196 ./node_modules/@angular/cli/bin/ng build --prod 但是实际测试发现,分配大额内存对于构建速度是负优化 修改打包配置项** 注意,本人用于gitlab-CI 的速度优化,而非实际生产环境配置 ** angular.json 123456789101112&quot;optimization&quot;: false, &quot;outputHashing&quot;: &quot;none&quot;, &quot;sourceMap&quot;: false, &quot;extractCss&quot;: true, &quot;namedChunks&quot;: false, &quot;showCircularDependencies&quot;: false, &quot;aot&quot;: true, &quot;extractLicenses&quot;: false, &quot;statsJson&quot;: false, &quot;progress&quot;: false, &quot;vendorChunk&quot;: true, &quot;buildOptimizer&quot;: false, 当然可以复制追加一个自定义的命名配置,直接通过npm脚本运行 1ng build --configuration=myenv 这里提供一个思路,但是具体配置项,可以根据需要微调,毕竟,速度前提是正确! ps: 附上本机实际时间对比 效果斐然 命令 时间 node --max_old_space_size=8196 ./node_modules/@angular/cli/bin/ng build --prod 3.4447分钟 ng build --prod 2.8793分钟 改打包配置文件 1.1223分钟"},{"title":"前端开发调试之奇技淫巧","path":"/2021/07/01/前端开发调试之奇技淫巧/","content":"#记录开发过程中的一些调试小技巧 插件 vscode-chrome调试插件 小技巧列表 chrome-js代码黑盒化"},{"title":"一步一步教你如何在 angular 项目中使用 eslint 以及 prettier 配合 husky 实现自动控制代码结构","path":"/2021/06/29/一步一步教你如何在-angular-项目中使用-eslint-以及-prettier-配合-husky-实现自动控制代码结构/","content":"一步一步教你如何在 angular 项目中使用 eslint 以及 prettier 配合 husky 实现自动控制代码结构工具安装Prettier首先，安装prettier1npm install --save-dev --save-exact prettier 不同版本的 prettier 有不同的格式实现，所以需要精准安装，并且，您使用的任何插件或可共享配置都必须在任何一种情况下本地安装!!! 然后创建配置文件 .prettierrc.json 这是我的配置12345678910111213&#123; &quot;tabWidth&quot;: 2, &quot;semi&quot;: true, &quot;singleQuote&quot;: true, &quot;jsxSingleQuote&quot;: true, &quot;bracketSpacing&quot;: true, &quot;jsxBracketSameLine&quot;: true, &quot;printWidth&quot;: 120, &quot;endOfLine&quot;: &quot;lf&quot;, &quot;proseWrap&quot;: &quot;preserve&quot;, &quot;trailingComma&quot;: &quot;es5&quot;, &quot;useTabs&quot;: false&#125; 别忘记了忽略文件 .perttierignore 下面是我的配置1234567# Ignore artifacts:buildcoveragepublish#尚未准备好处理html*.html 当然 vscode 有配套的插件 Prettier - Code formatter，安装之后会读取你工作区的配置文件Eslint第一步还是安装1npm install eslint --save-dev 然后初始化1npx eslint --init –init假设您已经有一个package.json文件 配置规则初始化之后，你会在你的 .eslintrc.&#123;js,yml,json&#125; 文件中看到以下内容 123456&#123; &quot;rules&quot;: &#123; &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;], &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;] &#125;&#125; 名称 semi 和 quotes 是 ESLint 中规则的名称。第一个值是规则的错误级别，可以是以下值之一： off 或 0 - 关闭规则warn 或 1 - 打开规则作为警告（不影响退出代码）error 或 2- 将规则作为错误打开（退出代码将为 1） 具体规则描述👉规则 您的.eslintrc.{js,yml,json}配置文件还将包含以下行： 123&#123; &quot;extends&quot;: &quot;eslint:recommended&quot;&#125; 这说明你的 Eslint 将会继承默认推荐规则, 即在规则页面前有 ✅ 的规则 配合使用配合配合 Eslint 和 Prettier 你需要安装一个 Eslint 的 prettier 配置 安装1npm install --save-dev eslint-config-prettier 配置然后添加 prettier 到 .eslintrc.* 文件的 extends 数组中 123456&#123; &quot; extends &quot; : [ &quot; some-other-config-you-use &quot; , &quot; prettier &quot; ]&#125; Git 预提交钩子1npx mrm lint-staged 这将安装 husky 和 lint-staged，然后向项目添加一个配置，该配置package.json将在预提交挂钩中自动格式化支持的文件。 此时你的 package.json 1234&quot;lint-staged&quot;: &#123; &quot;*.ts&quot;: &quot;eslint --cache --fix&quot;, // 默认为js，自行按需修改，下同 &quot;*.&#123;js,ts,css,scss,md&#125;&quot;: &quot;prettier --write&quot; &#125; 注意：如果您使用 ESLint，请确保 lint-staged Eslint 在 Prettier 之前而不是之后运行它。 如果需要husky在你提交代码时检查您的提交信息则请看另外文章 写在最后本文只是应用的一次 step to step ，若想深入了解操作原理还需仔细阅读官方文档 Eslint Prettier Prettier 与 Linter配合 Lint-staged"},{"title":"Git  flow 介绍以及使用","path":"/2021/05/21/Git-flow-介绍以及使用/","content":"[scode type&#x3D;”blue”]协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。”工作流程”在英语里，叫做”workflow”或者”flow”，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。[&#x2F;scode] 功能驱动需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。 Git flow特点 git-flow-ow.png 项目存在两个长期分支。 主分支 master 开发分支 develop 前者用于存放对外发布的版本；后者用于日常开发，存放最新的开发版。 其次，项目存在三种短期分支。 功能分支 feature branch 补丁分支 hot fix branch 预发分支 release branch 一旦开发完成，它们就会被合并进develop 或 master, 然后被删除 安装 Git flowwindows版本的git 已经自带其他版本 [其他版本安装地址][https://github.com/petervanderdoes/gitflow-avh/wiki/Installation] git-flow 并不是要替代 Git，它仅仅是非常聪明有效地把标准的 Git 命令用脚本组合了起来。严格来讲，你并不需要安装什么特别的东西就可以使用 git-flow工作流程。你只需要了解，哪些工作流程是由哪些单独的任务所组成的，并且附带上正确的参数，以及在一个正确的顺序下简单执行那些对应的 Git命令就可以了。当然，如果你使用 git-flow 脚本就会更加方便了，你就不需要把这些命令和顺序都记在脑子里。 使用-初始化1git flow init [-d] 7E0251C3-0A9B-4901-96E1-9A44AAC368B8.png 看起来是不是有点炫，但实际上它只是在你的分支上配置了一些命名规则。建议默认 [-d] 分支模式 Master -只能用来包括产品代码。你不能直接工作在这个 master 分支上，而是在其他指定的，独立的特性分支中。不直接提交改动到 master 分支上也是很多工作流程的一个共同的规则。 develop - 是你进行任何新的开发的基础分支。当你开始一个新的功能分支时，它将是_开发_的基础。另外，该分支也汇集所有已经完成的功能，并等待被整合到 master 分支中。 4A6C9C4D-AB21-46E3-8140-2CCC13D77E94.png 这两个分支被称作为长期分支。它们会存活在项目的整个生命周期中。而其他的分支，例如针对功能的分支，针对发行的分支，仅仅只是临时存在的。它们是根据需要来创建的，当它们完成了自己的任务之后就会被删除掉。 功能开发开始新功能让我们开始一个新功能 “rss-feed” E412C074-A4AC-4B5C-8BE5-26F1FB32030D.png Git flow 会打印出刚刚完成的操作的概述，如果你需要帮助随时可以 1git flow feature help 正如上面这个新功能一样，git-flow 会创建一个名为 “feature&#x2F;rss-feed” 的分支（这个 “feature&#x2F;” 前缀 是一个可配置的选项设置）。你已经知道了，在你做新功能开发时使用一个独立的分支是版本控制中最重要的规则之一。 git-flow 也会直接签出这个新的分支(即已经自动切换到此新分支)，这样你就可以直接进行工作了。 3F8484EE-FB3C-4BE2-BE3F-59991007C87D.png 完成一个功能经过一段时间艰苦地工作和一系列的聪明提交，我们的新功能终于完成了： 1git flow feature finish rest-feed F3D5E62B-A39C-47B6-850E-F043DEEE51A3.png 最重要的是，这个 “feature finish” 命令会把我们的工作整合到主 “develop” 分支中去。在这里它需要等待： 一个在更广泛的 “开发” 背景下的全面测试。 稍后和所有积攒在 “develop” 分支中的其它功能一起进行发布。 之后，git-flow 也会进行清理操作。它会删除这个当下已经完成的功能分支，并且换到 “develop” 分支。 管理 releaseRelease 管理是版本控制处理中的另外一个非常重要的话题。让我们来看看如何利用 git-flow 创建和发布 release。 创建 release当你认为现在在 “develop” 分支的代码已经是一个成熟的 release 版本时，这意味着： 第一，它包括所有新的功能和必要的修复； 第二，它已经被彻底的测试过了。 如果上述两点都满足，那就是时候开始生成一个新的 release 了： 1Git flow release start 1.1.5 078BAD7C-ED05-4D8E-8104-4A9EF182061D.png 请注意，release 分支是使用版本号命名的。这是一个明智的选择，这个命名方案还有一个很好的附带功能，那就是当我们完成了release 后，git-flow 会适当地_自动_去标记那些 release 提交。有了一个 release 分支，再完成针对 release 版本号的最后准备工作（如果项目里的某些文件需要记录版本号），并且进行最后的编辑。 完成 release1git flow release finish 1.1.5 需要填写tag message 5EDFB0A6-75B6-4BA8-870B-12A0BE86AD5D.png EBC3588A-F271-4454-9EDA-1BDE08D3B6C0.png 这个命令会完成如下一系列的操作： 首先，git-flow 会拉取远程仓库，以确保目前是最新的版本。 然后，release 的内容会被合并到 “master” 和 “develop” 两个分支中去，这样不仅产品代码为最新的版本，而且新的功能分支也将基于最新代码。 为便于识别和做历史参考，release 提交会被标记上这个 release 的名字（在我们的例子里是 “1.1.5”）。清理操作，版本分支会被删除，并且回到 “develop”。 从 Git 的角度来看，release 版本现在已经完成。依据你的设置，对 “master” 的提交可能已经触发了你所定义的部署流程，或者你可以通过手动部署，来让你的软件产品进入你的用户手中。 hotfix很多时候，仅仅在几个小时或几天之后，当对 release 版本作做全面测试时，可能就会发现一些小错误。在这种情况下，git-flow 提供一个特定的 “hotfix” 工作流程（因为在这里不管使用 “功能” 分支流程，还是 “release” 分支流程都是不恰当的）。 创建Hotfixes1Git flow hot fix start miss-link 这个命令会创建一个名为 “hotfix&#x2F;missing-link” 的分支。因为这是对产品代码进行修复，所以这个 hotfix 分支是基于 “master” 分支。这也是和 release 分支最明显的区别，release 分支都是基于 “develop” 分支的。因为你不应该在一个还不完全稳定的开发分支上对产品代码进行地修复。就像 release 一样，修复这个错误当然也会直接影响到项目的版本号！ 完成 Hotfixes1git flow hotfix finish miss-link 这个过程非常类似于发布一个 release 版本： 完成的改动会被合并到 “master” 中，同样也会合并到 “develop” 分支中，这样就可以确保这个错误不会再次出现在下一个 release 中。 这个 hotfix 程序将被标记起来以便于参考。 这个 hotfix 分支将被删除，然后切换到 “develop” 分支上去。 还是和产生 release 的流程一样，现在需要编译和部署你的产品（如果这些操作不是自动被触发的话）。 59240A8C-E3F3-4218-B079-5D8FB9C60D3E.png 回顾总结首先，git-flow 并不会为 Git 扩展任何新的功能，它仅仅使用了脚本来捆绑了一系列 Git 命令来完成一些特定的工作流程。 其次，定义一个固定的工作流程会使得团队协作更加简单容易。无论是一个 “版本控制的新手” 还是 “Git 专家”，每一个人都知道如何来正确地完成某个任务。 记住，使用 git-flow 并不是必须的。当积攒了一定的使用经验后，很多团队会不再需要它了。当你能正确地理解工作流程的基本组成部分和目标的之后，你完全可以定义一个属于你自己的工作流程。"},{"title":"macOS安装NVM","path":"/2021/05/10/macOS安装NVM/","content":"不要使用brew工具安装nvm!不要使用brew工具安装nvm!不要使用brew工具安装nvm! 会有一些奇怪的坑,而且官方也不推荐,虽然可以安装并且使用,但是需要才很多坑. #官方安装 https://github.com/nvm-sh/nvm 其实就是下面这一句 1curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh 不过我使用命令安装的时候一直遇到网络情况,然后我仔细阅读了一下说明文档 安装说明 也可以直接运行安装脚本,那直接走你! 新建’install’ 文件 复制 github中的 ‘install.sh’ 里面的内容 重命名 ‘install’ &#x3D;&gt; ‘install.sh’ ~ $ sh install.sh 安装成功! 然后打开 ~ 下的 ‘.zshrc’ (不同终端不同文件) 终端配置文件 保存,然后 1$ source .zshrc 运行一下环境变量 然后接下来就是安装node了 #解决速度问题 在终端中运行下面代码修改nvm的下载源 1export NVM_IOJS_ORG_MIRROR=https://npm.taobao.org/mirrors/iojs 我盲猜这是一次性的,所以在上面的 .zshrc 文件中,我也加入了这一段,希望能够每次运行的时候就修改我nvm的下载源.如果猜错,烦请留言指正,不胜感激! 那么安装nvm关键步骤就完成了! 说在最后: 最近用自己的电脑办公了,之前一直只是课余时间使用macos,这次竟然装环境就花了我大半天时间,还是要学以致用啊!shell命令其实我也是一知半解,慢慢摸索吧."},{"title":"很有意思的东西-关于临时变量在循环体内定义，还是在循环体外定义的问题","path":"/2021/03/31/很有意思的东西-关于临时变量在循环体内定义，还是在循环体外定义的问题/","content":"在一开始学循环的时候，比如说遍历一个list数组,是这么教的: 123for(let i = 0; i &lt; list.length; i++)&#123; //xxx &#125; 但是其实每次循环结束判断条件的时候，都是会去调用list.length,这都是需要消耗性能，如果数组是一个固定长度的那么，可以写成这样： 123for(let i = 0, len = list.length; i &lt; len; i++)&#123; //xxx &#125; 这样，就在初始化的时候，把数组长度给缓存了下来，而不用每次判断的时候去list里面找。 今天在leetcode刷题的时候，因为涉及到循环，而且需要临时变量，我就按照惯例，在循环体中声明并且使用了临时变量，如下方 给定一个Excel表格中的列名称，返回其相应的列序号。A -&gt; 1B -&gt; 2C -&gt; 3…Z -&gt; 26AA -&gt; 27AB -&gt; 28… 123456789101112function titleToNumber(columnTitle: string): number &#123; let len = columnTitle.length - 1; let radix = 1; let sum = 0; while (len &gt;= 0) &#123; let temp = columnTitle.charCodeAt(len) - 64; sum += temp * radix; len--; radix *= 26; &#125; return sum;&#125;; 提交了之后，速度果然 微信图片_20210331165400.png 但是我想，这样每次循环的时候都会创建变量，是不是直接在外部初始化一个临时变量，这样每次直接赋值就好了？ 说干就干 12345678910111213function titleToNumber(columnTitle: string): number &#123; let len = columnTitle.length - 1; let radix = 1; let sum = 0; let curr: number; while (len &gt;= 0) &#123; curr = columnTitle.charCodeAt(len) - 64; sum += curr * radix; len--; radix *= 26; &#125; return sum;&#125;; 很快啊，直接保存提交，霍，直接时间加了20ms增加1&#x2F;4，这可不行啊。 那么联想到list.length的情况，我猜测是因为如果不在循环体内定义的话，需要通过作用域链找寻上层作用域链中的临时变量，这样成本是会比直接在本身作用域中找寻的成本大的。 一个有意思的小细节 再追加一个小技巧: js向下取整 number | 0 &#x3D;&#x3D;&#x3D; Math.floor(number)"},{"title":"数码宝贝：最后的进化","path":"/2020/10/30/数码宝贝：最后的进化/","content":"image.jpeg 今天看了数码宝贝：最终的进化。本来也是赵旭升邀请我，我才会看的。但是随着Butter-Fly的音乐响起。我发现我好像突然回到了十几年前的夏天。这种感觉很奇妙。让我从繁重的工作生活中，一下子解脱了出来。 当然，剧情的发展也特别符合我们现在的心境，大家都长大了。都不想从前一样能那么肆无忌惮，都有了一些枷锁。我也觉得这样的生活不太好。但是却不知道该怎么办。 有的人选择了固守在自己的回忆里，当然，我也有这样的选择，我一直到现在也还偶尔回忆从前，当然，频率没那么频繁。我还记得刚毕业的时候，爸爸妈妈想让我当兵，或者去当公务员，我觉得我不能接受，我不能接受自己的生活一眼就能望到底。一点波澜都没有；随着毕业工作了一年多，我好像已经习惯了当社畜的感觉。甚至心里还在想，好像公务员，当兵这种稳定的事情，其实也不错，朝九晚五，这样的生活多好啊！ 但是，一成不变的生活真的是我想要的吗？曾经的我喜欢稳定，我惧怕、拒绝变化，觉得变化是我不能接受，不能掌控的，但是，变化，才能有新事物，每一天都是未知的，都是随机的感觉这样不好吗？我才23，为什么已经不想要变化了呢？ 我需要好好反思，当然，因为是长大了，接触的事情多了，自己的世界观变大了，以前小时候，世界观就这么大，以为整个世界都是自己的，世界的中心就是我身边的圈子，现在长大了，接触的，看到了，感受到的事物多了，好像把自己的位置变得比较靠后了，考虑的因素多了起来。可是，这样的生活真的是你想要的吗？ 就像最后说的，我一定会找到你！我要在接触了世界之后，还能在人群中，一眼找到你。毕竟我们都是孩子。不是吗？孩子还有无限的可能。我喜欢未知，未知的世界才是充满魅力的世界"},{"title":"适用于webkit的自定义浏览器样式","path":"/2020/08/17/适用于webkit的自定义浏览器样式/","content":"前言： 现在越来越要求“表面功夫”了，几乎所有的手机端浏览器的滚动条都是Mini版本，近些年来，部分PC端的前端页面的滚动条也开始变得妖艳贱货了起来。这里做下记录方便个人查看 [scode type&#x3D;”blue”]必须为webkit内核，即样式前缀需支持-webkit-,也可配合css选择使用，若不搭配使用，则为全局样式[&#x2F;scode] 伪元素 选择器 备注 滚动条 ::-webkit-scrollbar 整体 滚动条按钮 ::-webkit-scrollbar-button 上下方向键 滚动条轨道 ::-webkit-scrollbar-track 滚动条滚动的上下去区间 滚动条-补偿 ::-webkit-scrollbar-track-piece 滚动条轨道-滚动条实体的部分 滚动条-实体 ::-webkit-scrollbar-thumb 滚动条实体 水平垂直滚动条交接部分 ::-webkit-scrollbar-corner 基本为页面右下角 拖动区 ::-webkit-resize 与滚动条交接区重合，可以重设大小 [scode type&#x3D;”share”]tips:我们可以为这些对象中的每个对象设置边框，阴影，背景图像等样式，以创建完全自定义的滚动条，当然，且没有疑惑这些滚动条在按钮位置和单击行为方面仍将遵循操作系统的设置。[&#x2F;scode] 另外，引入了以下伪类并将其应用于伪元素。 :horizontal –水平伪类适用于任何具有水平方向的滚动条。 :vertical –垂直伪类适用于任何具有垂直方向的滚动条。 :decrement–减量伪类适用于按钮和轨道块。它指示按钮或轨道块在使用时是否会降低视图的位置（例如，在垂直滚动条上向上，在水平滚动条上左侧）。 :increment–增量伪类适用于按钮和跟踪片段。它指示按钮或轨迹块在使用时是否会增加视图的位置（例如，在垂直滚动条上向下，在水平滚动条上右侧）。 :start– start伪类适用于按钮和跟踪片段。它指示对象是否放置在拇指之前。 :end–结束伪类适用于按钮和跟踪片段。它指示对象是否放置在拇指后面。 :double-button–双按钮伪类适用于按钮和轨道块。它用于检测一个按钮是否是位于滚动条同一端的一对按钮的一部分。对于履带板，它指示履带板是否邻接一对按钮。 :single-button–单按钮伪类适用于按钮和轨道块。它用于检测按钮是否位于滚动条末尾。对于履带板，它指示履带板是否邻接单例按钮。 :no-button –适用于曲目片断，并指示曲目片断是否延伸到滚动条的边缘，即，曲目的那端没有按钮。 :corner-present –适用于所有滚动条，并指示是否存在滚动条角。 :window-inactive–适用于所有滚动条，并指示包含滚动条的窗口当前是否处于活动状态。（在最近的夜间，此伪类现在也适用于:: selection。我们计划将其扩展为可处理任何内容，并将其提议为新的标准伪类。） 此外，：enabled，：disabled，：hover和：active伪类也可以与滚动条一起使用。 可以将display属性设置为none，以便隐藏特定的作品。 沿滚动条的轴支持边距。它们可以是负数（例如，可以使轨道膨胀以部分覆盖按钮）。 举个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041::-webkit-scrollbar:vertical &#123; -webkit-border-image: url(resources/vertical-button.png) 2 0 2 0; border-color: transparent; border-width: 2px 0; background-image: url(resources/vertical-button-background.png); background-repeat: repeat-y;&#125;::-webkit-scrollbar-track-piece:disabled &#123; display: none !important;&#125;::-webkit-scrollbar-track:vertical:disabled &#123; -webkit-border-image: url(resources/vertical-track-disabled.png) 13 0 13 0; border-color: transparent; border-width: 13px 0;&#125;/** 或者 **//*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/::-webkit-scrollbar&#123; width: 3px; height: 16px; background-color: rgba(255,255,255,0);&#125; /*定义滚动条轨道 内阴影+圆角*/::-webkit-scrollbar-track&#123; -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3); border-radius: 10px; background-color: rgba(255,255,255,0);&#125; /*定义滑块 内阴影+圆角*/::-webkit-scrollbar-thumb&#123; border-radius: 10px; -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3); background-color: #555;&#125; 样式滚动条"},{"title":"泰山随笔","path":"/2020/07/27/泰山随笔/","content":"上周日回了一趟家，晚上回到上海之后就在想一个问题：端午干嘛?是不是太无聊了? 好的直接计划泰山，周一确定计划，周二摇人买票，周三摸鱼，周四开冲！ 直接上午高铁出发了。 [vplayer url&#x3D;”https://www.godlike.top/usr/uploads/2020/07/1788278680.mp4&quot;] 老刘这个家伙直接上了高铁就睡觉了，有点弱的不行！ ![fbfdc448ccb865fa6d699d5f37266ce.jpg][1] 下次是哪次？改天是哪天？以后是多久？不管如何，干就完了。 到了泰安，天气不错哦~，但是已经下午四点了，怎么也得吃点东西再出发把？ 面27一碗，肉还是挺足的。大满足！ ![10a639d3565c7a38ea94d4c75beb112.jpg][2] 如果火车的话，很近就能到泰山脚下，但是我们高铁，还是花35块钱打的吧。 车上还在说老刘不行，我在出租上也直接睡着了。被老刘这个逼给偷拍了。淦！ 我们上山走的是正经的红门路线。为什么叫红门呢？可能是因为房间都是红色的吧？ 照片里可能看不出来有多陡，但是看老刘的身高和台阶的比例就知道了吧？太抖了！还好我有偷偷锻炼，所以其实还行，但是老刘这个家伙就不行了，走一段路就啊啊啊不行了不行了。 然后看到前面有喜欢的妹妹也在走动，马上换了一副面孔，冲冲冲！我刘某又行了。 ![2bc5db6861fd512bebb390e105054c4.jpg][7] 一路载歌载舞，听刘某吹吹牛，还在想会不会遇到九龙拉棺。害就到了最难爬的十八盘 过了18盘。再过了一段几乎垂直的陡坡，终于上了南天门，见了“天宫” 到了南天门就顺便休息一下，跟同路的妹妹们聊一下天~ 但是这个时候才半夜12点，日出还有四小时呢怎么办呢？ 等等呗，顺便吹吹牛，在老刘去厕所的时候，他跟着的小姐姐去买东西吃，然后休息了，本来我们也准备这么做，但是找不到他们，然后随便找了一家店，点了一份十块钱的拉面，为什么拉面十块钱，泡面15，我想你们也应该猜出来味道怎么样了。太坑了。害 开始出发，日观峰。 走着走着，临近一点了，雾气越来越大了，感觉要开始下雨了，只能找个店家多一下雨，顺便小酣一下~ 雨过天晴，我觉得这次的日出好像稳了！ 去山顶的路上遇到了一个人在苏州读大学的妹子。第二次来泰山（一个人）太强了。随意聊了一下。很有感触。 好景不长，虽然到了日观峰，也差不多占了好位置，但是雾气越来越大了，风也越来越大。我一度怀疑自己会不会山东14天游！ 好的又开始下大雨了，被疏散了。。 行吧，本来六点半才营业的索道直接给我们五点半就开始营业了。下到半山，直接去了高铁站，买了最早的动车，出发，回家！ 虽然这次旅程略有遗憾，没有看到日出，但是我登顶了~也不虚此行。遇到了一些很有意思的人。"},{"title":"别让自己“墙”了自己","path":"/2020/07/27/别让自己“墙”了自己/","content":"[scode type&#x3D;”blue”]别限制了自己[&#x2F;scode] 这两天看了《富爸爸穷爸爸》粗略了解了财商，其实归根结底是提升自己的能力 也让自己的价值观具现化了[post cid&#x3D;”521” &#x2F;] 这些都是收获，不过今天看的这篇文章《别让自己“墙”了自己》，让我收获很大，以一个过来人的身份告诉我年轻人应该有什么优秀的品质，应该做怎么样的事情 做有价值的事 | 这个符合我的事业观:做对别人有价值事情 扩大自己的眼界，开放自己的内心 | 人生观和事业观 你的英文语言能力对你能不能融入世界是起决定性的作用 你的视野决定了你的知不知道要去哪，你的开放决定了你想不想去 站在更高的维度 | 思维方式 精于计算得失 | 《富爸爸穷爸爸》: 先支付自己的账单，再支付别人的账单 精于计算得失的，就懂得什么是投资，不懂的只会投机。对于赚钱，你可以投机，但是对于自己最好还是投资。 勇于跳出传统的舒服 | 改变的力量你真的喜欢改变吗？在正确的时间做正确的事情 井蛙不可以语于海者，拘于虚也；&#x2F;&#x2F;空间局限夏虫不可以语于冰者，笃于时也；&#x2F;&#x2F;时间局限曲士不可以语于道者，束于教也。&#x2F;&#x2F;认识局限 别自己墙了自己，人最可悲的就是自己限制自己，想都不敢想，共勉！ 别让自己“墙”了自己"},{"title":"前端如何优化首次渲染性能","path":"/2020/03/31/前端如何优化首次渲染性能/","content":"性能优化需求产生原因前端项目日益加大，并且三大框架Angular, Vue, React导致单页面应用(SPA)大行其道,小程序的日益化也导致现在前端需要优化项目的首次渲染速度。 如何优化，归根结底就是了解一个网页是如何渲染的，一个简单的网页渲染分为两个大步骤 文档对象模型DOM CSS对象模型CSSOM 网页的渲染步骤文件的获取DOM下图是浏览器获取网页DOM文件并渲染成DOM的步骤图 1. **转换：** 浏览器从网络或者本地磁盘读取HTML的原始字节，并根据文档的指定编码（such as utf-8 full-process.png转换成可视字符 令牌化 浏览器将字符转换成W3C HTML5 标准规定的各种令牌,例如 ，每个令牌都有其特殊意义和规则 词法分析 将令牌转化成定义其属性和规则的对象 DOM构建 HTML标记定义不同标记之间的关系，创建一个树形的主从关系，成为DOM树 CSSOM浏览器在构建页面时，从head标记中获取到了link标记，其引用了外部的样式 style.css, 会立即发起请求获取此css文件,例如 12345body &#123; font-size: 16px &#125;p &#123; font-weight: bold &#125;span &#123; color: red &#125;p span &#123; display: none &#125;img &#123; float: right &#125; PS: 诚然，直接使用内联CSS在速度让肯定比请求网络资源快，但是现代前端页面崇尚将内容与设计进行关注点分离；即设计人员专注于CSS，开发者侧重HTML 获取CSS文件之后，我们依旧需要讲CSS规则转换成浏览器能够理解和处理的东西，所以我们会重复HTML的步骤，不过主体变为了CSS。 cssom-construction.png 字节 &#x3D;&gt; 字符 &#x3D;&gt; 令牌 &#x3D;&gt; 节点 &#x3D;&gt; CSSOM [scode type&#x3D;”blue”]为什么是树形结构，是为了样式的继承即规则: “向下级联”[&#x2F;scode] cssom-tree.png 生成渲染树在完成DOM和CSSOM各自的转换之后，浏览器会把两者整合为渲染树 DOM和CSSOM合并后形成渲染树 渲染树只包含页面需要显示的部分 计算布局每一个对象的精确位置和大小 最后一个将像素渲染到屏幕上 渲染细节 从DOM树的根节点开始遍历每一个可见节点 某些节点不可见(脚本标记，元标记等)会被跳过忽略 设置了css隐藏样式的节点也会被忽略，例如display: none 为每一个可见的节点匹配其对应的CSSOM规则并应用它 讲可见节点整合进渲染树，包含其CSSOM规则和内容 布局知道了需要渲染的内容，还需要匹配屏幕，即将节点转换为屏幕上的像素点，这一步称为“栅格化”或“绘制” 执行渲染树构建、布局、绘制所需的时间取决于文档的大小、应用的样式以及硬件性能。 文档大小和时间成正比、样式复杂度和时间成正比、性能和时间成反比 总结步骤 处理HTML标记并构建DOM树 处理CSS标记并构建CSSOM树 将DOM和CSSOM合并为一个渲染树 根据渲染树来布局，并计算每个节点的几何信息 将节点绘制到屏幕上 [scode type&#x3D;”red”]请注意当CSSOM和DOM发生更改，上述所有步骤将会重新执行！[&#x2F;scode] 优化的关键就是最大限度缩短上述5步的时间开销 导致阻塞的原因阻塞渲染的CSS默认情况下，CSS会导致渲染的阻塞，即直至CSSOM构建完毕完成前，浏览器都不会渲染任何已处理的内容！ 我们知道在构建渲染树时，DOM和CSSOM必须同时存在。 HTML和CSSd都是阻塞渲染的资源, 但是从实际状况出来，HTML的优先级是强于CSS的,因为没有HTML等于没有需要展示的实质内容。 [scode type&#x3D;”share”]CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。[&#x2F;scode] 诚然，有些CSS样式只在某些特殊的情况下需要，比如打印和媒体查询,我们可以通过特殊的标识符来通知浏览器此资源不阻塞渲染 123&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;&lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 40em)&quot;&gt; [scode type&#x3D;”share”]请注意“阻塞渲染”仅是指浏览器是否需要暂停网页的首次渲染，直至该资源准备就绪。无论哪一种情况，浏览器仍会下载 CSS 资产，只不过不阻塞渲染的资源优先级较低罢了。[&#x2F;scode] 阻塞渲染的Javascriptjavascript可以修改页面的内容和样式和用户交互，当然它也会阻塞DOM构建和延缓页面的渲染，所以为了最佳的性能，我们应该让javascript异步执行，并使得页面渲染的关键路径中不要出现任何JavaScript [scode type&#x3D;”share”]一个重要事实：我们的脚本在文档的何处插入，就在何处执行。所以绝大多数JavaScript脚本的位置都在body标志的尾部[&#x2F;scode] 脚本在文档中的位置很重要 当浏览器遇到一个script标志时，DOM构建讲暂停，直至脚本运行结束 JavaScript可以查询DOM和CSSOM，并修改他们 JavaScript会在CSSOM就绪之后运行！ 默认情况下，内联和外部JavaScript都会暂停DOM的渲染，通过添加async关键字，可以大幅提升渲染性能 1&lt;script src=&quot;app.js&quot; async&gt;&lt;/script&gt; 如何监听网页渲染关键步骤通过浏览器的Navagation Timing Api捕获所有相关时间戳配合页面加载时其他浏览器事件，我们可以捕获并计算出到浏览器从获取第一批文档资源到页面展示完整的完整时间损耗 相关时间戳的含义 domLoading: 整个过程的起始时间戳，浏览器即将开始解析接受到的第一批HTML文档文件 domInteractive: 表示浏览器完成对所有HTML的解析并且DOM构建完成的时间点 domContentLoaded: 表示DOM准备继续并且没有样式表阻止JavaScript执行的时间点，即开始构建渲染树 许多JavaScript框架在等待此事件发生后再运行其本身的逻辑 domComplete: 顾名思义，所有事件完成，所有资源加载完成，即页面转环停止转动 loadEvent: 做为每个网页加载的最后一步，浏览器会触发onload事件 HTML 规范中规定了每个事件的具体条件：应在何时触发、应满足什么条件等等。对我们而言，我们将重点放在与关键渲染路径有关的几个关键里程碑上： domInteractive： 表示DOM准备就绪的时间点 domContentLoaded ： 一般表示DOM和CSSOM均准备就绪的时间点 如果没有阻塞解析器的JavaScript, 则DOMContentLoaded 将在domInteractive 后立即触发 因为一般来说css在文件中比JavaScript先获取 domComplete : 表示网页以及其所有子资源都加载完毕的时间点 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Critical Path: Measure&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script&gt; function measureCRP() &#123; var t = window.performance.timing, interactive = t.domInteractive - t.domLoading, dcl = t.domContentLoadedEventStart - t.domLoading, complete = t.domComplete - t.domLoading; var stats = document.createElement(&#x27;p&#x27;); stats.textContent = &#x27;interactive: &#x27; + interactive + &#x27;ms, &#x27; + &#x27;dcl: &#x27; + dcl + &#x27;ms, complete: &#x27; + complete + &#x27;ms&#x27;; document.body.appendChild(stats); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;measureCRP()&quot;&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 优化pageSpeed为了尽快完成首次渲染，我们需要最大限度减少以下三种可变因素: 关键资源的数量 关键路径的长度 关键字节的长度 关键资源是可能阻止网页首次渲染的资源 同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。 最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。 优化关键渲染路径的常规步骤如下： 对关键路径进行分析和特性描述：资源数、字节数、长度。 最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。 优化关键字节数以缩短下载时间（往返次数）。 优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。 JavaScript优化建议 优先异步JavaScript 避免使用同步服务器调用 延迟解析JavaScript 避免运行长时间的JavaScript CSS优化建议 将CSS置于Head标志内 避免使用CSS import 适当情况下使用内联CSS [优化关键渲染路径][4] 补充: 回流和重绘在之前说到的浏览器绘制步骤中 回流:改变DOM的布局 重绘:改变DOM除布局以外的部分（颜色，透明度） 那么什么时候会触发回流和重绘呢？ 回流一定会触发重绘，而重绘不一定会触发回流！"},{"title":"TS之this形参-即指定this类型","path":"/2020/03/03/TS之this形参-即指定this类型/","content":"在VS code 中 使用ts编码时写了一个很简单的代码: 1window.onmousedown = xxx 此时鼠标移动上来会出现类型推断的提示： 批注 2020-03-03 220407.png 这个时候我就在想： 两个参数吗？ 可是我们平时调用不就是一个Event对象传入吗？ 于是我就去翻阅资料 结论TS中可以使用this形参来指定当前函数的this对象 举个栗子 12345678function demo() &#123; console.log(this.length); //this并没有length这一方法，所以不会自动弹出联想&#125;function demo2(this: Array&lt;any&gt;)&#123; console.log(this.length)&#125; 但是需要注意的是，this形参只能在参数列表的第一个出现，并且只会在ts文件中出现，编译成js后并会有这个形参，只是辅助TS校验用 即：传递参数的时候跳过this 12345678function demo(this: void, arg:any) &#123; //这种情况即告诉编译器this不存在，无法调用this console.log(arg);&#125;//调用demo(&#x27;测试&#x27;); 所以图1的情况就是TS编译器在告诉我们此时函数的this上下文是什么(图中为GlobalEventHandlers或者重载的Window对象) 批注 2020-03-03 220913.png 说点别的 win10自带的截屏除了原来的PrintScrn 还可以使用win + shift + s 调出更加复杂的截图界面"},{"title":"angular2+中使用renderer2代替原生js方法创建以及操控DOM对象","path":"/2020/02/13/angular2-中使用renderer2代替原生js方法创建以及操控DOM对象/","content":"[scode type&#x3D;”green”]今天遇到一个需要类似右击然后创建一个菜单的时候，陷入了误区，为什么要自己操控dom呢？angular明明优势就是数据操控视图，直接在页面的定义好对应的组件（不显示），直接通过数据控制不就行了吗？[&#x2F;scode] 1window.document.createElement() 这个基本大家都使用过虽然在angular中也能使用，不过因为逻辑上Angular以组件为单位划分，这其实是很不合理的，所以官方提供个封装好的方法给我们使用 let demo = this.renderer2.createElement(&#39;a&#39;);this.renderer2.appendChild(this.el.nativeElement, demo); [post cid&#x3D;”358” &#x2F;] 这里的el.nativeElement替代当前控制器所操控的实际DOM结构 请看下文 &#x2F;&#x2F;这里可以理解为当前组件ts 逻辑上的body部分 123456import &#123; Component, OnInit, AfterViewInit, ViewChild, ElementRef, Renderer2, OnDestroy &#125; from &#x27;@angular/core&#x27;;constructor( private renderer2: Renderer2, private el: ElementRef, ) &#123; &#125; 然后就是控制属性的code： 1this.renderer2.setAttribute(demo, &#x27;download&#x27;, this.pdfName); 移除DOM： 1this.renderer2.removeChild(this.el.nativeElement, tempLink); 聊点别的 从过年前的的不到一万，现在已经6w了。 2020计划: &#x3D;&gt; 活着"},{"title":"在Angular中使用RxJS完成接口数据的缓存","path":"/2019/12/16/在Angular中使用RxJS完成接口数据的缓存/","content":"在实际项目中，很多共用的接口返回的数据是一样的，这样许多页面多次调用会造成性能浪费，可以使用RxJS的ReplaySubject(size)发送之前的旧值给新的订阅者。 用ReplaySubject(size)可以发送之前的旧值给新的订阅者，size是定义发送具体多少个旧值给新的订阅者。 shareReplay这个操作符会自动创建一个ReplaySubject，一旦http request执行一次以后，就会在后续的订阅和源头Observable之间建立一个ReplaySubject，ReplaySubject是一个多播的Hot Observable，后续订阅都是从这个中间ReplaySubject拿到最后一个值，从而达到缓存效果。 方法与正常调用服务层，相差无几，只是多了一个”中间商” 在cacheServices.ts中 1234567891011121314151617181920212223242526272829303132333435363738import &#123; Injectable &#125; from &quot;@angular/core&quot;;import &#123; HttpClient &#125; from &quot;@angular/common/http&quot;;import &#123; map, catchError, shareReplay &#125; from &#x27;rxjs/operators&#x27;;import &#123; of, Observable &#125; from &#x27;rxjs&#x27;;const CACHE_SIZE = 1;@Injectable()export class cacheServices&#123; private cacheTemp:Observable&lt;any&gt;; constructor(private http: HttpClient) &#123; &#125; chache() &#123; if(!this.cacheTemp)&#123; this.cacheTemp= this._chache() .pipe( shareReplay(CACHE_SIZE) ); &#125; return this.cacheTemp; &#125; private _chache() &#123; return this.http.get&lt;any&gt;(&quot;xxx&quot;) .pipe( map(respone =&gt; respone), catchError(error =&gt; &#123; console.log(&quot;something went wrong &quot; + error) return of([]); &#125;) ) &#125;&#125; 页面的第一个请求是调用API拿到信息，第二个调用，直接从cacheTemp拿到这个缓存信息。cacheTemp是ReplaySubject(1)把最后一个旧值（api return）发送给新的订阅者，从而实现了缓存效果。 RxJS：如何通过RxJS实现缓存"},{"title":"记录下工作中需要用到的GIT命令","path":"/2019/12/06/记录下工作中需要用到的GIT命令/","content":"这里记录一下日常工作中使用的到的git命令 git-zoom.png [scode type&#x3D;”blue”]关于git flow，新版本git已默认附带，使用需要初始化[&#x2F;scode] 指令 作用 git branch -d branch-name 删除本地分支 git branch -D branch-name 强制删除本地（没有合并的）分支 git push origin --delete name 删除远程分支 git tag -d v1.0 删除本地标签 git push origin --delete v1.0 删除远程标签 git remote prune origin –dry-run 清理无效的远程引用 git flow feature start branchname 开始 开发特性分支xxx git flow feature finish branchname 结束 开发特性分支xxx git flow release start releasename 开始 版本发布 git revert xx 撤销某一次提交 git merge --no-ff branchname 合并分支（禁用快进方式） git rebase branchname 变基， 优化提交次数，使用后切换分支再使用merge会变为快进提交！(只能在未发布远程的分支使用，否则人民会唾弃你)"},{"title":"一个关于谷歌浏览器与其他浏览器图片显示有差异的问题","path":"/2019/11/26/一个关于谷歌浏览器与其他浏览器图片显示有差异的问题/","content":"今天在网站上发现有一张图片，在浏览器中显示是带有一丝黄色的背景色，下载后本地打开就是预期的蓝色背景色。 后来研究发现是谷歌浏览器的图片显示问题(后期可能修复)。应该是图片的RGB设置问题，用火狐浏览器查看相应图片显示正常！ [scode type&#x3D;”blue”]可以用不同浏览器查看本图片[&#x2F;scode] 49b8b710-ac2c-432c-a120-41514ecc3637.jpg 解决方案"},{"title":"一些JS的小技巧","path":"/2019/11/21/一些JS的小技巧/","content":"![javascript.jpg][1] 快速生成6位验证码1Math.random().toString(36).substr(2, 6); 转换数字123const number = &#x27;10&#x27;;number = +number;console.log(number); // 10 1234// 强制取整 ， 带有强制的类型转换，非法的转换之后取0const number = &#x27;10&#x27;;number = ~~number;console.log(number); // 10 快速浮点转整型123// 浮点不能进行或运算，所以会取整，或0保持不变console.log(10.9 | 0); // 10console.log(-10.9 | 0); // -10 123// 强制取整 ， 带有强制的类型转换，非法的转换之后取0console.log(~~10.9);console.log(~~-10.9); 数组降维二维数组12345678910let arr = [ [1], [2], [3] ];arr = Array.prototype.concat.apply([], arr);console.log(arr);// [1, 2, 3]//flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。//var newArray = arr.flat([depth])let array = [ [1], [2], [3] ];array = array.flat(2);console.log(array); // [1, 2, 3] 多维数组123let arrMore = [1, 2, [3], [[4]]];arrMore = arrMore.flat(Infinity); ///全局属性 Infinity 是一个数值，表示无穷大。console.log(arrMore); 判断小数是否相等12345// 原理为判断实际差值是否小于阈值function equal(number1, number2) &#123; return Math.abs(number1 - number2) &lt; Math.pow(2, -52);&#125;console.log(equal(0.1 + 0.2, 0.3)); 判断变量是否为数组123451. instanceof2. array.__proto__.constructor === Array3. array.constructor === Array4. Array.isArray（兼容性问题）5. Object.prototype.toString.call([]) === &quot;[object Array]&quot;（最通用） //同理和可以判断任意其他类型 PS：instanceof和constructor判断的变量，必须在当前页面声明。例如：父页面是一个框架，框架中引入一个页面（子页面），在子页面中申明的array，并将其复制给父元素的一个变量，这时instanceof和constructor判断该变量，将返回false。—————————————————————————————————————– 原因： array是复合类型。在传递的过程中，仅仅是引用地址的传递。每个页面的array原生对象引用的地址是不一样的，在子页面中声明的array，所对应的构造函数，是子页面的array对象，在父页面进行判断时，使用的并不是子页面的array。 数组去重12345Array.prototype.unique = function() &#123; return [...new Set(this)];&#125;var array = [1, 2, 3, 43, 45, 1, 2, 2, 4, 5];array.unique(); 短路运算符 &amp;&amp; ||使用&amp;&amp;将返回第一个条件为假的值。如果每个操作数的计算值都为true，则返回最后一个计算过的表达式。123let one = 1, two = 2, three = 3;console.log(one &amp;&amp; two &amp;&amp; three); // 3console.log(0 &amp;&amp; null); // 0 使用||将返回第一个条件为真的值。如果每个操作数的计算结果都为false，则返回最后一个计算过的表达式。123let one = 1, two = 2, three = 3;console.log(one || two || three); // 1console.log(0 || null); // null 过滤空值12let result1 = [1, 2, 0, undefined, null, false, &#x27;&#x27;].filter(Boolean);console.log(result1); 合并对象12345const person = &#123; name: &#x27;David Walsh&#x27;, gender: &#x27;Male&#x27; &#125;;const tools = &#123; computer: &#x27;Mac&#x27;, editor: &#x27;Atom&#x27; &#125;;const attributes = &#123; handsomeness: &#x27;Extreme&#x27;, hair: &#x27;Brown&#x27;, eyes: &#x27;Blue&#x27; &#125;;const summary = &#123; ...person, ...tools, ...attributes &#125;;console.log(summary); 字符串去空格123String.prototype.trim = function()&#123;return this.replace(/^\\s+|\\s+$/g, &quot;&quot;);&#125;;//去两端 string.trim()"},{"title":"使用JS检测协议是否存在","path":"/2019/11/08/使用JS检测协议是否存在/","content":"[scode type&#x3D;”yellow”]移动点击打开软件或跳转至应用商城推荐使用，PC端使用不多[&#x2F;scode] 移动端开发，一个绕不开的问题就是，如何在H5页面中，把用户引流到自家的APP中，现通用的方法如下图所示： ![微信图片_20191108101934.jpg][1] 最上方可关闭提示，为Safari自带的应用商店功能标签，实现方法为添加&lt;meta&gt;标签。↓ 123&lt;meta name=&#x27;apple-itunes-app&#x27; content=&#x27;app-id=477927812&#x27;&gt; &lt;!-- 上面的方法仅限于iOS设备，且无法定义Banner的形式。另外打开应用时也无法告诉App端要做什么操作。 --&gt; &lt;!-- app-id 对应 App Store里面ID，我使用的百度贴吧的ID--&gt; 页面浮动在底部App内打开为普遍方法，样式可能会因站而异，但原理相同，话不多说直接上code [scode type&#x3D;”share”]protocolcheck[&#x2F;scode] Examp.html 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Custom Protocol Detection&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Click one of these labels:&lt;/h1&gt; &lt;div href=&quot;blahblah:randomstuff&quot;&gt;虚假url &lt;/div&gt; &lt;div href=&quot;mailto:johndoe@somewhere.com&quot;&gt;真实url &lt;/div&gt; &lt;script src=&quot;https://code.jquery.com/jquery-1.11.2.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;protocolcheck.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;example.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Example.js 123456789$(function () &#123; $(&quot;div[href]&quot;).click(function (event) &#123; window.protocolCheck($(this).attr(&quot;href&quot;), function () &#123; alert(&quot;url无效！&quot;); &#125;); event.preventDefault ? event.preventDefault() : event.returnValue = false; &#125;);&#125;); [scode type&#x3D;”blue”]是否需要使用Jquery因人而异，请根据自身项目自行决定，事件绑定方法，也请根据页面情况自行修改！[&#x2F;scode]"},{"title":"GET和POST两种基本请求方法的区别","path":"/2019/10/22/GET和POST两种基本请求方法的区别/","content":"GET和POST两种基本请求方法的区别GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。 最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。 你可能自己写过无数个GET和POST请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。 当你在面试中被问到这个问题，你的内心充满了自信和喜悦。 640.jpg 你轻轻松松的给出了一个“标准答案”： GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 （本标准答案参考自w3schools） “很遗憾，这不是我们要的回答！” 640 (3).jpg 请告诉我真相。。。 如果我告诉你GET和POST本质上没有区别你信吗？ 让我们扒下GET和POST的外衣，坦诚相见吧！ 640 (4).jpg GET和POST是什么？HTTP协议中的两种发送请求的方法。 HTTP是什么？HTTP是基于TCP&#x2F;IP的关于数据如何在万维网中如何通信的协议。 HTTP的底层是TCP&#x2F;IP。所以GET和POST的底层也是TCP&#x2F;IP，也就是说，GET&#x2F;POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 那么，“标准答案”里的那些区别是怎么回事？ 640 (2).jpg 在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。 但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？ 640 (1).jpg 在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。 好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 你以为本文就这么结束了？ 0.png 我们的大BOSS还等着出场呢。。。 这位BOSS有多神秘？当你试图在网上找“GET和POST的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢。。。 GET和POST还有一个重大区别，简单的说： GET产生一个TCP数据包；POST产生两个TCP数据包。 长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 现在，当面试官再问你“GET与POST的区别”的时候，你的内心是不是这样的？ 640.jpg 结束！！！ 来源：99%的人都理解错了HTTP中GET与POST的区别"}]