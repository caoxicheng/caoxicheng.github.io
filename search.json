[{"title":"测试评论专用","path":"/2023/06/16/测试评论专用/","content":"这篇文章专门用来测试博客的评论功能(giscus)"},{"title":"使用TypeScript编写一个简单而实用的网页爬虫","path":"/2023/04/27/使用TypeScript编写一个简单而实用的网页爬虫/","content":"在这篇博客中，我们将深入探讨如何使用TypeScript编写一个简洁实用的网页爬虫，用于抓取指定页面中特定标签的内容。网络爬虫在互联网领域具有广泛的应用，它们可以帮助我们从各种网站上获取有价值的… 在这篇博客中，我们将深入探讨如何使用TypeScript编写一个简洁实用的网页爬虫，用于抓取指定页面中特定标签的内容。 网络爬虫在互联网领域具有广泛的应用，它们可以帮助我们从各种网站上获取有价值的信息。在本文中，我们将介绍如何使用TypeScript和一些流行的库来构建一个简单的爬虫，用于抓取指定页面中特定标签的内容。 准备工作首先，我们需要确保已经安装了Node.js和npm。接下来，我们将安装两个库：axios 和 cheerio。axios 是一个用于发送HTTP请求的库，而 cheerio 是一个用于解析HTML并提取数据的库。您可以使用以下命令安装这两个库： 1npm install axios cheerio 同时，安装TypeScript及其类型定义： 1npm install typescript @types/axios @types/cheerio 编写爬虫代码接下来，让我们看看如何使用这些库编写我们的爬虫。以下是一个简单的TypeScript爬虫脚本： 123456789101112131415161718192021222324252627282930313233343536import axios from &#x27;axios&#x27;;import cheerio from &#x27;cheerio&#x27;;interface ScrapedData &#123; title: string link: string&#125;async function fetchHTML(url: string): Promise&lt;string&gt; &#123; try &#123; const &#123; data &#125; = await axios.get(url); return data; &#125; catch (error) &#123; console.error(`Error fetching HTML from $&#123;url&#125;:`, error); return &#x27;&#x27; &#125;&#125;function extractDataFromHTML(html: string, target: string = &#x27;a&#x27;): ScrapedData[] &#123; const $ = cheerio.load(html); const scrapedData: ScrapedData[] = []; // 选取要抓取的元素,这里以 &lt;a&gt; 标签为例 $(target).each((_index, element) =&gt; &#123; const _element = $(element); scrapedData.push(&#123; title: _element.text(), link: _element.attr(&#x27;href&#x27;) || &#x27;&#x27; &#125;); &#125;) return scrapedData;&#125;export async function scrapeWebsite(url: string, targetName: string): Promise&lt;ScrapedData[]&gt; &#123; const html = await fetchHTML(url); return extractDataFromHTML(html, targetName);&#125; 在上面的脚本中，我们首先定义了一个ScrapedData接口，用于存储爬取到的数据。接着，我们实现了两个核心函数：fetchHTML 和 extractDataFromHTML。fetchHTML 函数用于从指定的URL获取HTML内容，而 extractDataFromHTML 函数则用于从HTML中提取指定标签的数据。 我们在extractDataFromHTML函数中使用了cheerio库，它提供了类似于jQuery的API，使得提取数据变得更加简单。在这个例子中，我们以&lt;a&gt;标签为例，但您可以根据需要修改extractDataFromHTML函数以提取其他类型的标签。 最后，我们导出了一个名为scrapeWebsite的函数，它接受一个URL和一个目标标签名称作为参数，并返回一个包含抓取到的数据的数组。这个函数封装了前面的fetchHTML和extractDataFromHTML函数，使得爬虫的使用变得简单明了。 使用示例以下是如何使用我们编写的爬虫从一个网站抓取所有&lt;a&gt;标签的示例： 123456789101112import &#123; scrapeWebsite &#125; from &#x27;./your_crawler_file&#x27;;async function main() &#123; const url = &#x27;https://www.example.com&#x27;; const targetTag = &#x27;a&#x27;; const scrapedData = await scrapeWebsite(url, targetTag); console.log(&#x27;Scraped data:&#x27;, scrapedData);&#125;main(); 这个例子中，我们导入了scrapeWebsite函数，并传入了一个示例网站的URL和目标标签&lt;a&gt;。爬虫将抓取该页面上所有&lt;a&gt;标签的文本内容和链接，然后将结果输出到控制台。 总结通过本文，我们学习了如何使用TypeScript和一些流行的库（axios和cheerio）来编写一个简单而实用的网页爬虫。虽然这个爬虫示例相对简单，但它可以作为编写更复杂爬虫的基础。您可以根据实际需求对其进行扩展，以提取更多类型的数据和处理更多种类的网页。 希望本文能对您有所帮助，祝您编程愉快！ 写在最后:这篇文章是由GPT自动生成了我只提供了关键代码片段,上面的案例也是GPT自动生成 另外,此案例的repo地址caoxicheng&#x2F;scrape-demo (github.com)"},{"title":"「瞎搞」-微信连接GPT","path":"/2023/04/22/「瞎搞」-微信连接GPT/","content":"前言最近在和GPT疯狂的聊天,想起来之前也想研究微信的自动应答,那么理论上是可以支持把GPT接入微信的,那么开干就干,下面展开说说…因为最近一直在和GPT闲聊,所以第一时间想到也是的直接问G… 前言最近在和GPT疯狂的聊天,想起来之前也想研究微信的自动应答,那么理论上是可以支持把GPT接入微信的,那么开干就干,下面展开说说… 因为最近一直在和GPT闲聊,所以第一时间想到也是的直接问GPT 图1 图1 因为提到了ichat,去搜索了相关的内容,不过说是代码很简陋+有封号危险,另外寻到了 Wechaty wechaty官方 中文文档 通过阅读 github 启动了一个 demo 小试牛刀按照介绍,直接 12pnpm install // 我习惯了pnpm,npm也可pnpm start 扫码登陆…… 事情没这么简单图2 图2 我直接愣住 图3 图3 我寻思这也能遇到Angualr(angualr大法好),不过我想到自己也是个angular开发,试试看能不能自己解决问题.进到问题点去看了一下,得是我没用过的内容 算了,直接去看issue,省略10mins 原因是微信的安全策略问题,需要配置 uos 模式[scode type&#x3D;”blue” size&#x3D;””]具体表现来说就是电脑登陆的话,手机扫码你电脑会被挤掉线[&#x2F;scode] 搞定ok,解决了这个小问题,我们直接开始测试,里面就判断一个很简单的内容,如果接收到信息为“ding”,则回复一个“dong”确实很入门 👇代码 图4 图4 👇效果 图5 图5 高阶玩法按照正常的流程接下来要开始研究文档,然后匹配自己的逻辑了,不过我这个比较鸡贼,想快速看到结果,就去搜索了一下关键字 微信 GPT hhhh,然后给我看了一个现成的应用ChatGPT-wechat-bot 其实是对于上文提到的 wechaty的一层封装 那么按照文档一步一步来(这里就把我之前遇到的 uos给默认打开了,但是官方的例子竟然没有修复!!!) 获取&#x2F;配置key……安装依赖……登陆……问答…… 图6 图6 后续api的方式调用的是GPT-3.5版本用起来确实没有GPT-4来的丝滑,不过最初的功能已经达成了 后期的设想 [ ] 商务的自动问答 [ ] 自动同意好友申请 [ ] 自动拉人进群 [ ] 更多 当然也有问题,就是群聊如果@你,不过你有群聊的备注,那么匹配不到,因为插件只会匹配你的微信名字,但是群聊@你是你群聊中的备注.当然这个可以通过改规则的正则来修复,我是比较简单的把我群聊的备注给删了.只是测试能成就行~ 顺便给我的微信好友们体验了一小时GPT的对话 图7 图7"},{"title":"使用GPT当作代码片段仓库","path":"/2023/04/17/使用GPT当作代码片段仓库/","content":"有些简单的代码片段其实是想保存下来的,之前有了解过一些工具,不过想用的性质不高,一方面是要收费,一方面积极性不高,也是因为一些内容一搜就知道了.不过今天在问GPT一个问题的时候,我突然想到:既然… 有些简单的代码片段其实是想保存下来的,之前有了解过一些工具,不过想用的性质不高,一方面是要收费,一方面积极性不高,也是因为一些内容一搜就知道了.不过今天在问GPT一个问题的时候,我突然想到:既然GPT是保存上下文的,那我能不能用它来保存代码片段呢?并且询问也比较方面,而且就算有我没有保存的片段,我也可以直接让它智能提示给我.那么即刻开干! […]"},{"title":"2023年2月阅读清单","path":"/2023/03/03/2023年2月阅读清单/","content":"weekly&#x2F;4.精读《AsyncAwait 优越之处》.md at master · ascoders&#x2F;weekly (github.com)weekly&#x2F;6.精读《JavaScript 错误… weekly&#x2F;4.精读《AsyncAwait 优越之处》.md at master · ascoders&#x2F;weekly (github.com) weekly&#x2F;6.精读《JavaScript 错误堆栈处理》.md at master · ascoders&#x2F;weekly (github.com) weekly&#x2F;36.精读《When You “Git” in Trouble- a Version Control Story》.md at master · ascoders&#x2F;weekly (github.com) weekly&#x2F;11.精读《前端调试技巧》.md at master · ascoders&#x2F;weekly (github.com) 条件JavaScript - JavaScript - 开发提示 (umaar.com)"},{"title":"2022年11月阅读列表","path":"/2023/02/22/2022年11月阅读列表/","content":"2022年11月阅读列表略读# 如何创建可重用和可配置的 Angular 组件# 使用 RxJs 停止对用户输入更改的冗余和不必要的 API 调用angular &amp; vite# 如何在 2022… 2022年11月阅读列表略读 # 如何创建可重用和可配置的 Angular 组件 # 使用 RxJs 停止对用户输入更改的冗余和不必要的 API 调用 angular &amp; vite # 如何在 2022 年成为 Angular Pro 开发人员——遵循 11 个简单步骤。 # 您可能从未使用过的最有用的 Angular 功能 # 使用两行代码在 Angular 中延迟加载图像 # Angular 中要避免的订阅和实践 Traits You Can Change, and Traits You Can’t | Stay SaaSy 细读 # Angular DOM 操作：ElementRef、TemplateRef 和 ViewContainerRef # 使用 @Log() 装饰器进行 Angular 方法日志记录 # 不要在 Angular 中绑定方法！ # 性能优化技术——角度方式。 # 深入研究 RxJs switchMap 运算符：它是如何工作的？ # 高阶 RxJs 映射运算符综合指南：switchMap、mergeMap、concatMap（和 excludeMap [# 角度变化检测——它是如何工作的？]("},{"title":"微前端实施方案","path":"/2023/01/31/微前端实施方案/","content":"介绍微前端微前端的概念是由 ThoughtWorks 在2016年提出的，它借鉴了微服务的架构理念，核心在于将一个庞大的前端应用拆分成多个独立灵活的小型应用，每个应用都可以独立开发、独立运行、独… 介绍微前端微前端的概念是由 ThoughtWorks 在2016年提出的，它借鉴了微服务的架构理念，核心在于将一个庞大的前端应用拆分成多个独立灵活的小型应用，每个应用都可以独立开发、独立运行、独立部署，再将这些小型应用融合为一个完整的应用，或者将原本运行已久、没有关联的几个应用融合为一个应用。微前端既可以将多个项目融合为一，又可以减少项目之间的耦合，提升项目扩展性，相比一整块的前端仓库，微前端架构下的前端仓库倾向于更小更灵活。 它主要解决了两个问题： 1、随着项目迭代应用越来越庞大，难以维护。 2、跨团队或跨部门协作开发项目导致效率低下的问题。 image.png image.png 开源框架字节跳动: Garfish 京东: micro-app 蚂蚁金服: qiankun (qiankun是基于 single-spa 的一层封装) 比较Garfish优势 自实现 提供缓存 沙盒功能 劣势 需要配置的配置项较多 基座应用必须为react 懒加载、刷新有时有奇怪的问题 不支持嵌套(子应用不能既是主又是子) micro-app优势 基于webComponent技术 嵌入无需新增依赖 应用无限制 沙盒功能 预加载 劣势 静态资源有时会有问题 angular子应用无法使用懒加载 不支持嵌套(子应用不能既是主又是子) 鉴于实际上手难度以及使用场景我们决定基于micro-app来实现我们的微前端方案 实操主应用(预算planning项目)1、安装依赖1npm i @micro-zoe/micro-app --save 2、在入口处引入123456789101112131415161718// index.jsimport microApp from &#x27;@micro-zoe/micro-app&#x27;microApp.start()// 实际代码(main.js)import &#123; enableProdMode &#125; from &#x27;@angular/core&#x27;;import &#123; platformBrowserDynamic &#125; from &#x27;@angular/platform-browser-dynamic&#x27;;import &#123; AppModule &#125; from &#x27;./app/app.module&#x27;;import &#123; environment &#125; from &#x27;./environments/environment&#x27;;// entryimport microApp from &#x27;@micro-zoe/micro-app&#x27;microApp.start()if (environment.production) &#123; enableProdMode();&#125;platformBrowserDynamic().bootstrapModule(AppModule) .catch((err) =&gt; console.error(err)); 3、增加对WebComponent的支持在app/app.module.ts中添加CUSTOM_ELEMENTS_SCHEMA到@NgModule.schemas 12345// app/app.module.tsimport &#123; NgModule, CUSTOM_ELEMENTS_SCHEMA &#125; from &#x27;@angular/core&#x27;;@NgModule(&#123; schemas: [CUSTOM_ELEMENTS_SCHEMA],&#125;) 4、分配路由给子应用1234567891011121314151617181920212223242526272829303132333435// app/app-routing.module.tsimport &#123; NgModule &#125; from &#x27;@angular/core&#x27;;import &#123; RouterModule, Routes &#125; from &#x27;@angular/router&#x27;;import &#123; MyAngularComponent &#125; from &quot;./my-angular/my-angular.component&quot;;import &#123; MyReactComponent &#125; from &quot;./my-react/my-react.component&quot;;import &#123; MyVueComponent &#125; from &quot;./my-vue/my-vue.component&quot;;const routes: Routes = [ &#123; // 👇 非严格匹配，/examples/angular/* 都指向 my-angular 页面 path: &#x27;examples/angular&#x27;, children: [&#123; path: &#x27;**&#x27;, component: MyAngular &#125;] &#125;, &#123; path: &#x27;examples/react&#x27;, children: [&#123; path: &#x27;**&#x27;, component: MyReactComponent &#125;] &#125;, &#123; path: &#x27;examples/vue&#x27;, children: [&#123; path: &#x27;**&#x27;, component: MyVueComponent &#125;] &#125;,];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule],&#125;)export class AppRoutingModule &#123; &#125; 5、在页面中嵌入子应用 123456789&lt;micro-app disableScopecss name=&#x27;app-angular&#x27; url=&#x27;http://localhost:3000/&#x27; baseroute=&#x27;/examples/angular&#x27;&gt;&lt;/micro-app&gt;&lt;!-- app/my-vue/my-vue.component.html --&gt;&lt;micro-app disableScopecss name=&#x27;app-vue&#x27; url=&#x27;http://localhost:8080/&#x27; baseroute=&#x27;/examples/vue&#x27;&gt;&lt;/micro-app&gt;&lt;!-- app/my-react/my-react.component.html --&gt;&lt;micro-app disableScopecss name=&#x27;app-react&#x27; url=&#x27;http://localhost:3001/&#x27; baseroute=&#x27;/examples/react&#x27;&gt;&lt;/micro-app&gt; 子应用Angular1、关闭热更新123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;ng serve --live-reload false&quot;,&#125;, 2、设置基础路由(如果基座是history路由，子应用是hash路由，这一步可以省略)123456789101112131415161718// app/app-routing.module.tsimport &#123; NgModule &#125; from &#x27;@angular/core&#x27;;import &#123; RouterModule, Routes &#125; from &#x27;@angular/router&#x27;;import &#123; APP_BASE_HREF &#125; from &#x27;@angular/common&#x27;;const routes: Routes = [...];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule], // 👇 设置基础路由 providers: [&#123; provide: APP_BASE_HREF, // angular子应用实测需要此中方式获取路径,可能是文档更新不齐全 // @ts-ignore __MICRO_APP_BASE_ROUTE__ 为micro-app传入的基础路由 useValue: (window[&quot;__MICRO_APP_PROXY_WINDOW__&quot;] &amp;&amp; window[&quot;__MICRO_APP_PROXY_WINDOW__&quot;][&quot;__MICRO_APP_BASE_ROUTE__&quot;]) || &#x27;/&#x27;, &#125;]&#125;)export class AppRoutingModule &#123; &#125; 3、设置publicPath步骤1: 在子应用src目录下创建名称为public-path.js的文件，并添加如下内容 12345// __MICRO_APP_ENVIRONMENT__和__MICRO_APP_PUBLIC_PATH__是由micro-app注入的全局变量if (window[&quot;__MICRO_APP_PROXY_WINDOW__&quot;] &amp;&amp; window[&quot;__MICRO_APP_PROXY_WINDOW__&quot;][&quot;__MICRO_APP_ENVIRONMENT__&quot;]) &#123; // eslint-disable-next-line __webpack_public_path__ = window[&quot;__MICRO_APP_PROXY_WINDOW__&quot;][&quot;__MICRO_APP_PUBLIC_PATH__&quot;]&#125; 步骤2: 在子应用入口文件的最顶部引入public-path.js 12// entryimport &#x27;./public-path&#x27; 4、监听卸载子应用被卸载时会接受到一个名为unmount的事件，在此可以进行卸载相关操作。 123456789101112// main.tslet app = null;platformBrowserDynamic() .bootstrapModule(AppModule) .then((res: NgModuleRef&lt;AppModule&gt;) =&gt; &#123; app = res &#125;)// 监听卸载操作window.addEventListener(&#x27;unmount&#x27;, function () &#123; app.destroy(); app = null;&#125;) React1、设置基础路由(如果基座是history路由，子应用是hash路由，这一步可以省略)12345678// router.jsimport &#123; BrowserRouter, Switch, Route &#125; from &#x27;react-router-dom&#x27;export default function AppRoute () &#123; return ( // 👇 设置基础路由，如果没有设置baseroute属性，则window.__MICRO_APP_BASE_ROUTE__为空字符串 &lt;BrowserRouter basename=&#123;window.__MICRO_APP_BASE_ROUTE__ || &#x27;/&#x27;&#125;&gt; ... &lt;/BrowserRouter&gt; )&#125; 或者 1234567891011// index.jsconst router = createBrowserRouter([ &#123; path: &#x27;/&#x27;, element: &lt;App /&gt; &#125;], &#123; // @ts-ignore basename: (window[&#x27;__MICRO_APP_BASE_ROUTE__&#x27;]) || &#x27;/&#x27; &#125;) 2、设置publicPath步骤1: 在子应用src目录下创建名称为public-path.js的文件，并添加如下内容 12345// __MICRO_APP_ENVIRONMENT__和__MICRO_APP_PUBLIC_PATH__是由micro-app注入的全局变量if (window.__MICRO_APP_ENVIRONMENT__) &#123; // eslint-disable-next-line __webpack_public_path__ = window.__MICRO_APP_PUBLIC_PATH__&#125; 步骤2: 在子应用入口文件的最顶部引入public-path.js 12// entryimport &#x27;./public-path&#x27; 3、监听卸载123456子应用被卸载时会接受到一个名为unmount的事件，在此可以进行卸载相关操作。window.addEventListener(&#x27;unmount&#x27;, function () &#123; root.unmount() // react 18 // ReactDOM.unmountComponentAtNode(document.getElementById(&#x27;root&#x27;))&#125;) Vue1、设置跨域支持1234567891011在vue.config.js中添加配置const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, devServer: &#123; headers: &#123; &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;, &#125; &#125;&#125;) 2、设置基础路由(如果基座是history路由，子应用是hash路由，这一步可以省略)12345678// main.jsimport &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;import routes from &#x27;./router&#x27;const router = createRouter(&#123; // 👇 __MICRO_APP_BASE_ROUTE__ 为micro-app传入的基础路由 history: createWebHistory(window.__MICRO_APP_BASE_ROUTE__ || process.env.BASE_URL), routes,&#125;) 3、设置publicPath步骤1: 在子应用src目录下创建名称为public-path.js的文件，并添加如下内容 12345// __MICRO_APP_ENVIRONMENT__和__MICRO_APP_PUBLIC_PATH__是由micro-app注入的全局变量if (window.__MICRO_APP_ENVIRONMENT__) &#123; // eslint-disable-next-line __webpack_public_path__ = window.__MICRO_APP_PUBLIC_PATH__&#125; 步骤2: 在子应用入口文件的最顶部引入public-path.js 12// entryimport &#x27;./public-path&#x27; 4、监听卸载123456789子应用被卸载时会接受到一个名为unmount的事件，在此可以进行卸载相关操作。// main.jsconst app = createApp(App)app.mount(&#x27;#app&#x27;)// 监听卸载操作window.addEventListener(&#x27;unmount&#x27;, function () &#123; app.unmount()&#125;) 数据通信一、子应用获取来自基座应用的数据micro-app会向子应用注入名称为microApp的全局对象，子应用通过这个对象和基座应用进行数据交互。 有两种方式获取来自基座应用的数据： 方式1：直接获取数据 1const data = window.microApp.getData() // 返回基座下发的data数据 方式2：绑定监听函数 1234567891011121314151617function dataListener (data) &#123; console.log(&#x27;来自基座应用的数据&#x27;, data)&#125;/**- 绑定监听函数，监听函数只有在数据变化时才会触发- dataListener: 绑定函数- autoTrigger: 在初次绑定监听函数时如果有缓存数据，是否需要主动触发一次，默认为false- !!!重要说明: 因为子应用是异步渲染的，而基座发送数据是同步的，- 如果在子应用渲染结束前基座应用发送数据，则在绑定监听函数前数据已经发送，在初始化后不会触发绑定函数，- 但这个数据会放入缓存中，此时可以设置autoTrigger为true主动触发一次监听函数来获取数据。 */ window.microApp.addDataListener(dataListener: Function, autoTrigger?: boolean) // 解绑监听函数 window.microApp.removeDataListener(dataListener: Function) // 清空当前子应用的所有绑定函数(全局数据函数除外) window.microApp.clearDataListener() 二、子应用向基座应用发送数据12// dispatch只接受对象作为参数window.microApp.dispatch(&#123;type: &#x27;子应用发送的数据&#x27;&#125;) 三、基座应用向子应用发送数据基座应用向子应用发送数据有两种方式： 方式1: 通过data属性发送数据Vue(Angular类似)12345678910111213141516&lt;template&gt; &lt;micro-app name=&#x27;my-app&#x27; url=&#x27;xx&#x27; :data=&#x27;dataForChild&#x27; // data只接受对象类型，数据变化时会重新发送 /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; dataForChild: &#123;type: &#x27;发送给子应用的数据&#x27;&#125; &#125; &#125;&#125;&lt;/script&gt; React在React中我们需要引入一个polyfill。 在元素所在的文件顶部添加polyfill(注释也要复制)。 123/** @jsxRuntime classic *//** @jsx jsxCustomEvent */import jsxCustomEvent from &#x27;@micro-zoe/micro-app/polyfill/jsx-custom-event&#x27; 开始使用 12345&lt;micro-app name=&#x27;my-app&#x27; url=&#x27;xx&#x27; data=&#123;this.state.dataForChild&#125; // data只接受对象类型，采用严格对比(===)，当传入新的data对象时会重新发送/&gt; 方式2: 手动发送数据手动发送数据需要通过name指定接受数据的子应用，此值和元素中的name一致。 123import microApp from &#x27;@micro-zoe/micro-app&#x27;// 发送数据给子应用 my-app，setData第二个参数只接受对象类型microApp.setData(&#x27;my-app&#x27;, &#123;type: &#x27;新的数据&#x27;&#125;) 四、基座应用获取来自子应用的数据基座应用获取来自子应用的数据有三种方式： 方式1：直接获取数据12import microApp from &#x27;@micro-zoe/micro-app&#x27;const childData = microApp.getData(appName) // 返回子应用的data数据 方式2: 监听自定义事件 (datachange)Vue(Angular同理)1234567891011121314151617&lt;template&gt; &lt;micro-app name=&#x27;my-app&#x27; url=&#x27;xx&#x27; // 数据在事件对象的detail.data字段中，子应用每次发送数据都会触发datachange @datachange=&#x27;handleDataChange&#x27; /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; handleDataChange (e) &#123; console.log(&#x27;来自子应用的数据：&#x27;, e.detail.data) &#125; &#125;&#125;&lt;/script&gt; React在React中我们需要引入一个polyfill。 在元素所在的文件顶部添加polyfill(注释也要复制)。 123/** @jsxRuntime classic *//** @jsx jsxCustomEvent */import jsxCustomEvent from &#x27;@micro-zoe/micro-app/polyfill/jsx-custom-event&#x27; 开始使用 123456&lt;micro-app name=&#x27;my-app&#x27; url=&#x27;xx&#x27; // 数据在event.detail.data字段中，子应用每次发送数据都会触发datachange onDataChange=&#123;(e) =&gt; console.log(&#x27;来自子应用的数据：&#x27;, e.detail.data)&#125;/&gt; 方式3: 绑定监听函数123456789101112131415161718绑定监听函数需要通过name指定子应用，此值和&lt;micro-app&gt;元素中的name一致。import microApp from &#x27;@micro-zoe/micro-app&#x27;function dataListener (data) &#123; console.log(&#x27;来自子应用my-app的数据&#x27;, data)&#125;/**- 绑定监听函数- appName: 应用名称- dataListener: 绑定函数- autoTrigger: 在初次绑定监听函数时如果有缓存数据，是否需要主动触发一次，默认为false */ microApp.addDataListener(appName: string, dataListener: Function, autoTrigger?: boolean) // 解绑监听my-app子应用的函数 microApp.removeDataListener(appName: string, dataListener: Function) // 清空所有监听appName子应用的函数 microApp.clearDataListener(appName: string) DEMO 依赖版本: “@micro-zoe&#x2F;micro-app”: “^0.8.10” 内部项目就不展示了 Angular主应用(预算) React子应用 Vue子应用 Angular子应用"},{"title":"2022年10月阅读列表","path":"/2022/11/01/2022年10月阅读列表/","content":"2022年10月阅读列表略读一文看懂any，never，void和unknown的区别 - 掘金科技爱好者周刊（第 222 期）：四十年编程感想 - 阮一峰的网络日志科技爱好者周刊（第 223 … 2022年10月阅读列表略读 一文看懂any，never，void和unknown的区别 - 掘金 科技爱好者周刊（第 222 期）：四十年编程感想 - 阮一峰的网络日志 科技爱好者周刊（第 223 期）：程序员需要担心裁员吗？ - 阮一峰的网络日志 从选购到使用，让 3D 打印机打开新世界的大门 - 少数派 科技爱好者周刊（第 224 期）：Figma 为什么赢了 Sketch - 阮一峰的网络日志 Why Are We Addicted To Our Phones? https://staysaasy.com/product/2022/09/16/why-figma-is-special.html Build Your Career on Dirty Work | Stay SaaSy Node CLI工具原理解析 - 掘金 【前端&amp;运维那点事儿】八：迈向Shell的第四步：算数运算与数组 - 掘金 https://blog.angular.io/modern-css-in-angular-layouts-4a259dca9127 《 关于我用拓展运算符把项目搞崩这件事 》 - 掘金 细读 面试官问我什么是浏览器层爆炸？ - 掘金 https://alumni.media.mit.edu/~cahn&#x2F;life&#x2F;gian-carlo-rota-10-lessons.html"},{"title":"如何在Angular中兼容CommonJS/AMD/UMD","path":"/2022/10/27/如何在Angular中兼容CommonJS-AMD-UMD/","content":"在导入类似 moment 这样的开发工具时,因为没有es的import导入,所以我们可能会使用 1import * as moment from &#x27;moment 不过最近发现通过此种方式开发插件库,在应用端会报找不到函数 研究后发现可以通过ts的配置来修复此问题 1234compilerOptions: &#123; &quot;esModuleInterop&quot;: true, // 兼容CommonJS/AMD/UMD (官方文档说此配置项会自动打开allowSyntheticDefaultImports) &quot;allowSyntheticDefaultImports&quot;: true, // 兼容CommonJS/AMD/UMD&#125; ES 模块互操作 - esModuleInterop"},{"title":"2022年9月阅读清单","path":"/2022/09/30/2022年9月阅读清单/","content":"2022年9月阅读清单收获Promise永久Pending状态造成内存泄漏 - 掘金💯💯💯 原来 Base64 如此简单！！！ - 掘金硬核基础编码篇（一）烫烫烫烫烫烫 - 掘金淦，为什么 &amp;q… 2022年9月阅读清单收获 Promise永久Pending状态造成内存泄漏 - 掘金 💯💯💯 原来 Base64 如此简单！！！ - 掘金 硬核基础编码篇（一）烫烫烫烫烫烫 - 掘金 淦，为什么 “𠮷𠮷𠮷”.length !&#x3D;&#x3D; 3 - 掘金 TS 类型体操还能这么玩，太秀了！ - 掘金 git为什么文件换名后会丢失跟踪记录？ - 知乎 https:&#x2F;&#x2F;medium.com&#x2F;@alet.aurelien&#x2F;hexagonal-architecture-with-angular-7e4d070155ea 闲谈 ResizeObserver Api监听DOM尺寸变化 - 掘金 https://sergeygultyayev.medium.com/sass-variables-vs-css-custom-properties-c0adc01c0624 科技爱好者周刊（第 221 期）：全世界最繁荣的行业 - 阮一峰的网络日志 利用console提高写bug的效率 - 掘金 What is the Event Loop in JavaScript? - 30 seconds of code 为什么B站的弹幕可以不挡人物 - 掘金 非大厂的我们，要如何去搞前端基建？ - 掘金 CHALK - 美化 node 输出的神器 - 掘金 前端实现docx、pdf格式文件在线预览 - 掘金 不会时间管理、手摸手带你开发一个提效工具！！！ - 掘金 扯淡 你会用RxJS吗？【细说 RxJS中的 Operators】 - 掘金 你会用RxJS吗？【初识 RxJS中的Observable和Observer】 - 掘金 2022年国内外前端发展态势 - 掘金 硬核基础二进制篇（二）位运算 - 掘金 Electron的用武之地 - 掘金"},{"title":"2022年8月阅读清单","path":"/2022/09/01/2022年8月阅读清单/","content":"2022年8月阅读清单收获淘系前端团队DNS 查询原理详解 - 阮一峰的网络日志异或运算 XOR 教程 - 阮一峰的网络日志How SHA-256 Works Step-by-Step | Bo… 2022年8月阅读清单收获 淘系前端团队 DNS 查询原理详解 - 阮一峰的网络日志 异或运算 XOR 教程 - 阮一峰的网络日志 How SHA-256 Works Step-by-Step | Boot.dev The Front-End Developer’s Guide to the Terminal https://lambdaisland.com/blog/2022-02-17-the-fg-command Angular 2 Decorators(装饰器) - part 1 · Issue #9 · semlinker&#x2F;angular2-ionic2 · GitHub 雷军2022年度最新演讲：熬过绝望低谷，你便无人能敌_盘古_金山_公司 Thread by @coolXiao on Thread Reader App – Thread Reader App 数据流是否需要在ngOnInit中初始化 How to Be a Senior Leader | Stay SaaSy Management Scrutiny | Stay SaaSy ::ng-deep 的替代方法之css变量 如何说出坏消息 Small Performance Cues | Stay SaaSy npm 如何处理依赖与依赖冲突 · 语雀 闲谈 Understanding Volta | Volta https://medium.com/generic-ui/the-new-way-of-subscribing-in-an-angular-component-f74ef79a8ffc https://sergeygultyayev.medium.com/how-to-make-angular-applications-more-robust-855deec98fbc https://javascript.plainenglish.io/angular-interceptors-a-complete-guide-7294e2317ecf 科技爱好者周刊（第 212 期）：人生不短 - 阮一峰的网络日志 The Most Important Performance Management Rule For Software Engineers | Stay SaaSy Be less technical https://www.1024nav.com/front-news/rush-is-furture Browser in the Dark: flashlights with CSS and canvas https://gitexplorer.com/ 2022-30: 如何维护一个开源项目 科技爱好者周刊（第 218 期）：葡萄酒，樱花，全球变暖 - 阮一峰的网络日志 Ways to Expand Your SaaS Business | Stay SaaSy 设计更好的 Angular 组件 徐辛承：快手增长团队的前端工程化思考 JavaScript Source Map 详解 - 阮一峰的网络日志 A closer look at SharedModule| Chau Tran 你不知道的 import type toLocaleString 也太好用了吧！ - 掘金 面试官：说说哪些浏览器事件不会冒泡 - 掘金 扯淡 浅谈：为啥vue和react都选择了Hooks🏂？ - 掘金 字节序探析：大端与小端的比较 - 阮一峰的网络日志 容错，高可用和灾备 - 阮一峰的网络日志 Debugging My Work Health | Stay SaaSy I was wrong. CRDTs are the future RxAngular State, The Component Reactive Store | Marmicode Tasting Session #1 - YouTube 改善角度初始加载时间 科技爱好者周刊（第 219 期）：如何防止帐号被黑 - 阮一峰的网络日志 ReScript 与 TypeScript，谁是前端圈的“当红辣子鸡” - 掘金 网易严选多端组件库OSSA正式开源 - 掘金 TypeScript Monorepo 最佳实践 - 掘金"},{"title":"创建前端PNPM自定义Docker镜像并上传至服务器使用","path":"/2022/08/18/创建前端PNPM自定义Docker镜像并上传至服务器使用/","content":"本地创建node镜像并提前安装pnpm环境背景因为需要在项目中使用pnpm包管理工具，并且通过only-allow强制使用pnpm 引出 ci 也需要使用 pnpm 但是介于网络问题，安装一直错误，并且因为安全问题，也不能使服务器连接外网。 解决方案在一台网络正常的机器上构建一个已经预装好pnpm的docker镜像，并上传到服务器，使用本地镜像来解决问题 环境要求 docker 网络正常 步骤构建自定义镜像本地新建目录来进行如下操作 12345# 基于基础的node镜像FROM node:16.13.2RUN curl -f https://get.pnpm.io/v6.16.js | node - add --global pnpm@7 \\ &amp;&amp; pnpm config set store-dir ~/.pnpm-store 开始构建 1docker build -t name:tag . 验证 123456$ docker run -itd --name test node16:pnpm$ docker ps // 获取id$ docker exec -it id /bin/bash// node -v &amp;&amp; pnpm -v work! 开始创建镜像文件 1$ docker save -o exampleName.tar name:tag 传输至服务器 1$ scp exampleName.tar root@hostname:/data 服务器导入镜像 1$ docker load &lt; exampleName.tar 查看 1$ docker images 可能需要重命名 $ $docker tag IMAGEID(镜像id) REPOSITORY:TAG(仓库：标签) 删除 $ $docker rmi IMAGEID 或者 docker rmi REPOSITORY:TAG"},{"title":"CI 中 Cypress 下载超时处理方案","path":"/2022/08/18/CI-中-Cypress-下载超时处理方案/","content":"前言在项目中我们依赖了cypress，在跑ci&#x2F;cd时，时常遇到超时错误。 最终定位问题，我们发现时这个cypress插件会自己下载二进制版本，或者直接超时。 排查错误毫无疑问，我们一开始就定位到了网络问题。并且也通过日志定位了到了这个问题 1234567891011121314151617181920212223242526272829.../cypress@9.7.0/node_modules/cypress postinstall$ node index.js --exec install.../cypress@9.7.0/node_modules/cypress postinstall: Installing Cypress (version: 9.7.0).../cypress@9.7.0/node_modules/cypress postinstall: [STARTED] Task without title..../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] The Cypress App could not be downloaded..../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] .../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] Does your workplace require a proxy to be used to access the Internet? If so, you must configure the HTTP_PROXY environment variable before downloading Cypress. Read more: https://on.cypress.io/proxy-configuration.../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] .../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] Otherwise, please check network connectivity and try again:.../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] .../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] ----------.../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] .../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] URL: https://download.cypress.io/desktop/9.7.0?platform=linux&amp;arch=x64.../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] Error: read ETIMEDOUT.../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] .../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] ----------.../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] .../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] Platform: linux-x64 (Debian - 10.11).../cypress@9.7.0/node_modules/cypress postinstall: [FAILED] Cypress Version: 9.7.0.../cypress@9.7.0/node_modules/cypress postinstall: The Cypress App could not be downloaded..../cypress@9.7.0/node_modules/cypress postinstall: Does your workplace require a proxy to be used to access the Internet? If so, you must configure the HTTP_PROXY environment variable before downloading Cypress. Read more: https://on.cypress.io/proxy-configuration.../cypress@9.7.0/node_modules/cypress postinstall: Otherwise, please check network connectivity and try again:.../cypress@9.7.0/node_modules/cypress postinstall: ----------.../cypress@9.7.0/node_modules/cypress postinstall: URL: https://download.cypress.io/desktop/9.7.0?platform=linux&amp;arch=x64.../cypress@9.7.0/node_modules/cypress postinstall: Error: read ETIMEDOUT.../cypress@9.7.0/node_modules/cypress postinstall: ----------.../cypress@9.7.0/node_modules/cypress postinstall: Platform: linux-x64 (Debian - 10.11).../cypress@9.7.0/node_modules/cypress postinstall: Cypress Version: 9.7.0.../cypress@9.7.0/node_modules/cypress postinstall: Failed ELIFECYCLE Command failed with exit code 1. 当然，比较简单的办法就是给服务器开通网络代理，不过，出于安全问题，不允采用。 通过查看cypress的官方文档，也得知了几种方案 跳过安装 缓存 CDN 镜像 社区论坛上反馈 cypress 的版本检查程序有问题，可以通过固定版本号来绕开一部分超时错误 当然比较实在的就是跳过和缓存，缓存的话，可以参考我的其他文章如何提供pnpm镜像环境[post cid&#x3D;”690” &#x2F;] 跳过安装比较实在，因为我们已经安装了node版本的cypress不再需要安装二进制版本了 妙手方案敲定，直接修改ci文件 12variables: CYPRESS_INSTALL_BINARY: 0 遗留问题安装一些依赖的时候依旧很吃网络环境。公司内部也通过verdaccio部署了自己的注册表，并且天然的提供缓存服务。所以乘着这次修改，直接一起转移过去吧。"},{"title":"2022年7月阅读清单","path":"/2022/08/11/2022年7月阅读清单/","content":"2022年7月阅读清单收获 如何移除你项目中99%的JS代码 - 掘金 解决跨域的几种方法 - 掘金 https://javascript.plainenglish.io/angular-route-parameters-a-simple-guide-88c69d54102c 小程序不让用 JS 解释器？那我再肛一次鹅厂 - 掘金 11+ chrome高级调试技巧，学会效率直接提升666% - 掘金 weekly&#x2F;191.精读《高性能表格》.md at master · ascoders&#x2F;weekly · GitHub https://www.telerik.com/blogs/angular-on-desktop https://www.telerik.com/blogs/how-to-desktop-2022 闲谈 如果能重来，你要选 Vite 还是 Webpack ？ - 掘金 无虚拟 DOM 版 Vue 即将到来 - 掘金 花十分钟，迅速了解ES13的全部特性 - 掘金 如何实现字体小于 12px 以及边框 0.5 px？ - 掘金 前端新宠 Svelte 带来哪些新思想？赶紧学起来！ - 掘金 扯淡 谈谈干前端三年的几点感受 - 掘金 雷军做程序员时写的博客，太牛了。。 - 掘金 前端必备知识之Nginx - 掘金 API 请求慢？这次锅真不在后端 - 掘金 高级前端必须掌握的package.json字段知识 - 掘金 前端开发者的登天梯 - babel - 掘金 JavaScript写一个 once 函数，让传入函数只执行一次 - 掘金 33个非常实用的JavaScript一行代码，建议收藏！ - 掘金"},{"title":"storybook 编写指南","path":"/2022/08/11/storybook-编写指南/","content":"storybook 编写指南 所有story相关的导入导出以及文件名称，官方推荐首字母大写 storybook 指南 argTypes 参数详情 overview 举个 🌰 e.g. 控件参数详解 再举个 🌰 e.g. 不想&#x2F;想全部给你看 👀 code source 部分 描述部分 我想写独立的文档 argTypes 参数详情 overview 字段 说明 name 同字段名,可省略 type.required boolean description 描述 defaultValue 数据:默认值 table.disable 不在文档中出现 table.category 分类分组名称 table.type.summary 类型的简单描述 table.type.detail 类型的长描述 table.defaultValue.summary 显示:默认值 table.defaultValue.detail 显示:默认值详细说明 control 禁用控制器 e.g false control.type 控件类型(需要有[数据]默认值) e.g. null \\ options 控件类型为 radio 时的值数组 举个 🌰 e.g.1234567891011121314151617181920Primary.argTypes = &#123; fNotFoundImage: &#123; name: &#x27;fNotFoundImage&#x27;, type: &#123; required: false, &#125;, table: &#123; disable: true, defaultValue: &#123; summary: &#x27;null&#x27;, &#125;, type: &#123; summary: &#x27;string | TemplateRef&lt;void&gt;&#x27; &#125; &#125;, description: &#x27;图片url&#x27;, defaultValue: null, options: [null, &#x27;https://www.sass.hk/images/sass.png&#x27;], control: &#123; type: &#x27;radio&#x27; &#125;, // 可简写成 =&gt; control: &#x27;radio&#x27; &#125;&#125;; 控件参数详解 data type 数据类型 control type 控件类型 description 描述 options 选项 array array serialize array into a comma-separated string inside a textbox separator boolean boolean checkbox input - number number a numberic text box input min, max, step - range a range slider input min, max, step object object json editor text input - enum radio radio buttons input options - inline-radio inline radio buttons input options - check multi-select checkbox input options - inline-check multi-select inline checkbox input options - select select dropdown input options - multi-select multi-select dropdown input options string text simple text input - - color color picker input that assumes strings are color values - - date date picker input - 再举个 🌰 e.g.123456789101112export default &#123; title: &#x27;Gizmo&#x27;, component: Gizmo, argTypes: &#123; width: &#123; type: &#x27;range&#x27;, min: 400, max: 1200, step: 50 &#125;; &#125;,&#125;; 不想&#x2F;想全部给你看 👀有些内容很隐私&#x2F;重要，你就是不想&#x2F;需要给调用的人看到。 那么你可以使用 include 和 exclude 配置 controls, 可以写数字串数组或正则表达式 举个 🌰 e.g. 123456789101112131415161718192021222324252627282930313233343536373839import &#123; YourComponent &#125; from &#x27;./YourComponent&#x27;; export default &#123; title: &#x27;YourComponent&#x27;, component: YourComponent,&#125;;const Template = (args) =&gt; (&#123; //👇 Your template goes here&#125;);ArrayInclude = Template.bind(&#123;&#125;)ArrayInclude.parameters = &#123; controls: &#123; include: [&#x27;foo&#x27;, &#x27;bar&#x27;] &#125;&#125;;RegexInclude = Template.bind(&#123;&#125;)RegexInclude.parameters = &#123; controls: &#123; include: /^hello*/ &#125;&#125;;ArrayExclude = Template.bind(&#123;&#125;)ArrayExclude.parameters = &#123; controls: &#123; exclude: [&#x27;foo&#x27;, &#x27;bar&#x27;] &#125;&#125;; RegexExclude = Template.bind(&#123;&#125;)RegexExclude.parameters = &#123; controls: &#123; exclude: /^hello*/ &#125;&#125;; 当然比较本的办法隐藏起来就是在 ts 文件中追加注释 @ignore code source 部分有时候自动带出 code source 并不足以满足我们的要求，需要我们自定义这个时候就可以使用 docs.source.code 和可选参数 docs.source.language 123456789101112131415161718192021222324// Button.stories.js|jsx|ts|tsx import &#123; Button &#125; from &#x27;./Button&#x27;; export default &#123; /* 👇 The title prop is optional. * See https://storybook.js.org/docs/react/configure/overview#configure-story-loading * to learn how to generate automatic titles */ title: &#x27;Button&#x27;, component: Button,&#125;; export const Template = (args) =&gt; (&#123; //👇 Your template goes here&#125;); export const CustomSource = Template.bind(&#123;&#125;); CustomSource.parameters = &#123; docs: &#123; language: &#x27;ts&#x27;, // 高亮语言 format: true, // 格式化 source: &#123; code: &#x27;Some custom string here&#x27;, &#125;, &#125;,&#125;; 描述部分 Storybook 提取组件的描述并将其呈现在页面顶部。它是从 docgen 组件自动生成的支持的框架基于组件的源代码。下面是一个精简的例子和可用的选项。 12345678910111213141516171819202122232425262728293031// Button.stories.js|jsx|ts|tsx import &#123; Button &#125; from &#x27;./Button&#x27;; export default &#123; /* 👇 The title prop is optional. * See https://storybook.js.org/docs/react/configure/overview#configure-story-loading * to learn how to generate automatic titles */ title: &#x27;Button&#x27;, component: Button, parameters: &#123; docs: &#123; description: &#123; component: &#x27;Some component _markdown_&#x27;, &#125;, &#125;, &#125;,&#125;; const Template = (args) =&gt; (&#123; //👇 Your template goes here&#125;); export const WithStoryDescription = Template.bind(&#123;&#125;);WithStoryDescription.parameters = &#123; docs: &#123; description: &#123; story: &#x27;Some story **markdown**&#x27;, &#125;, &#125;,&#125;; 选项 描述 component 覆盖默认组件描述。description: { component:’An example component description’ } story 覆盖故事描述。 description: { story: ‘An example story description’ } 我想写独立的文档 有的同学想写和本文档同级别的内容 在项目中你觉得适合的任意位置创建一个 MyComponent.stories.mdx 文件的内容 名称MyComponent自行修改 123456789&lt;!-- MyComponent.stories.mdx --&gt; import &#123; Meta &#125; from &#x27;@storybook/addon-docs&#x27;; # Some header And Markdown here &lt;Meta title=&quot;Docs/MyComponent&quot;/&gt;"},{"title":"Angular中库与应用共享服务遇到的问题以及解决方案","path":"/2022/07/08/Angular中库与应用共享服务遇到的问题以及解决方案/","content":"Angular中库与应用共享服务遇到的问题以及解决方案背景随着项目的功能越来越多，我们计划抽离一些基础服务作为单一的库来整理优化项目结构，并且可以方便后期新开应用时更加方便的开发。 问题服务中涉及到国际化，我们想要的程度是： 能够一键切换语种 能够所有抽离的服务共享一个服务来设置国际化 用户使用时尽可能的不需要自己设置，或者只需要设置一次 方案方案一使用拓展fone-ui的翻译服务，但是舍弃了，不能一键，并且如果使用了此种方案，必须强制依赖fone-ui，这是我不能接受的。 方案二应用中常用的国际化方案是ngx-translate,并且通过查看文档，也是支持拓展的，支持一键切换（应用天然使用此库） demo核心库代码 1234567891011121314import &#123; Injectable, &#125; from &#x27;@angular/core&#x27;;import &#123; TranslateService &#125; from &#x27;@ngx-translate/core&#x27;;import zh_CN from &#x27;./zh-CN&#x27;;import en_US from &#x27;./en-US&#x27;;@Injectable(&#123; providedIn: &#x27;root&#x27;,&#125;)export class TestService &#123; constructor(private translate: TranslateService) &#123; this.translate.setTranslation(&#x27;zh-CN&#x27;, zh_CN, true); this.translate.setTranslation(&#x27;en-US&#x27;, en_US, true); &#125;&#125; 构建之后npm link 应用核心代码AppComponent 12345678910111213141516171819202122import &#123; Component &#125; from &#x27;@angular/core&#x27;;import &#123; TranslateService &#125; from &#x27;@ngx-translate/core&#x27;;const zh_CN = &#123; lindo: &#x27;lindo11111&#x27;,&#125;;const en_US = &#123; lindo: &#x27;lindo2222&#x27;,&#125;;@Component(&#123; selector: &#x27;my-test-app-root&#x27;, templateUrl: &#x27;./app.component.html&#x27;, styleUrls: [&#x27;./app.component.scss&#x27;],&#125;)export class AppComponent &#123; title = &#x27;test&#x27;; constructor(private translate: TranslateService) &#123; this.translate.setTranslation(&#x27;zh-CN&#x27;, zh_CN); this.translate.setTranslation(&#x27;en-US&#x27;, en_US); &#125;&#125; SubComponentComponent 1234567891011121314import &#123; Component, OnInit &#125; from &#x27;@angular/core&#x27;;import &#123; TranslateService &#125; from &#x27;@ngx-translate/core&#x27;;import &#123; TestService &#125; from &#x27;@caoxicheng/test&#x27;;@Component(&#123; selector: &#x27;my-test-app-sub-component&#x27;, templateUrl: &#x27;./sub-component.component.html&#x27;, styleUrls: [&#x27;./sub-component.component.scss&#x27;],&#125;)export class SubComponentComponent implements OnInit &#123; constructor(private translate: TranslateService, private test: TestService) &#123;&#125; ngOnInit(): void &#123;&#125;&#125; 项目启动之后直接错误 image.png 也去官方查看这个问题的描述 https://angular.cn/errors/NG0203 通过正常的办法没办法正常的注入依赖 也尝试过绕过去的办法，比如说 image.png 或者使用forwardRef关键字，均无效 曙光在查看官方的依赖提供者一章时看到了这段文字 要想根据运行前尚不可用的信息创建可变的依赖值，可以使用工厂提供者。 感觉可行，无非就是绕呗 修改后代码(SubComponentModule) 12345678910111213141516171819import &#123; NgModule &#125; from &#x27;@angular/core&#x27;;import &#123; CommonModule &#125; from &#x27;@angular/common&#x27;;import &#123; SubComponentComponent &#125; from &#x27;./sub-component.component&#x27;;import &#123; TranslateService &#125; from &#x27;@ngx-translate/core&#x27;;import &#123; TestService &#125; from &#x27;@lindo/test&#x27;;@NgModule(&#123; declarations: [SubComponentComponent], imports: [CommonModule], exports: [SubComponentComponent], providers: [ &#123; provide: TestService, useFactory: (translate: TranslateService) =&gt; new TestService(translate), deps: [TranslateService], &#125;, ],&#125;)export class SubComponentModule &#123;&#125; 遗留问题对于用户而言在注入的地方需要手动提供工厂函数，这一点也不优雅这是不能接受的。 所以说是否可以优化这个问题？"},{"title":"2022年6月阅读清单","path":"/2022/07/08/2022年6月阅读清单/","content":"2022年6月阅读清单收获 https://juejin.cn/post/7103905846337224711 浅聊偏函数 - 掘金 你还在直接用 localStorage 么？该提升下逼格了 - 掘金 Monorepo 原理浅探 - 掘金 https://mp.weixin.qq.com/s/qtIu-NHml_8wT3APDyuzXg Create a static file server with Node.js - 30 seconds of code 在uni-app中使用微软的文字转语音服务 - 掘金 图片优化不完全指北 - 掘金 如何快速在团队内做一次技术分享？ - 掘金 给女友写的，每日自动推送暖心消息 - 掘金 前端web实现（@、At、艾特）选人或引用数据 - 掘金 现代 CSS 解决方案：CSS 数学函数 前端监控的搭建步骤，别再一头雾水了！ 基于设计稿识别的可视化低代码系统实践 css伪类函数 :is() 和 :where() - 掘金 落地qiankun的诸多问题—-父子应用样式污染 - 掘金 为什么模块循环依赖不会导致死循环？CommonJS和ES Module的解决办法有什么不同？ - 掘金 My Wonderful HTML Email Workflow, using MJML and MDX for responsive emails GitHub - alivebao&#x2F;clean-code-js: JavaScript风格指南 闲谈Kafka到底有多高可靠？（RNG NB） - 掘金 冴羽答读者问：如果有机会，你会选择脱产学习深造吗？ - 掘金 JavaScript设计模式-适配器模式（11） - 掘金 oh-my-zsh让你的终端体验起飞！ - 掘金 为什么程序员应该有一台Mac个人电脑 - 掘金 Angular 项目里使用 scss 文件的一些技巧 - 掘金 取代前端er？PyScript到底是何方神圣！ - 掘金 我本地明明是好的啊？前端怎么本地复现线上问题？ - 掘金 🦊【通用体系】你司暴露的上传接口被黑产用来上传小视频？做一套安全的上传体系来防范吧！🦄️ - 掘金 好用不卡，这些插件和配置让你的 Webstorm 更牛逼！ - 掘金 line-height用了这么久，你真的了解他么 - 掘金 扯淡【架构师（第三十二篇）】 通用上传组件开发及测试用例 - 掘金 技术团队为什么要坚持开展技术分享会以及落地实施 - 掘金 前方高能！一个前端程序员的 README 能写到多好看 - 掘金 TypeScript查漏补缺(基础类型) - 掘金 【一库】妙啊！👺这个库组织npm脚本简直爆炸！ - 掘金"},{"title":"Error: Cannot call a namespace (moment) 的处理方案","path":"/2022/06/07/Error-Cannot-call-a-namespace-moment-的处理方案/","content":"提供一种曲线救国的思路 123import * as moment_ from &#x27;moment&#x27;;const moment = moment_;// 曲线救国 酌情修改下面参数 allowSyntheticDefaultImports skipLibCheck 参考 [scode type&#x3D;”share” size&#x3D;””]https://stackoverflow.com/questions/59735280/angular-8-moment-error-cannot-call-a-namespace-moment[/scode]"},{"title":"2022年5月阅读清单","path":"/2022/05/30/2022年5月阅读清单/","content":"2022年5月阅读清单收获 can x!&#x3D;&#x3D;x ? 你可能不知道的 Chrome Devtools 实用功能 - 掘金 如何根据后端返回的url下载json文件 - 掘金 type 和 interface 傻傻分不清楚？ - 掘金 https://mp.weixin.qq.com/s/UobubFEiukXrCmQu7OZIgQ The Surprising Truth About Pixels and Accessibility: should I use pixels or rems? Angular Community Meetup | May 2022 | Mini Bhati, Jeffry Houser, &amp; Colum Ferry - YouTube CSS 变量自动变色技术 - 掘金 闲谈 Taming Code Organization with Module Boundaries in Nx - YouTube 【第三十七期】2022-05-15 · Issue #39 · Geekhyt&#x2F;weekly · GitHub 扯淡"},{"title":"git提交时自动检测信息是否合法·中文指南","path":"/2022/03/10/git提交时自动检测信息是否合法·中文指南/","content":"安装1.依赖 1npm install --save-dev @commitlint/config-conventional @commitlint/cli husky 2.配置文件 在工程根目录下新建配置文件，名称为 commitlint.config.js。 当然也能直接一行命令 1echo &quot;module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125;&quot; &gt; commitlint.config.js commitlint.config.js 中添加配置信息 1module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125; 然后使用命令创建拦截脚本(可能会出错，建议检查一下内容) 1npx husky add .husky/commit-msg &quot;npx --no -- commitlint --edit $1&quot; 你会发现在.husky文件夹内出现一个commit-msg文件，里面内容是npx --no -- commitlint --edit &quot;$1&quot; 至此结束！ 小说明：如果某次提交想禁用 husky，可以添加参数 –no-verify 。git commit --no-verify -m &quot;xxx&quot;"},{"title":"2022年3月阅读清单","path":"/2022/03/03/2022年3月阅读清单/","content":"精读收获 互联网上如何快速找到资源 - 掘金 👨‍💻‍程序员如何提高工作效率+程序员健康指南👨‍💻‍ - 掘金 【敏捷5.1】规划的核心：用户故事 - 掘金 在使用地理定位API时，你需要知道什么？ - 掘金 npm发布包教程（一）：从npm说起 npm发布包教程（二）：发布包 npm发布包教程（三）：安装和加载原理 剖析npm的包管理机制（完整版） | ConardLi的blog 一篇文章教你搭建一个前后端分离（gitlab-cicd+docker+vue+django）的自动化部署的网站，干货满满！ - 掘金 GitLab CI&#x2F;CD+Gitlab-runner+docker的介绍与踩坑 - 掘金 https://zhuanlan.zhihu.com/p/184936276 你不知道的JavaScript中的5个JSON秘密功能 - 掘金 从 Google 离职了！ - 掘金 https://segmentfault.com/a/1190000018714929 webpack构建速度和体积优化策略 - 掘金 闲谈 我提交了一个 pr，竟然是为了吃 - 掘金 不要把政治带进开源项目 - 掘金 快24岁了，没什么目标（不才的21年年终总结） - 掘金 从头梳理，看看中国的 ICP 备案制度 - 掘金 程序员迁坟指南【西安 -&gt;上海之行实录】 - 掘金 产品线 - MBA智库百科 展望 分享几个你可能不知道的交互式Git命令 - 掘金 CPU调度算法 - 掘金 同事提出个我从未想过的问题，为什么Kubernetes要&amp;#34;多此一举&amp;#34;推出静态Pod概念？ - 掘金 计算机网络–物理层 - 掘金 https://jotadeveloper.medium.com/five-use-cases-where-a-npm-private-proxy-fits-in-your-workflow-632a81779c14 一次代码审计实战案例【思路流程】 - 掘金 https://mp.weixin.qq.com/s/6QJvzDroVPAy6KXd2hhvCw 「前端CI&#x2F;CD系列」第三篇：如何用建木CI构建前端项目并部署到CDN - 掘金 GitLab CI&#x2F;CD - 废物大师兄 - 博客园 TypeScript 官方：JavaScript 中直接支持类型！ - 掘金 GitHub - giltayar&#x2F;proposal-types-as-comments: ECMAScript proposal for type syntax that is erased - Stage 0 关于core-js的分包设计 - 掘金"},{"title":"如何编写好的提交信息","path":"/2022/02/25/如何编写好的提交信息/","content":"如何编写好的提交信息简介本文用来介绍在组件库开发的过程中，如何提交一个符合语法规则、团队约定和具有高可行性的提交信息。 接下来的操作默认读者使用 git 作为代码仓库。 快速上手12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt;// 空一行&lt;footer&gt; 进阶篇其中，Header是必需的，Body和Footer可以省略。 不管是哪一个部分，任何一行都不得超过72个字符。这是为了避免自动换行影响美观。 HeaderHeader部分只有一行，包括三个字段： type （必需）、scope（可选）、subject（必需） 1） type type 用于说明 commit 的类型，只允许使用下面的标识 feat：新功能 fix：修复一个错误 style：与样式相关的功能和更新 refactor：重构代码 test：与测试相关的一切提交 docs：与文档相关的一切提交 chore：不包含生产代码变动的定期代码维护 perf:：与性能优化相关的 build：与构建相关 ci：持续集成相关的一切提交 revert：回退代码（一般由程序自动带出） 如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test、perf、build、ci、revert）在我们项目中不会放入 Change Log 中 2）scope scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 3） subject subject是 commit 目的的简短描述，不超过50个字符。 主题和内容以一个空行分隔 主题行结束不用标点 主题行使用祈使语气 仅使用必要的标点符号 BodyBody 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。 1234567More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent 有3个注意点。 （1）使用第一人称现在时，比如使用change而不是changed或changes。 （2）应该说明代码变动的动机，以及与以前行为的对比。 （3）应该默认你的读者不了解问题的初衷。 FooterFooter 部分提供相关文章和其它资源的链接和第三方工具的关键字 注意点 内容每行72个字 永远不要认为大家都知道或理解最初的问题是什么，尽可能添加他的描述 确保你的代码新人也能快速理解 遵循团队的提交约定 参阅 Commit message 和 Change log 编写指南 - 阮一峰的网络日志 GitHub - conventional-changelog&#x2F;commitlint: 📓 Lint commit messages How to Write a Git Commit Message"},{"title":"「SEMVER」语义版本规范","path":"/2022/02/16/「SEMVER」语义版本规范/","content":"[SEMVER]语义版本规范semver&#x2F;semver.org提出一个语义版本规范，用于规范版本的生成和设置 英文版：Semantic Versioning 2.0.0 中文版：语义化版本 2.0.0 优势 标识当前应用版本信息 管理代码仓库 管理外部依赖 版本格式版本号命名如下: 英文版MAJOR.MINOR.PATCH 中文版主版本号.次版本号.修订号 版本号递增规则： 主版本号(MAJOR version)：出现不兼容的API变化 次版本号(MINOR version)：新增向后兼容的功能 修订号(补丁版本号，PATCH version)：修复向后兼容的bug 规范 使用语义版本控制的软件必须(MUST)声明公共API。API可以在代码本身中声明，或者严格存在于文档中。不管怎样，它都应该是精确和全面的 正常版本号必须(MUST)采用X.Y.Z格式，其中X、Y和Z是非负整数，并且必须不(MUST NOT)包含前导零。X是主版本，Y是次版本，Z是补丁版本。每个元素必须(MUST)以数字形式增加。例如：1.9.0 -&gt; 1.10.0 -&gt; 1.11.0 一旦发布了版本化的包，就不能再(MUST NOT)修改该版本的内容。任何修改都必须作为新版本重新发布 主版本号为0(0.y.z)表示初始开发阶段，可以执行任意的修改。这个阶段的公共API不应该(SHOULD NOT)被视为稳定版。 从版本1.0.0定义的公共API开始，之后版本号的递增方式依赖于此公共API的更改方式 只要有向后兼容的bug被修复，就必须(MUST)递增补丁版本号Z(x.y.Z | x&gt;0)。错误修复被定义为修复错误行为的内部更改 只要有向后兼容的功能被引入公共API，就必须(MUST)递增次版本号Y(x.Y.z | x&gt;0)。只要有任何公共API被标记为舍弃(deprecated)，就必须(MUST)递增次版本号。如果在私有代码中引入了大量新功能或改进，其中可以(MAY)包括补丁级别的改变，那么可以(MAY)递增次版本号。当次版本号递增时必须(MUST)设置补丁版本号为0 只要有不向后兼容的改变被引入公共API，就必须(MUST)递增主版本号X(X.y.z | x&gt;0)，其中可以(MAY)包括次版本和补丁级别的修改。当主版本号递增时，必须(MUST)设置次版本号和补丁版本号为0 预发布版本可以(MAY)通过在补丁版本之后附加连字符(-)和一系列点(.)分隔的标识符来表示。标识符必须(MUST)只包含ASCII字母数字和连字符[0-9a-za-z-]。标识符必须不(MUST NOT)为空。数字标识符必须不(MUST NOT)包含前导0。预发布版本的优先级低于相关的正常版本。预发布版本表示该版本尚不稳定，可能不满足与其关联的正常版本预期的兼容性要求。比如，1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92 构建元数据可以(MAY)通过在补丁或预发布版本之后立即附加一个加号和一系列点分隔的标识符来表示。标识符必须(MUST)只包含ASCII字母数字和连字符[0-9a-za-z-]。标识符必须不(MUST NOT)为空。在确定版本优先级时应该(SHOULD)忽略构建元数据。因此如果有两个版本仅在构建元数据上有区别，那么这两个版本优先级相同。比如，1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85 优先级是指在排序时版本之间如何进行比较。必须(MUST)按顺序将版本分离为主、次、补丁和预发布标识符来计算优先级（构建元数据不包含在优先级中）。当从左到右比较每个标识符时，优先级由第一个差异决定，如下所示：主、次和补丁版本总是用数字进行比较。比如，1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主、次和补丁的大小相同时，预编译版本的优先级低于正常版本。比如，1.0.0-alpha &lt; 1.0.0。具有相同主版本、次版本和补丁版本的两个预发布版本的优先级必须(MUST)通过从左到右比较每个点分隔的标识符来确定，直到发现以下差异：仅由数字组成的标识符用数字进行比较，带字母或连字符的标识符按ASCII排序顺序在词法上进行比较。数字标识符总是优先级低于非数字标识符。如果前面的所有标识符都相同，则拥有更长字段集的预发布版本的优先级高于较小字段集的预发布版本。比如，1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0 FAQ问：应该如何处理0.y.z初始开发阶段的修订？ 最简单的方式是初始开发版本从0.1.0开始，然后在每一个后续的阶段递增次版本号 问：什么时候发布1.0.0版本？ 下列情况可用于发布1.0.0版本 软件已经在生产中使用 已经有用户依赖于稳定的API 开发过程中非常担心向后兼容性 问：是否语义化规范不鼓励快速开发和快速迭代？ 主版本为0的初始开发阶段就是用于快速开发的。如果每天都在改变API，那么软件应该仍旧停留在0.y.z阶段或者在一个单独的开发分支上处理下一个主版本 问：是否对公共API小小的不兼容修改都要递增主版本，那这样的话很快就能达到42.0.0？ 这就要考验你的开发经验和开发远见。不应将不兼容的更改轻易地引入具有大量依赖代码的软件中，升级所需的成本可能很高。必须推出主版本以发布不兼容的更改意味着你已经考虑了更改的影响，并评估所涉及的成本&#x2F;效益比 问：为全部公共API生成文档需要做太多的工作了！ 为了其他人的使用而去文档化软件，这是作为职业开发者的责任。管理软件复杂性是保持项目高效的一个非常重要的部分，如果没有人知道如何使用您的软件，或者可以安全地调用哪些方法，这很难做到。从长远来看，语义版本控制以及对定义良好的公共API的坚持可以使每个人都能顺利运行 问：如果不小心在次版本发布了一个不兼容改变该怎么办？ 一旦意识到已经破坏了语义化版本规范，修复问题并发布一个新的次要版本，以纠正问题并恢复向后兼容性。即使在这种情况下，修改已发行的版本也是不可接受的。如果合适，记录违规版本并告知用户该问题，以便他们了解有问题的版本。 问：如果我更新了依赖，但是没有改变公共API，应该怎么做？ 这种方式是兼容的，因为它没有影响公共API。明确依赖于你的包的软件应该有它们自己的依赖规范，作者也会注意到任何冲突。决定是否这个修改是补丁级别还是次版本级别依赖于你更新你的依赖是为了修复bug还是添加新功能。我通常期待额外的代码是为了后一种，这种情况下明显是一个次版本级别递增 问：如果我不小心修改了公共API，但是不兼容于版本号的改变（比如在补丁版本中错误的引入了主版本级别的不兼容修改）？ 运用你最好的判断。如果有大量的用户会因为这个公共API的返回而受到影响，那么最好的策略是执行一次主版本发布，即使这次修复严格上被视为是补丁发布。记住，语义版本化就是通过版本号的变化来传达意义。如果这些更改对您的用户很重要，请使用版本号通知他们 问：应该如何处理待舍弃的功能? 舍弃已存在的功能是软件开发的常规动作，也是为了进一步发展所必须的。当你舍弃部分公共API，应该做两件事情：（1）更新文档让用户知道这次改变，（2）发布一个新的次版本，仍旧包含这个舍弃功能。在新的主版本发布中完全移除这些功能之前，应该至少发布一个包含这些舍弃功能的次版本，其目的是让用户能够平滑的迁移到新的API 问：语义规范对版本字符串有大小限制吗？ 没有限制，但是255个字符的版本号也太长了一点。此外，特定系统可能会对字符串的大小有限制 辅助工具semantic-release&#x2F;semantic-release conventional-changelog&#x2F;standard-version 参考链接 语义版本规范"},{"title":"2022年2月阅读清单","path":"/2022/02/11/2022年2月阅读清单/","content":"2022年2月阅读清单 毕业五年还在卷：2021 年终总结 - 掘金 [NGX]使用ViewContainerRef来操作Angular中的DOM - 掘金 你会用ES6，那倒是用啊！ - 掘金 Angular使用技巧：NgIf 非常规用法 - 掘金 【卷王的2021】前端：从995到965且涨薪40+%？ - 掘金 【手把手】学会VS Code&amp;#34;任务&amp;#34;神技，成为项目组最靓的崽！ - 掘金 一份前端够用的 Linux 命令 - 掘金 一文搞懂peerDependencies 5 个 JavaScript 写法小技巧分享 - 掘金 如何正确地评价 Angular? 国内研发管理工具PingCode和其他工具对比有什么特别之处？ - 知乎 Angular 真的需要状态管理么？ - 徐海峰的文章 - 知乎 # Angular 依赖注入 - 全面解析 前端生成二维码和条形码完整方案（附问题处理方案） - 掘金 仿微博@人员功能实现 - 掘金 10分钟，打造一个专属于你的cli - 掘金 使用 typescript 快速开发一个 cli - Jason Long - 博客园 如何向开源社区提问题 · Issue #545 · seajs&#x2F;seajs · GitHub How-To-Ask-Questions-The-Smart-Way&#x2F;README-zh_CN.md at main · ryanhanwu&#x2F;How-To-Ask-Questions-The-Smart-Way · GitHub # 如何向开源项目提交无法解答的问题 # 纯管道如何提高 Angular 应用程序的性能 # 使用 Angular 在您自己的库中创建自定义管道 TS入门之细说枚举enum - 掘金 GitHub - ruanyf&#x2F;document-style-guide: 中文技术文档的写作规范 Really Friendly Command Line Intro - Hello Web Books TLCL 杂谈 浅谈跨端技术 - 掘金 低代码的王国里，没有国王 - 掘金 通过fetch看跨域：是谁阻止了跨域请求？ - 掘金 # 这个17k star的拖拽库有点料 冻结JS对象方法技术详解 - 掘金 rxjs-shareReplay 你还在手写TS类型代码吗 - 掘金 关于自建组件库的思考 - 掘金 程序员必备技能之—Typescript - 掘金 GitHub - Anduin2017&#x2F;HowToCook: 程序员在家做饭方法指南。 别害羞，开源社区真的很需要你，教你如何参与开源社区！ - 掘金 影响了一代代前端人的 20 个里程碑式的顶级开源项目！2021 成为里程碑的项目又是哪个呢？ - 掘金 GitHub 上能挖矿的神仙技巧 - 如何发现优秀开源项目 · Issue #45 · biaochenxuying&#x2F;blog · GitHub 聊一聊技术人学习的方向 - 掘金 《重构·改善既有代码的设计》笔记整理 - 掘金 离谱！一个0行代码的库居然拿了50k star！ - 掘金 macOS-Security-and-Privacy-Guide&#x2F;README-cn.md at master · drduh&#x2F;macOS-Security-and-Privacy-Guide · GitHub 目前不适合我 transfom技术细节 - 掘金 # rrweb 带你还原问题现场 vscode 扩展插件开发——入门篇 - 掘金 妈妈再也不用担心我重装VSCode了 - 掘金 Tmux使用手册 | louis blog 你不知道的 WebSocket"},{"title":"安装并使用Verdaccio部署私有NPM仓库","path":"/2022/02/07/安装并使用Verdaccio部署私有NPM仓库/","content":"前言 需要搭建私有的NPM仓库，社区提供了两种方法，我们思考了一下，采用了Verdaccio「主要还是轻量吧」 使用nodejs 安装1yum install -y gcc-c++ make 1curl -sL https://rpm.nodesource.com/setup_14.x | sudo -E bash - 这里我们一开始安装了10.x版本的node，但是发现Cerdaccio不支持10.x的版本，但是yum已经有了缓存需要清除缓存，不然会404 1yum install -y nodejs 1npm install -g verdaccio 1nerdaccio --listen 0.0.0.0:4873 使用docker 安装 拉取最新的docker镜像 1docker pull verdaccio/verdaccio 在服务器/data/verdaccio/conf下创建一个config.yaml放置配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101## This is the config file used for the docker images.# It allows all users to do anything, so don&#x27;t use it on production systems.## Do not configure host and port under `listen` in this file# as it will be ignored when using docker.# see https://verdaccio.org/docs/en/docker#docker-and-custom-port-configuration## Look here for more config file examples:# https://github.com/verdaccio/verdaccio/tree/master/conf## path to a directory with all packagesstorage: /verdaccio/storage/data# path to a directory with plugins to includeplugins: /verdaccio/pluginsweb: # WebUI is enabled as default, if you want disable it, just uncomment this line #enable: false title: Verdaccio # comment out to disable gravatar support # gravatar: false # by default packages are ordercer ascendant (asc|desc) # sort_packages: asc # darkMode: true # logo: http://somedomain/somelogo.png # favicon: http://somedomain/favicon.ico | /path/favicon.ico # rateLimit: # windowMs: 1000 # max: 10000# translate your registry, api i18n not available yet# i18n:# list of the available translations https://github.com/verdaccio/ui/tree/master/i18n/translations# web: en-USmax_body_size: 20mbauth: htpasswd: file: /verdaccio/storage/htpasswd # Maximum amount of users allowed to register, defaults to &quot;+infinity&quot;. # You can set this to -1 to disable registration. # max_users: 1000# a list of other known repositories we can talk touplinks: npmjs: url: https://registry.npmjs.org/packages: &#x27;@*/*&#x27;: # scoped packages access: $all publish: $authenticated unpublish: $authenticated proxy: npmjs &#x27;**&#x27;: # allow all users (including non-authenticated users) to read and # publish all packages # # you can specify usernames/groupnames (depending on your auth plugin) # and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot; access: $all # allow all known users to publish/publish packages # (anyone can register by default, remember?) publish: $authenticated unpublish: $authenticated # if package is not available locally, proxy requests to &#x27;npmjs&#x27; registry proxy: npmjs# You can specify HTTP/1.1 server keep alive timeout in seconds for incoming connections.# A value of 0 makes the http server behave similarly to Node.js versions prior to 8.0.0, which did not have a keep-alive timeout.# WORKAROUND: Through given configuration you can workaround following issue https://github.com/verdaccio/verdaccio/issues/301. Set to 0 in case 60 is not enough.server: keepAliveTimeout: 60middlewares: audit: enabled: true# log settingslogs: &#123; type: stdout, format: pretty, level: http &#125;#experiments:# # support for npm token command# token: false# # enable tarball URL redirect for hosting tarball with a different server, the tarball_url_redirect can be a template string# tarball_url_redirect: &#x27;https://mycdn.com/verdaccio/$&#123;packageName&#125;/$&#123;filename&#125;&#x27;# # the tarball_url_redirect can be a function, takes packageName and filename and returns the url, when working with a js configuration file# tarball_url_redirect(packageName, filename) &#123;# const signedUrl = // generate a signed url# return signedUrl;# &#125;# This affect the web and api (not developed yet)#i18n:#web: en-US 3.运行命令 123456V_PATH=/data/verdaccio; docker run -it -d --rm --name verdaccio \\ -p 4873:4873 \\ -v $V_PATH/conf:/verdaccio/conf \\ -v $V_PATH/storage:/verdaccio/storage \\ -v $V_PATH/plugins:/verdaccio/plugins \\ verdaccio/verdaccio 4.授予文件权限 1sudo chown -R 10001:65533 /data/verdaccio"},{"title":"2022年2月阅读清单","path":"/2022/02/07/2022年2月阅读清单-1/","content":"2022年2月阅读清单 毕业五年还在卷：2021 年终总结 - 掘金 [NGX]使用ViewContainerRef来操作Angular中的DOM - 掘金 你会用ES6，那倒是用啊！ - 掘金 Angular使用技巧：NgIf 非常规用法 - 掘金 【卷王的2021】前端：从995到965且涨薪40+%？ - 掘金 【手把手】学会VS Code&amp;#34;任务&amp;#34;神技，成为项目组最靓的崽！ - 掘金 一份前端够用的 Linux 命令 - 掘金 一文搞懂peerDependencies 5 个 JavaScript 写法小技巧分享 - 掘金 如何正确地评价 Angular? 国内研发管理工具PingCode和其他工具对比有什么特别之处？ - 知乎 Angular 真的需要状态管理么？ - 徐海峰的文章 - 知乎 # Angular 依赖注入 - 全面解析 前端生成二维码和条形码完整方案（附问题处理方案） - 掘金 仿微博@人员功能实现 - 掘金 10分钟，打造一个专属于你的cli - 掘金 使用 typescript 快速开发一个 cli - Jason Long - 博客园 杂谈 浅谈跨端技术 - 掘金 低代码的王国里，没有国王 - 掘金 通过fetch看跨域：是谁阻止了跨域请求？ - 掘金 # 这个17k star的拖拽库有点料 冻结JS对象方法技术详解 - 掘金 目前不适合我但我还是中招了 transfom技术细节 - 掘金 # rrweb 带你还原问题现场"},{"title":"Docker 安装 gitlab-runner 实现 CI/CD","path":"/2022/01/29/Docker-安装-gitlab-runner-实现-CI-CD/","content":"Docker install gitlab-runner 拉取gitlab-runner镜像 1sudo docker pull gitlab/gitlab-runner:latest 添加gitlab-runner container 1234sudo docker run -d --name gitlab-runner --restart always \\ -v /srv/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest 注册runner 1sudo docker exec -it gitlab-runner gitlab-ci-multi-runner register 12345说明： 1、gitlab ci的地址以及token，从你要配置该runner到哪个项目，就去gitlab下该项目首页右侧设置—》CI/CD Pipelines—》Specific Runners下可以找到。 2、gitlab-ci tags这个很重要，在项目构建流程yaml文件里面指定tag，就是匹配使用哪个tag的runner，这里我定义了fone-ui，回头再配置文件里面就指定这个tag。 3、executor：执行者可以有很多种，这里我们使用docker，方便构建执行。 4、Docker image：构建Docker image时填写的image名称，根据项目代码语言不同，指定不同的镜像。我这里项目是node语言的，所以我使用官方node:16.13.2镜像。 设置运行脚本 1234567891011121314151617181920212223cache: paths: - node_modules/image: node:16.13.2build: stage: build tags: - fone-ui script: - echo &quot;show npm registry &amp; proxy...&quot; - npm get registry - npm config get proxy - echo &quot;Start building App...&quot; - npm ci - npm run build - echo &quot;Build successfully!&quot; only: refs: - merge_requests variables: - $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == &quot;develop&quot; || $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == &quot;master&quot; 如何删除呢？ gitlab设置页面，删除runner docker容器中的gitlab-runner中删除 第一个在注册步骤中的页面可以一键删除 第二个使用命令 进入runner容器内 1$ docker exec -it gitlab-runner bash 查看runner列表 1$ gitlab-runner list 使用指定的id和url删除验证 1gitlab-runner verify --delete -t [你的token，即第一步中的对应的token] -u http://git.xxxx.com/ 退出容器 1exit 环境参数 CentOs 7.9 docker 20.20.10 NodeJs 16.13.2 GitLab 社区版 13.12.0"},{"title":"2022年1月阅读清单","path":"/2022/01/27/2022年1月阅读清单/","content":"2022年1月阅读清单 淘系前端团队-karma 测试框架的前世今生 随着工作的进展，测试已经变得越来越迫切起来，之所以关注karma框架，可能还是因为angular默认支持的就是这个吧 淘系前端团队-VSCode原理解析 - 断点调试 淘系前端团队-揭秘浏览器远程调试技术 淘系前端团队-我的前端成长之路： 在阿里七年，我的成长和迷茫 淘系前端团队-VS Code 源码分析 - 多语言实现 jsDelivr 事故后的公共CDN故障自动切换思考 - 友人C [Angular]在Angular中和DOM打交道的正确姿势 - 掘金"},{"title":"「Mac」SourceTree 手动拉取代码每次都需要自己手动刷新列表","path":"/2022/01/05/「Mac」SourceTree-手动拉取代码每次都需要自己手动刷新列表/","content":"起因原本我的GIT是通过Xcode安装的,至于为什么不用brew安装,我已经忘记为什么了. 今天突然心血来潮,把Xcode给卸载了.然后 brew install git,很好,git也支持中文了! 既然版本最新了,那就顺手在SourceTree的Git使用自己下载的吧, 事发没想到这样一来就出问题了 image.png 无法自动更新代码了. 解决重新使用内置版本解决问题!"},{"title":"ng-deep的使用限制","path":"/2021/12/08/ng-deep的使用限制/","content":"对于ng-deep,感觉官方的态度是比较暧昧的,但是这个使用场景其实还是比较多的.特别是在组件内部使用其他组件,并且需要仅在当前组件下自定义样式的情况,ng-deep就显得比较迫切了. 但是以前以为在组件样式文件夹内直接使用::ng-deep是没有问题的,也会挂在当然组件下面,但是实际并不是如此 image.png image.png 如果直接在最外层使用::ng-deep是会直接加载至全局样式的,用户知道打开过此组件页面,就算后期关闭也会有此遗产存留. 本来是期望使用第二种使用方案,即外层包含一个保护类.这样即使加载了,也会因为angular的组件样式隔离而无法影响其他页面. 但是白天在交流的时候,有人提到了::host这个关键字特意去看了官方文档,其实官方已经想到了这种情况 已弃用 &#x2F;deep&#x2F;、&gt;&gt;&gt; 和 ::ng-deep 所以结论在使用::ng-deep的地方应该加上:host伪类选择器"},{"title":"Angular ChangeDetection:OnPush的视图更新策略","path":"/2021/09/23/Angular-ChangeDetection-OnPush的视图更新策略/","content":"默认更新策略 defaultAngular默认在三种情况下数据更新 事件驱动 事件: 页面 click、submit、mouse XHR: http 请求 Timer: setTimeout()、 setInterval() 都为异步且都是不同类型的webapi angular 通过zone.js, 而zone.js 通过猴子补丁的方式强制重写了浏览器关于异步事件的捕获处理. 推送策略 OnPush如果组件设置了 1234@Component(&#123; ..., changeDetection: ChangeDetectionStrategy.OnPush&#125;) 则需要手动触发变更检测 组件的@Input属性的引用发生变化. 组件内的 DOM 事件,包括它子组件的 DOM 组件内的 Observable 订阅事件,同时设置Asynv pipe, 即默认的订阅事件其实是不会被angular捕获的 组件内手动使用 ChangeDetectorRef.detectChanges()、ChangeDetectorRef.markForCheck()、ApplicationRef.tick() ChangeDetectorRef-官方指南 变更触发顺序在设置了@Input字段之后, 组件内更新的顺序根据模板中的变量前后顺序有关即 1&lt;app-demo [input1]=&quot;a&quot; [input2]=&quot;b&quot;&gt;&lt;/app-demo&gt; 先修改input1,然后再修改input2,特别在设置了setter方法之后,表现特别明显 参考资料"},{"title":"2021年9月阅读文稿.md","path":"/2021/09/08/2021年9月阅读文稿-md/","content":"#2021年9月阅读文稿.md 杂谈 跨浏览器窗口通讯,7种方式 css 实现单行居中,多行省略 如何做好 CodeReview Webpack 5.0新特性 模块联邦 如何比较Object 因为使用peerDependencies 而引发的 bug undefined 与 null 的区别 Typescript 4 用 Reduce 实现 Promise 串行执行 Cache API 技术 精通 console.log 手写JSON.parse 巧用 CSS filter,让你的网站更加炫酷 Angular 变更检测以及单项数据流 *Angular 2 Change Detection - 2 如何命名 angular 变更检测详解"},{"title":"永劫无间·胡桃·三排攻略","path":"/2021/08/16/永劫无间·胡桃·三排攻略/","content":"永劫无间·胡桃·三排攻略 S0赛季陨星守门员,指挥,专打固定三排(胡桃、和尚、宁红叶[特穆尔]) 打法!!!永远找机会多少打, 2v1, 3v1 排除遭遇战,先远程消耗,随后队友和尚和宁红叶[特穆尔]先手进场,胡桃在中等距离补充伤害和控制,[k头] 天赋 &amp; 技能天赋天赋是一个需要考虑队友的作战习惯,团队中胡桃的定位来折中考虑 精力·怒气·幸运·拉人 通用 (上左右精力,下钩索距离)这套就是纯打架拼操作的天赋 精力 + 幸运 (上左右精力,下幸运)这套放弃了追击能力,而补充了幸运,可以让你落地更快的拿到优质装备,也可以在第一条命浪费之后,打野发育效率增加,这套比较常用,精力的追加可以让你挨打的时候更好操作,幸运的增加也会让你落地更快的补充装备 怒气 + 精力 + 幸运 (左每秒努气, 上攻击怒气, 右精力上限, 下幸运)折中怒气和精力,因为毕竟分段越往上打,其实打得还是很谨慎,要么不打,一开打必须马上秒人. 怒气 + 精力 + 幸运 + 拉人 (左每秒怒气, 上攻击怒气, 右拉人速度, 下幸运)同理,去掉了精力,追加辅助能力,一般不需要胡桃拼操作的时候,而且队友落地很容易就暴毙的时候. 技能F1 + V3 武器 &amp; 魂玉武器选择长剑 + 连弩 长剑在近距离补充伤害,尽量在敌人视野盲区努力,也可看准备队友被振刀时,释放剑气打断对方振刀追击.连弩配合和尚或宁红叶[特穆尔]的控制完成点杀. 魂玉选择胡桃不需要绝大多数攻击魂玉,无论是是否为装备的金色魂玉,此类完全可以让给输出队友.优先保证村活.在保证自己存活的情况下,辅助队友.因为一般都会先杀辅助. 属性魂玉: 近抗 &gt; 体力(金色优先) 辅助魂玉: 虚影步,地堂霸脚,凌波,壁虎游墙(房区爬墙逃避伤害神器),妙手 小细节 不要落单 精准报点,遇人永远等队友|集合 不恋战,不贪伤害,要打就集火秒人,不然就不打"},{"title":"storybook doc-block argType 详解","path":"/2021/08/06/storybook-doc-block-argType-详解/","content":"storybook doc-block argType 详解参数详情 overview 字段 说明 name 同字段名,可省略 type.require boolean description 描述 defaultValue 数据:默认值 table.type.summary 类型的简单描述 table.type.detail 类型的长描述 table.defaultValue.summary 显示:默认值 table.defaultValue.detail 显示:默认值详细说明 control.type 控件类型(需要有[数据]默认值) e.g. null , radio , text , number options 控件类型为 radio 时的值数组 举个 🌰 e.g.1234567891011121314151617181920Primary.argTypes = &#123; fNotFoundImage: &#123; name: &#x27;fNotFoundImage&#x27;, type: &#123; required: false, &#125;, table: &#123; defaultValue: &#123; summary: &#x27;null&#x27;, &#125;, type: &#123; summary: &#x27;string | TemplateRef&lt;void&gt;&#x27; &#125; &#125;, description: &#x27;图片url&#x27;, defaultValue: null, options: [null, &#x27;https://www.sass.hk/images/sass.png&#x27;], control: &#123; type: &#x27;radio&#x27; &#125;, // 可简写成 =&gt; control: &#x27;radio&#x27; &#125;&#125;; 控件参数详解 data type &amp; 数据类型 control type &amp; 控件类型 description &amp; 描述 options &amp; 选项 array array serialize array into a comma-separated string inside a textbox separator boolean boolean checkbox input - number number a numberic text box input min, max, step - range a range slider input min, max, step object object json editor text input - enum radio radio buttons input Ï options - inline-radio inline radio buttons input options - check multi-select checkbox input options - inline-check multi-select inline checkbox input options - select select dropdown input options - multi-select multi-select dropdown input options string text simple text input - - color color picker input that assumes strings are color values - - date date picker input - 再举个 🌰 e.g.1234567export default &#123; title: &#x27;Gizmo&#x27;, component: Gizmo, argTypes: &#123; width: &#123; type: &#x27;range&#x27;, min: 400, max: 1200, step: 50 &#125;; &#125;,&#125;;"},{"title":"2021年8月阅读目录","path":"/2021/08/04/2021年8月阅读目录/","content":"2021年8月阅读目录.md杂项 When You “Git” in Trouble - a Version Control Story how we position and what we compare(可视化案例) async await 是把双刃剑 现代JS框架存在的根本原因 typescript 2.0-2.9文档 谈谈 web workers typescript 3.2 新特性 caches api 如何编译前端项目与组件 Scheduling in React 国际化布局-Logical Properties Nodejs V12 使用 css 变量 前端深水区 前端与 BI 用 grid 重新思考布局 我在阿里数据中台大前端 技术 图解 ES 模块 精读《插件化思维》 css 选择器 编写有弹性的组件 持续集成 vs 持续交付 vs 持续部署 Optional chaining – ts已支持 rxjs rxjs-cn RxJS：四种 Subject 的用法和区别 RxJS：所有订阅都需要调用 unsubscribe 取消订阅？ Nuxtjs 寻找框架设计的平衡点 基础知识 V8引擎 Lazy Parsing What’s new in javascript 前端未来展望 源码学习"},{"title":"七月随机阅读文章目录(2021Y)","path":"/2021/07/22/七月随机阅读文章目录-2021Y/","content":"七月随机阅读文章目录(2021Y) 记录一下自己七月份看到的一些前端文章(排名只分遇到之时间顺序) V8 引擎特性带来的 JS 性能变化 try-catch 越来越需要在工作中提高使用频次了。 2.便利依旧优先for-in 3.delete性能优化，不过在 ts 中其实并不怎么使用 正则表达式|MDN 没什么说的,正则确实不会. package-lock.json 需要提交到 git？ 版本控制相关的内容有错或者说不清晰,只能说看看里面文件结构以及字段的介绍吧 命令需要自己检查,作者提供的不准确 vscode 是怎么跑起来的 很大概的介绍,引入了一些依赖注入的思想 以及现代前端需要了解和学习的两大技术栈node、chromium GitHub、GitLab、Git 操作的一些规范 介绍了一下 angular-commit 规范 比较需要留意的是 git reflog、ignore 一篇讲透自研的前端错误监控 涉及的知识点很多 全面的错误捕获 错误定位,sourceMap 后端的错误搜集 加班粗略看了一下.想有收获应该还是需要精读一番 如何从前端小白进化为带队大佬 其实就涉及到一些软技能了 精读《API》设计原则 不想写好 API 的开发不是一个好开发 但是具体方法还是得从模仿优秀的开源框架开始 你真的了解package.json 讲解很详细,并且是中文友好 确实英文能力不好人.对于看文档有一种隐式的推脱 简化你的JavaScript 使用some &amp; find 两者都是查找即停,而不会全量遍历 如何快速学习东西如何永远记住任何事情在Angular中取消订阅的6种办法 ngOnDestroy() async Pipe Rxjs take* operator(需要注意确认在component生命周期内触发完成) Rxjs first 装饰器自动调用销毁(非订阅会很麻烦) 使用ts&#x2F;eslint Angular重构示例业务系统的稳定性建设 搭建一套错误收集系统需要思考的点 2021年前端趋势预测 前端&amp;AI 基建即node&amp;webpack重点关注 前端机器学习的利器,更快的Pipcook 现在JavaScript概述null &gt;&#x3D; 0 &#x3D;&#x3D;&#x3D; true 介绍了一下比较的逻辑判断 最复杂的反而是&#x3D;&#x3D;,所以项目优先使用显式的真等和显式类型转换 2017年前端性能优化备忘录css-in-js 杀鸡用牛刀ja 中的内存管理 虽然是个老生常谈的问题,不过还是会点开看看 DOM 引用 闭包 Javascript 事件循环与异步Ant Design 3.0 背后的故事 看这个只是因为最近在写自己的组件库"},{"title":"如何优化angular-cli构建速度","path":"/2021/07/15/如何优化angular-cli构建速度/","content":"优化 angular cli build 速度增加内存一般会增加一个nodejs命令来提高打包时分配的内存,比如说 1node --max_old_space_size=8196 ./node_modules/@angular/cli/bin/ng build --prod 但是实际测试发现,分配大额内存对于构建速度是负优化 修改打包配置项** 注意,本人用于gitlab-CI 的速度优化,而非实际生产环境配置 ** angular.json 123456789101112&quot;optimization&quot;: false, &quot;outputHashing&quot;: &quot;none&quot;, &quot;sourceMap&quot;: false, &quot;extractCss&quot;: true, &quot;namedChunks&quot;: false, &quot;showCircularDependencies&quot;: false, &quot;aot&quot;: true, &quot;extractLicenses&quot;: false, &quot;statsJson&quot;: false, &quot;progress&quot;: false, &quot;vendorChunk&quot;: true, &quot;buildOptimizer&quot;: false, 当然可以复制追加一个自定义的命名配置,直接通过npm脚本运行 1ng build --configuration=myenv 这里提供一个思路,但是具体配置项,可以根据需要微调,毕竟,速度前提是正确! ps: 附上本机实际时间对比 效果斐然 命令 时间 node --max_old_space_size=8196 ./node_modules/@angular/cli/bin/ng build --prod 3.4447分钟 ng build --prod 2.8793分钟 改打包配置文件 1.1223分钟"},{"title":"前端开发调试之奇技淫巧","path":"/2021/07/01/前端开发调试之奇技淫巧/","content":"#记录开发过程中的一些调试小技巧 插件 vscode-chrome调试插件 小技巧列表 chrome-js代码黑盒化"},{"title":"一步一步教你如何在 angular 项目中使用 eslint 以及 prettier 配合 husky 实现自动控制代码结构","path":"/2021/06/29/一步一步教你如何在-angular-项目中使用-eslint-以及-prettier-配合-husky-实现自动控制代码结构/","content":"一步一步教你如何在 angular 项目中使用 eslint 以及 prettier 配合 husky 实现自动控制代码结构工具安装Prettier首先，安装prettier1npm install --save-dev --save-exact prettier 不同版本的 prettier 有不同的格式实现，所以需要精准安装，并且，您使用的任何插件或可共享配置都必须在任何一种情况下本地安装!!! 然后创建配置文件 .prettierrc.json 这是我的配置12345678910111213&#123; &quot;tabWidth&quot;: 2, &quot;semi&quot;: true, &quot;singleQuote&quot;: true, &quot;jsxSingleQuote&quot;: true, &quot;bracketSpacing&quot;: true, &quot;jsxBracketSameLine&quot;: true, &quot;printWidth&quot;: 120, &quot;endOfLine&quot;: &quot;lf&quot;, &quot;proseWrap&quot;: &quot;preserve&quot;, &quot;trailingComma&quot;: &quot;es5&quot;, &quot;useTabs&quot;: false&#125; 别忘记了忽略文件 .perttierignore 下面是我的配置1234567# Ignore artifacts:buildcoveragepublish#尚未准备好处理html*.html 当然 vscode 有配套的插件 Prettier - Code formatter，安装之后会读取你工作区的配置文件Eslint第一步还是安装1npm install eslint --save-dev 然后初始化1npx eslint --init –init假设您已经有一个package.json文件 配置规则初始化之后，你会在你的 .eslintrc.&#123;js,yml,json&#125; 文件中看到以下内容 123456&#123; &quot;rules&quot;: &#123; &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;], &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;] &#125;&#125; 名称 semi 和 quotes 是 ESLint 中规则的名称。第一个值是规则的错误级别，可以是以下值之一： off 或 0 - 关闭规则warn 或 1 - 打开规则作为警告（不影响退出代码）error 或 2- 将规则作为错误打开（退出代码将为 1） 具体规则描述👉规则 您的.eslintrc.{js,yml,json}配置文件还将包含以下行： 123&#123; &quot;extends&quot;: &quot;eslint:recommended&quot;&#125; 这说明你的 Eslint 将会继承默认推荐规则, 即在规则页面前有 ✅ 的规则 配合使用配合配合 Eslint 和 Prettier 你需要安装一个 Eslint 的 prettier 配置 安装1npm install --save-dev eslint-config-prettier 配置然后添加 prettier 到 .eslintrc.* 文件的 extends 数组中 123456&#123; &quot; extends &quot; : [ &quot; some-other-config-you-use &quot; , &quot; prettier &quot; ]&#125; Git 预提交钩子1npx mrm lint-staged 这将安装 husky 和 lint-staged，然后向项目添加一个配置，该配置package.json将在预提交挂钩中自动格式化支持的文件。 此时你的 package.json 1234&quot;lint-staged&quot;: &#123; &quot;*.ts&quot;: &quot;eslint --cache --fix&quot;, // 默认为js，自行按需修改，下同 &quot;*.&#123;js,ts,css,scss,md&#125;&quot;: &quot;prettier --write&quot; &#125; 注意：如果您使用 ESLint，请确保 lint-staged Eslint 在 Prettier 之前而不是之后运行它。 如果需要husky在你提交代码时检查您的提交信息则请看另外文章 写在最后本文只是应用的一次 step to step ，若想深入了解操作原理还需仔细阅读官方文档 Eslint Prettier Prettier 与 Linter配合 Lint-staged"},{"title":"Git  flow 介绍以及使用","path":"/2021/05/21/Git-flow-介绍以及使用/","content":"[scode type&#x3D;”blue”]协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去。”工作流程”在英语里，叫做”workflow”或者”flow”，原意是水流，比喻项目像水流那样，顺畅、自然地向前流动，不会发生冲击、对撞、甚至漩涡。[&#x2F;scode] 功能驱动需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。 Git flow特点 git-flow-ow.png 项目存在两个长期分支。 主分支 master 开发分支 develop 前者用于存放对外发布的版本；后者用于日常开发，存放最新的开发版。 其次，项目存在三种短期分支。 功能分支 feature branch 补丁分支 hot fix branch 预发分支 release branch 一旦开发完成，它们就会被合并进develop 或 master, 然后被删除 安装 Git flowwindows版本的git 已经自带其他版本 [其他版本安装地址][https://github.com/petervanderdoes/gitflow-avh/wiki/Installation] git-flow 并不是要替代 Git，它仅仅是非常聪明有效地把标准的 Git 命令用脚本组合了起来。严格来讲，你并不需要安装什么特别的东西就可以使用 git-flow工作流程。你只需要了解，哪些工作流程是由哪些单独的任务所组成的，并且附带上正确的参数，以及在一个正确的顺序下简单执行那些对应的 Git命令就可以了。当然，如果你使用 git-flow 脚本就会更加方便了，你就不需要把这些命令和顺序都记在脑子里。 使用-初始化1git flow init [-d] 7E0251C3-0A9B-4901-96E1-9A44AAC368B8.png 看起来是不是有点炫，但实际上它只是在你的分支上配置了一些命名规则。建议默认 [-d] 分支模式 Master -只能用来包括产品代码。你不能直接工作在这个 master 分支上，而是在其他指定的，独立的特性分支中。不直接提交改动到 master 分支上也是很多工作流程的一个共同的规则。 develop - 是你进行任何新的开发的基础分支。当你开始一个新的功能分支时，它将是_开发_的基础。另外，该分支也汇集所有已经完成的功能，并等待被整合到 master 分支中。 4A6C9C4D-AB21-46E3-8140-2CCC13D77E94.png 这两个分支被称作为长期分支。它们会存活在项目的整个生命周期中。而其他的分支，例如针对功能的分支，针对发行的分支，仅仅只是临时存在的。它们是根据需要来创建的，当它们完成了自己的任务之后就会被删除掉。 功能开发开始新功能让我们开始一个新功能 “rss-feed” E412C074-A4AC-4B5C-8BE5-26F1FB32030D.png Git flow 会打印出刚刚完成的操作的概述，如果你需要帮助随时可以 1git flow feature help 正如上面这个新功能一样，git-flow 会创建一个名为 “feature&#x2F;rss-feed” 的分支（这个 “feature&#x2F;” 前缀 是一个可配置的选项设置）。你已经知道了，在你做新功能开发时使用一个独立的分支是版本控制中最重要的规则之一。 git-flow 也会直接签出这个新的分支(即已经自动切换到此新分支)，这样你就可以直接进行工作了。 3F8484EE-FB3C-4BE2-BE3F-59991007C87D.png 完成一个功能经过一段时间艰苦地工作和一系列的聪明提交，我们的新功能终于完成了： 1git flow feature finish rest-feed F3D5E62B-A39C-47B6-850E-F043DEEE51A3.png 最重要的是，这个 “feature finish” 命令会把我们的工作整合到主 “develop” 分支中去。在这里它需要等待： 一个在更广泛的 “开发” 背景下的全面测试。 稍后和所有积攒在 “develop” 分支中的其它功能一起进行发布。 之后，git-flow 也会进行清理操作。它会删除这个当下已经完成的功能分支，并且换到 “develop” 分支。 管理 releaseRelease 管理是版本控制处理中的另外一个非常重要的话题。让我们来看看如何利用 git-flow 创建和发布 release。 创建 release当你认为现在在 “develop” 分支的代码已经是一个成熟的 release 版本时，这意味着： 第一，它包括所有新的功能和必要的修复； 第二，它已经被彻底的测试过了。 如果上述两点都满足，那就是时候开始生成一个新的 release 了： 1Git flow release start 1.1.5 078BAD7C-ED05-4D8E-8104-4A9EF182061D.png 请注意，release 分支是使用版本号命名的。这是一个明智的选择，这个命名方案还有一个很好的附带功能，那就是当我们完成了release 后，git-flow 会适当地_自动_去标记那些 release 提交。有了一个 release 分支，再完成针对 release 版本号的最后准备工作（如果项目里的某些文件需要记录版本号），并且进行最后的编辑。 完成 release1git flow release finish 1.1.5 需要填写tag message 5EDFB0A6-75B6-4BA8-870B-12A0BE86AD5D.png EBC3588A-F271-4454-9EDA-1BDE08D3B6C0.png 这个命令会完成如下一系列的操作： 首先，git-flow 会拉取远程仓库，以确保目前是最新的版本。 然后，release 的内容会被合并到 “master” 和 “develop” 两个分支中去，这样不仅产品代码为最新的版本，而且新的功能分支也将基于最新代码。 为便于识别和做历史参考，release 提交会被标记上这个 release 的名字（在我们的例子里是 “1.1.5”）。清理操作，版本分支会被删除，并且回到 “develop”。 从 Git 的角度来看，release 版本现在已经完成。依据你的设置，对 “master” 的提交可能已经触发了你所定义的部署流程，或者你可以通过手动部署，来让你的软件产品进入你的用户手中。 hotfix很多时候，仅仅在几个小时或几天之后，当对 release 版本作做全面测试时，可能就会发现一些小错误。在这种情况下，git-flow 提供一个特定的 “hotfix” 工作流程（因为在这里不管使用 “功能” 分支流程，还是 “release” 分支流程都是不恰当的）。 创建Hotfixes1Git flow hot fix start miss-link 这个命令会创建一个名为 “hotfix&#x2F;missing-link” 的分支。因为这是对产品代码进行修复，所以这个 hotfix 分支是基于 “master” 分支。这也是和 release 分支最明显的区别，release 分支都是基于 “develop” 分支的。因为你不应该在一个还不完全稳定的开发分支上对产品代码进行地修复。就像 release 一样，修复这个错误当然也会直接影响到项目的版本号！ 完成 Hotfixes1git flow hotfix finish miss-link 这个过程非常类似于发布一个 release 版本： 完成的改动会被合并到 “master” 中，同样也会合并到 “develop” 分支中，这样就可以确保这个错误不会再次出现在下一个 release 中。 这个 hotfix 程序将被标记起来以便于参考。 这个 hotfix 分支将被删除，然后切换到 “develop” 分支上去。 还是和产生 release 的流程一样，现在需要编译和部署你的产品（如果这些操作不是自动被触发的话）。 59240A8C-E3F3-4218-B079-5D8FB9C60D3E.png 回顾总结首先，git-flow 并不会为 Git 扩展任何新的功能，它仅仅使用了脚本来捆绑了一系列 Git 命令来完成一些特定的工作流程。 其次，定义一个固定的工作流程会使得团队协作更加简单容易。无论是一个 “版本控制的新手” 还是 “Git 专家”，每一个人都知道如何来正确地完成某个任务。 记住，使用 git-flow 并不是必须的。当积攒了一定的使用经验后，很多团队会不再需要它了。当你能正确地理解工作流程的基本组成部分和目标的之后，你完全可以定义一个属于你自己的工作流程。"},{"title":"macOS安装NVM","path":"/2021/05/10/macOS安装NVM/","content":"不要使用brew工具安装nvm!不要使用brew工具安装nvm!不要使用brew工具安装nvm! 会有一些奇怪的坑,而且官方也不推荐,虽然可以安装并且使用,但是需要才很多坑. #官方安装 https://github.com/nvm-sh/nvm 其实就是下面这一句 1curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh 不过我使用命令安装的时候一直遇到网络情况,然后我仔细阅读了一下说明文档 安装说明 也可以直接运行安装脚本,那直接走你! 新建’install’ 文件 复制 github中的 ‘install.sh’ 里面的内容 重命名 ‘install’ &#x3D;&gt; ‘install.sh’ ~ $ sh install.sh 安装成功! 然后打开 ~ 下的 ‘.zshrc’ (不同终端不同文件) 终端配置文件 保存,然后 1$ source .zshrc 运行一下环境变量 然后接下来就是安装node了 #解决速度问题 在终端中运行下面代码修改nvm的下载源 1export NVM_IOJS_ORG_MIRROR=https://npm.taobao.org/mirrors/iojs 我盲猜这是一次性的,所以在上面的 .zshrc 文件中,我也加入了这一段,希望能够每次运行的时候就修改我nvm的下载源.如果猜错,烦请留言指正,不胜感激! 那么安装nvm关键步骤就完成了! 说在最后: 最近用自己的电脑办公了,之前一直只是课余时间使用macos,这次竟然装环境就花了我大半天时间,还是要学以致用啊!shell命令其实我也是一知半解,慢慢摸索吧."},{"title":"很有意思的东西-关于临时变量在循环体内定义，还是在循环体外定义的问题","path":"/2021/03/31/很有意思的东西-关于临时变量在循环体内定义，还是在循环体外定义的问题/","content":"在一开始学循环的时候，比如说遍历一个list数组,是这么教的: 123for(let i = 0; i &lt; list.length; i++)&#123; //xxx &#125; 但是其实每次循环结束判断条件的时候，都是会去调用list.length,这都是需要消耗性能，如果数组是一个固定长度的那么，可以写成这样： 123for(let i = 0, len = list.length; i &lt; len; i++)&#123; //xxx &#125; 这样，就在初始化的时候，把数组长度给缓存了下来，而不用每次判断的时候去list里面找。 今天在leetcode刷题的时候，因为涉及到循环，而且需要临时变量，我就按照惯例，在循环体中声明并且使用了临时变量，如下方 给定一个Excel表格中的列名称，返回其相应的列序号。A -&gt; 1B -&gt; 2C -&gt; 3…Z -&gt; 26AA -&gt; 27AB -&gt; 28… 123456789101112function titleToNumber(columnTitle: string): number &#123; let len = columnTitle.length - 1; let radix = 1; let sum = 0; while (len &gt;= 0) &#123; let temp = columnTitle.charCodeAt(len) - 64; sum += temp * radix; len--; radix *= 26; &#125; return sum;&#125;; 提交了之后，速度果然 微信图片_20210331165400.png 但是我想，这样每次循环的时候都会创建变量，是不是直接在外部初始化一个临时变量，这样每次直接赋值就好了？ 说干就干 12345678910111213function titleToNumber(columnTitle: string): number &#123; let len = columnTitle.length - 1; let radix = 1; let sum = 0; let curr: number; while (len &gt;= 0) &#123; curr = columnTitle.charCodeAt(len) - 64; sum += curr * radix; len--; radix *= 26; &#125; return sum;&#125;; 很快啊，直接保存提交，霍，直接时间加了20ms增加1&#x2F;4，这可不行啊。 那么联想到list.length的情况，我猜测是因为如果不在循环体内定义的话，需要通过作用域链找寻上层作用域链中的临时变量，这样成本是会比直接在本身作用域中找寻的成本大的。 一个有意思的小细节 再追加一个小技巧: js向下取整 number | 0 &#x3D;&#x3D;&#x3D; Math.floor(number)"},{"title":"灵光一闪-《令人心动的offer》","path":"/2020/12/07/灵光一闪-《令人心动的offer》/","content":"丁辉 《令人心动的offer》里面一个仅有的所谓低阶级的人。因为最近我从我朋友圈，身边的人，都在讨论这个。全部都在为丁辉鸣不平。确实，好像其他的几个人都是身世显赫，或者家境富裕。 当然文章多的原因是因为丁辉这个打工人符合普通大众的视觉：一个普通人努力奋斗，却因为种种不公平，而导致前路受错。而产生了一种共鸣，再联想到自己的悲惨生活。瞬间心情就符合了。 凡事存在和即合理 节目组方面：需要这个矛盾点，产生热点。不然平平无奇谁会看我们这个节目，我可不管你什么有的没的，节目有热度，才有金主爸爸给我钱，节目领导就会开心。 单位：确实你现在能力是不错，但是有能力的人也不缺你一个，你的竞争力是什么？其他小伙比你年轻，过几年也能达到你这个水平。我现在招你，你的长期效益确实没有其他人高。大家都是很现实的，不会做亏本买卖。 丁辉方面：确实，你们看好像现在丁辉是最惨的角色，律师所不待见他，年纪也大。但是，对他个人而言。所有实习生里存在感最强的人是他，《心动的offer》给了他一个曝光口，这不就是雷军说的风口吗？这个世界临近30岁还在努力奋斗工作的人多你一个不多，少你一个不少。不需要你丁辉，随便换个人来。也是这个效果。（当然，丁辉也事实证明了自己的能力） 你好我好大家好 大家都没损失，节目自有收视率，律师所能有优质新人。丁辉有曝光度。大家都有光明的未来。 淡然，虽说作为观众好像白打工，提供了收视率，付出了真情实感。不过你感情得到了共鸣。一箭多雕不是吗？ 引用知名划水人的名言： 我爱这个魔幻的世界~"},{"title":"《如果声音不记得》--希望所有黑暗都能被爱照亮","path":"/2020/12/06/《如果声音不记得》-希望所有黑暗都能被爱照亮/","content":"从来没有这么这么深刻的感受到抑郁症的绝望与痛苦。 因为母亲是一个感情细腻的人，所以我也难免继承了这份细腻的感情，在长大的过程中，也经常被人分享一些“心情”。有些是感情，有些是亲情。身边直接或间接的也接触到了几个抑郁症的朋友。虽然能感受到他们的心情，但是。还是很难感受到他们的绝望，感觉很难接触，很难深入他们的内心。甚至连渠道也找不到。 无独有偶，今天看完了《爱的能力》。整本书都在讲爱，讲爱的能力。有些观点我能接受，有些观点我看的时候甚至觉得是放屁。但是，爱确实是这个世界最伟大的力量，什么疾病都有药，唯有抑郁症，唯一的良药就是爱❤️ 命运就是这么神奇，本来是想随便看一部电影的，种种巧合，我有且只能看了《如果声音不记得》，也刚好母亲给了我细腻的情感。也刚好今天看完了《爱的能力》，也刚好这几天，几个朋友找我倾诉一些烦恼。希望我的所做能帮到你们。 你们说爱到底是什么呢？ 人活着好像都是带有一些目的的，名利，什么都是带有功利性，只有爱，讲究的是付出。我希望你幸福，我希望你快乐，我希望你笑容满面，我希望你没有烦恼。 那么，我也希望抑郁的你们能感受我们的爱❤️。"},{"title":"计算寻址范围","path":"/2020/12/02/计算寻址范围/","content":"假如有一个 1GB 容量存储器，cpu字长32位 如果按字节编址1GB &#x3D; 2^30B1字节 &#x3D; 1B2^30B&#x2F;1B &#x3D; 2^30寻址范围为0-（2^30） - 1 需要30根地址线 如果按字编址1GB &#x3D; 2^30B1字 &#x3D; 32bit &#x3D; 4B[scode type&#x3D;”blue”]ps：字长是32位，就是指1字&#x3D;32bit，该信息只有在按字编址时才有用。这里的字长说的是存储字长）[&#x2F;scode]2^32B&#x2F;4B &#x3D; 2^28寻址范围为0 - （2^28） - 1 需要28根地址线 有因为是16进制所以4位二进制代表以为16进制28&#x2F;4 &#x3D; 70000000 - FFFFFFF 公式： 存储空间 &#x3D; 寻址范围* （按字节或者按字） [scode type&#x3D;”blue”]寻址范围是数字范围[&#x2F;scode]"},{"title":"数码宝贝：最后的进化","path":"/2020/10/30/数码宝贝：最后的进化/","content":"image.jpeg 今天看了数码宝贝：最终的进化。本来也是赵旭升邀请我，我才会看的。但是随着Butter-Fly的音乐响起。我发现我好像突然回到了十几年前的夏天。这种感觉很奇妙。让我从繁重的工作生活中，一下子解脱了出来。 当然，剧情的发展也特别符合我们现在的心境，大家都长大了。都不想从前一样能那么肆无忌惮，都有了一些枷锁。我也觉得这样的生活不太好。但是却不知道该怎么办。 有的人选择了固守在自己的回忆里，当然，我也有这样的选择，我一直到现在也还偶尔回忆从前，当然，频率没那么频繁。我还记得刚毕业的时候，爸爸妈妈想让我当兵，或者去当公务员，我觉得我不能接受，我不能接受自己的生活一眼就能望到底。一点波澜都没有；随着毕业工作了一年多，我好像已经习惯了当社畜的感觉。甚至心里还在想，好像公务员，当兵这种稳定的事情，其实也不错，朝九晚五，这样的生活多好啊！ 但是，一成不变的生活真的是我想要的吗？曾经的我喜欢稳定，我惧怕、拒绝变化，觉得变化是我不能接受，不能掌控的，但是，变化，才能有新事物，每一天都是未知的，都是随机的感觉这样不好吗？我才23，为什么已经不想要变化了呢？ 我需要好好反思，当然，因为是长大了，接触的事情多了，自己的世界观变大了，以前小时候，世界观就这么大，以为整个世界都是自己的，世界的中心就是我身边的圈子，现在长大了，接触的，看到了，感受到的事物多了，好像把自己的位置变得比较靠后了，考虑的因素多了起来。可是，这样的生活真的是你想要的吗？ 就像最后说的，我一定会找到你！我要在接触了世界之后，还能在人群中，一眼找到你。毕竟我们都是孩子。不是吗？孩子还有无限的可能。我喜欢未知，未知的世界才是充满魅力的世界"},{"title":"适用于webkit的自定义浏览器样式","path":"/2020/08/17/适用于webkit的自定义浏览器样式/","content":"前言： 现在越来越要求“表面功夫”了，几乎所有的手机端浏览器的滚动条都是Mini版本，近些年来，部分PC端的前端页面的滚动条也开始变得妖艳贱货了起来。这里做下记录方便个人查看 [scode type&#x3D;”blue”]必须为webkit内核，即样式前缀需支持-webkit-,也可配合css选择使用，若不搭配使用，则为全局样式[&#x2F;scode] 伪元素 选择器 备注 滚动条 ::-webkit-scrollbar 整体 滚动条按钮 ::-webkit-scrollbar-button 上下方向键 滚动条轨道 ::-webkit-scrollbar-track 滚动条滚动的上下去区间 滚动条-补偿 ::-webkit-scrollbar-track-piece 滚动条轨道-滚动条实体的部分 滚动条-实体 ::-webkit-scrollbar-thumb 滚动条实体 水平垂直滚动条交接部分 ::-webkit-scrollbar-corner 基本为页面右下角 拖动区 ::-webkit-resize 与滚动条交接区重合，可以重设大小 [scode type&#x3D;”share”]tips:我们可以为这些对象中的每个对象设置边框，阴影，背景图像等样式，以创建完全自定义的滚动条，当然，且没有疑惑这些滚动条在按钮位置和单击行为方面仍将遵循操作系统的设置。[&#x2F;scode] 另外，引入了以下伪类并将其应用于伪元素。 :horizontal –水平伪类适用于任何具有水平方向的滚动条。 :vertical –垂直伪类适用于任何具有垂直方向的滚动条。 :decrement–减量伪类适用于按钮和轨道块。它指示按钮或轨道块在使用时是否会降低视图的位置（例如，在垂直滚动条上向上，在水平滚动条上左侧）。 :increment–增量伪类适用于按钮和跟踪片段。它指示按钮或轨迹块在使用时是否会增加视图的位置（例如，在垂直滚动条上向下，在水平滚动条上右侧）。 :start– start伪类适用于按钮和跟踪片段。它指示对象是否放置在拇指之前。 :end–结束伪类适用于按钮和跟踪片段。它指示对象是否放置在拇指后面。 :double-button–双按钮伪类适用于按钮和轨道块。它用于检测一个按钮是否是位于滚动条同一端的一对按钮的一部分。对于履带板，它指示履带板是否邻接一对按钮。 :single-button–单按钮伪类适用于按钮和轨道块。它用于检测按钮是否位于滚动条末尾。对于履带板，它指示履带板是否邻接单例按钮。 :no-button –适用于曲目片断，并指示曲目片断是否延伸到滚动条的边缘，即，曲目的那端没有按钮。 :corner-present –适用于所有滚动条，并指示是否存在滚动条角。 :window-inactive–适用于所有滚动条，并指示包含滚动条的窗口当前是否处于活动状态。（在最近的夜间，此伪类现在也适用于:: selection。我们计划将其扩展为可处理任何内容，并将其提议为新的标准伪类。） 此外，：enabled，：disabled，：hover和：active伪类也可以与滚动条一起使用。 可以将display属性设置为none，以便隐藏特定的作品。 沿滚动条的轴支持边距。它们可以是负数（例如，可以使轨道膨胀以部分覆盖按钮）。 举个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041::-webkit-scrollbar:vertical &#123; -webkit-border-image: url(resources/vertical-button.png) 2 0 2 0; border-color: transparent; border-width: 2px 0; background-image: url(resources/vertical-button-background.png); background-repeat: repeat-y;&#125;::-webkit-scrollbar-track-piece:disabled &#123; display: none !important;&#125;::-webkit-scrollbar-track:vertical:disabled &#123; -webkit-border-image: url(resources/vertical-track-disabled.png) 13 0 13 0; border-color: transparent; border-width: 13px 0;&#125;/** 或者 **//*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/::-webkit-scrollbar&#123; width: 3px; height: 16px; background-color: rgba(255,255,255,0);&#125;/*定义滚动条轨道 内阴影+圆角*/::-webkit-scrollbar-track&#123; -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3); border-radius: 10px; background-color: rgba(255,255,255,0);&#125;/*定义滑块 内阴影+圆角*/::-webkit-scrollbar-thumb&#123; border-radius: 10px; -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3); background-color: #555;&#125; 样式滚动条"},{"title":"泰山随笔","path":"/2020/07/27/泰山随笔/","content":"上周日回了一趟家，晚上回到上海之后就在想一个问题：端午干嘛?是不是太无聊了? 好的直接计划泰山，周一确定计划，周二摇人买票，周三摸鱼，周四开冲！ 直接上午高铁出发了。 老刘这个家伙直接上了高铁就睡觉了，有点弱的不行！ 下次是哪次？改天是哪天？以后是多久？不管如何，干就完了。 到了泰安，天气不错哦~，但是已经下午四点了，怎么也得吃点东西再出发把？ 面27一碗，肉还是挺足的。大满足！ 如果火车的话，很近就能到泰山脚下，但是我们高铁，还是花35块钱打的吧。 车上还在说老刘不行，我在出租上也直接睡着了。被老刘这个逼给偷拍了。淦！ 我们上山走的是正经的红门路线。为什么叫红门呢？可能是因为房间都是红色的吧？ 照片里可能看不出来有多陡，但是看老刘的身高和台阶的比例就知道了吧？太抖了！还好我有偷偷锻炼，所以其实还行，但是老刘这个家伙就不行了，走一段路就啊啊啊不行了不行了。 然后看到前面有喜欢的妹妹也在走动，马上换了一副面孔，冲冲冲！我刘某又行了。 ![2bc5db6861fd512bebb390e105054c4.jpg][7] 一路载歌载舞，听刘某吹吹牛，还在想会不会遇到九龙拉棺。害就到了最难爬的十八盘 过了18盘。再过了一段几乎垂直的陡坡，终于上了南天门，见了“天宫” 到了南天门就顺便休息一下，跟同路的妹妹们聊一下天~ 但是这个时候才半夜12点，日出还有四小时呢怎么办呢？ 等等呗，顺便吹吹牛，在老刘去厕所的时候，他跟着的小姐姐去买东西吃，然后休息了，本来我们也准备这么做，但是找不到他们，然后随便找了一家店，点了一份十块钱的拉面，为什么拉面十块钱，泡面15，我想你们也应该猜出来味道怎么样了。太坑了。害 开始出发，日观峰。 走着走着，临近一点了，雾气越来越大了，感觉要开始下雨了，只能找个店家多一下雨，顺便小酣一下~ 雨过天晴，我觉得这次的日出好像稳了！ 去山顶的路上遇到了一个人在苏州读大学的妹子。第二次来泰山（一个人）太强了。随意聊了一下。很有感触。 好景不长，虽然到了日观峰，也差不多占了好位置，但是雾气越来越大了，风也越来越大。我一度怀疑自己会不会山东14天游！ 好的又开始下大雨了，被疏散了。。 行吧，本来六点半才营业的索道直接给我们五点半就开始营业了。下到半山，直接去了高铁站，买了最早的动车，出发，回家！ 虽然这次旅程略有遗憾，没有看到日出，但是我登顶了~也不虚此行。遇到了一些很有意思的人。"},{"title":"别让自己“墙”了自己","path":"/2020/07/27/别让自己“墙”了自己/","content":"[scode type&#x3D;”blue”]别限制了自己[&#x2F;scode] 这两天看了《富爸爸穷爸爸》粗略了解了财商，其实归根结底是提升自己的能力 也让自己的价值观具现化了[post cid&#x3D;”521” &#x2F;] 这些都是收获，不过今天看的这篇文章《别让自己“墙”了自己》，让我收获很大，以一个过来人的身份告诉我年轻人应该有什么优秀的品质，应该做怎么样的事情 做有价值的事 | 这个符合我的事业观:做对别人有价值事情 扩大自己的眼界，开放自己的内心 | 人生观和事业观 你的英文语言能力对你能不能融入世界是起决定性的作用 你的视野决定了你的知不知道要去哪，你的开放决定了你想不想去 站在更高的维度 | 思维方式 精于计算得失 | 《富爸爸穷爸爸》: 先支付自己的账单，再支付别人的账单 精于计算得失的，就懂得什么是投资，不懂的只会投机。对于赚钱，你可以投机，但是对于自己最好还是投资。 勇于跳出传统的舒服 | 改变的力量你真的喜欢改变吗？在正确的时间做正确的事情 井蛙不可以语于海者，拘于虚也；&#x2F;&#x2F;空间局限夏虫不可以语于冰者，笃于时也；&#x2F;&#x2F;时间局限曲士不可以语于道者，束于教也。&#x2F;&#x2F;认识局限 别自己墙了自己，人最可悲的就是自己限制自己，想都不敢想，共勉！ 别让自己“墙”了自己"},{"title":"将价值观显性化","path":"/2020/07/27/将价值观显性化/","content":"将价值观具现化，让我思考我应该恪守怎么样的价值观，遇到是非应该如何应对，这些都是我以前从来没有深入思考过的新方向。 见贤思齐，三省吾身！ 价值观 1.0版本 金钱观 穷人工作为之为钱，富人让钱为之工作。 时间观 时间是机会，培养能力的机会。浪费时间，就是浪费培养能力的机会，浪费成长的机会。 感情观 找一个相处舒服的人，一起成长。 事业观 做对别人有价值的事。 人生观 凡事多看，多想，多总结；活的不够久，哪里来的人生观？ 市场观 向市场交付有价值的产品，帮用户变得更好，陪用户一起成长。 亲情观 刚刚好的经济供需+源源不断的陪伴 工具观 工具能发挥程度取决于你的格局、高度和视野。 情绪观 情绪没有好坏，负面情绪是问题信号，正面情绪是动力源泉。利用好情绪，这是上天给你的外挂。 快乐观 快乐是一种多维情绪，包含情绪管理、自我认同和心存感恩。既然是能力，就能被培养，我要找到他的方法论。 能力观 能力&#x3D;50%认知+50%行动 价值观 观点无对错，你不用向别人证明你观点对错，你只要向别人证明你有能力，接纳、吸收、内化别人的观点，融成你自己的价值观 创业观 为他人提供便利，他人反馈与你收获。 欲望观 欲望是与生俱来的，稍加引导就能成为你达成目标的最佳助手 世界观 世界都没看过，哪来的世界观？"},{"title":"angular中使用canvas生成随机字符验证码","path":"/2020/07/21/angular中使用canvas生成随机字符验证码/","content":"没什么复杂的东西，旋转角度被我注释掉了，难度太大，酌情添加 随机生成6位带字母的随机数请看另一篇文章 [post cid&#x3D;”393” &#x2F;] HTML 1&lt;canvas (click)=&quot;getNewValidate()&quot;&gt;&lt;/canvas&gt; TS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private canvas: HTMLCanvasElement; //获取到canvas对象！ private context: CanvasRenderingContext2D; ngOnInit() &#123; this.initValidate(); this.getNewValidate(); &#125; public getNewValidate(): void &#123; this.context.clearRect(0, 0, 200, 40);//清除画布 this.getValidate();//生成一个六位数的验证码 this.drawPoint(100);//画100个干扰点 this.drawLine(8);//画8条干扰线 &#125; private initValidate(): void &#123; this.canvas = document.querySelector(&quot;canvas&quot;); this.canvas.width = 200;//设置canvas宽度 this.canvas.height = 40;//设置canvas高度 this.context = this.canvas.getContext(&quot;2d&quot;); //获取到canvas的绘图环境！ this.context.font = &quot;bold 20px 微软雅黑&quot;;//设置字体 this.context.strokeRect(0, 0, 200, 40);//绘制一个矩形框 &#125; private getValidate(): void &#123; const codeLibrary = Math.random().toString(36).substr(2, 6); //生成6位随机数带字母 console.log(codeLibrary); for (var i = 0; i &lt; 6; i++) &#123; const x = 20 + i * 20; const y = 20 + Math.random() * 10; const txt = codeLibrary[i];//获取到随机的内容 this.context.fillStyle = this.getColor();//设置字体颜色 this.context.translate(x, y);//字体移动 // const deg = 180 * Math.random() * Math.PI / 180; // this.context.rotate(deg);//字体随机旋转度数 this.context.fillText(txt, 0, 0);//将文字写到canvas上面 // this.context.rotate(-deg); this.context.translate(-x, -y); &#125; &#125; private drawPoint(X): void &#123; for (var i = 0; i &lt; X; i++) &#123; this.context.beginPath(); const x = Math.random() * 200; const y = Math.random() * 40; this.context.moveTo(x, y); this.context.lineTo(x + 1, y + 1); this.context.strokeStyle = this.getColor(); this.context.stroke();//开始绘制 &#125; &#125; private drawLine(m): void &#123; for (var i = 0; i &lt; m; i++) &#123; this.context.beginPath(); //开始一个路径 this.context.moveTo(Math.random() * 200, Math.random() * 40);//设置起点坐标 this.context.lineTo(Math.random() * 200, Math.random() * 40);//设置终点坐标 this.context.strokeStyle = this.getColor(); this.context.stroke();//开始绘制 &#125; &#125; private getColor(): string &#123; const r = Math.floor(Math.random() * 256); const g = Math.floor(Math.random() * 256); const b = Math.floor(Math.random() * 256); return &quot;rgb(&quot; + r + &quot;,&quot; + g + &quot;,&quot; + b + &quot;)&quot;; &#125; [scode type&#x3D;”blue”]当然我觉得也可以传入参数以及设置默认参数来实现自定义的功能。仁者见仁智者见智[&#x2F;scode]"},{"title":"遍历的区别","path":"/2020/07/13/遍历的区别/","content":"通俗来讲： for in 遍历对象，并且只会遍历可枚举对象[标识值（enumerable）为true]for of 遍历数组（但是，如果真是只遍历数组，建议使用原生forEach,性能更佳！） 12345678910111213141516171819Object.prototype.objCustom = function() &#123;&#125;; Array.prototype.arrCustom = function() &#123;&#125;;let iterable = [3, 5, 7];iterable.foo = &#x27;hello&#x27;;for (let i in iterable) &#123; console.log(i); // logs 0, 1, 2, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot;&#125;for (let i in iterable) &#123; if (iterable.hasOwnProperty(i)) &#123; console.log(i); // logs 0, 1, 2, &quot;foo&quot; &#125;&#125;for (let i of iterable) &#123; console.log(i); // logs 3, 5, 7&#125; 无论是for…in还是for…of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。 for…in 语句以任意顺序迭代对象的可枚举属性。 for…of 语句遍历可迭代对象定义要迭代的数据。 [scode type&#x3D;”yellow”]最核心的问题就是： 可枚举属性和可迭代对象是什么意思？[&#x2F;scode] 可枚举属性是指那些内部 “可枚举” 标志设置为 true 的属性，对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true，对于通过 Object.defineProperty 等定义的属性，该标识值（enumerable）默认为 false。 可迭代对象 JavaScript内置的数据结构都有其对应的迭代器实现，如果硬在数组中定义对象成员变量，可行是可行，但是，并不会被数组的迭代器调用。 举一个栗子： 12345678let demo = [1,2,3];demo.demo = &quot;demo&quot;;for(let value of demo) &#123; console.log(value); // logs: 1,2,3&#125;for(let value in demo) &#123; console.log(value); // logs: 0,1,2,demo&#125; [scode type&#x3D;”green”]创建空对象时，除非必要，否则务必使用Object.create(null)，原因就是原型链已被污染[&#x2F;scode] 12345Object.prototype.xxx = &quot;xxx&quot;;let Lindo1 = &#123;&#125;;for(let value in Lindo1) &#123; console.log(value); // logs: xxx &#125; 1234let Lindo2 = Object.create(null);for(let value in Lindo2) &#123; console.log(value); // logs: undefined&#125;"},{"title":"Angular-Cli","path":"/2020/05/22/Angular-Cli/","content":"目前公司的项目虽然都是Angular4（其实核心部分或者说cli还是1.0，我想是历史升级留下的问题），功能迭代几乎也不用到cli的大部分功能，导致我感觉已经遗忘了cli的便利，今天抽空回忆一番。 generatemodule–flat 不创建文件夹 –module demo 挂在demo module下面 –routing 创建路由文件 PS: 官方文档内的 –route不知道怎么使用，先记着。 component–flat 不创建文件夹 –inlineTemplate 内联模板 –inlineStyle 内联样式 –module demo 挂在demo module下"},{"title":"《英雄》-微观后感","path":"/2020/05/21/《英雄》-微观后感/","content":"前几日在短视频上刷到了这部电影，剪辑的很有看的欲望。 通篇想表达的意思也很明显英雄主义，当然本人以为除了大英雄主义，还有表现得不同小人物在自己的人生境地中表现出来的个人英雄主义。 残剑的天下为公，舍小痛而博大爱，是英雄主义，为了飞雪不惜收到伤害，也做到了爱情上的英雄。 无名为了报仇，苦练10年剑术，不敢有一丝懈怠。后面认同了残剑的国家大义，而舍生取义是英雄主义。 飞雪对赵国来说，是英雄，为了报灭国之仇，杀上殿前，为伴侣同赴死，是英雄（在当时的环境下）。 仆人，为了主人的目标，也坚定不移帮助主人，不惜付出生命，是英雄。 男下人，传承赵国的精神而在箭雨下屹然不动写字，跟随无名进殿，不惧生死也是英雄。 秦始皇，一扫六合，统一文字，度量衡，焚书坑儒，是英雄。 每个角色都在做自己的英雄，英雄这个词从来都在我们身边。 那我也能做自己的英雄吗？"},{"title":"前端如何优化首次渲染性能","path":"/2020/03/31/前端如何优化首次渲染性能/","content":"性能优化需求产生原因前端项目日益加大，并且三大框架Angular, Vue, React导致单页面应用(SPA)大行其道,小程序的日益化也导致现在前端需要优化项目的首次渲染速度。 如何优化，归根结底就是了解一个网页是如何渲染的，一个简单的网页渲染分为两个大步骤 文档对象模型DOM CSS对象模型CSSOM 网页的渲染步骤文件的获取DOM下图是浏览器获取网页DOM文件并渲染成DOM的步骤图 1. **转换：** 浏览器从网络或者本地磁盘读取HTML的原始字节，并根据文档的指定编码（such as utf-8 full-process.png转换成可视字符 令牌化 浏览器将字符转换成W3C HTML5 标准规定的各种令牌,例如 ，每个令牌都有其特殊意义和规则 词法分析 将令牌转化成定义其属性和规则的对象 DOM构建 HTML标记定义不同标记之间的关系，创建一个树形的主从关系，成为DOM树 CSSOM浏览器在构建页面时，从head标记中获取到了link标记，其引用了外部的样式 style.css, 会立即发起请求获取此css文件,例如 12345body &#123; font-size: 16px &#125;p &#123; font-weight: bold &#125;span &#123; color: red &#125;p span &#123; display: none &#125;img &#123; float: right &#125; PS: 诚然，直接使用内联CSS在速度让肯定比请求网络资源快，但是现代前端页面崇尚将内容与设计进行关注点分离；即设计人员专注于CSS，开发者侧重HTML 获取CSS文件之后，我们依旧需要讲CSS规则转换成浏览器能够理解和处理的东西，所以我们会重复HTML的步骤，不过主体变为了CSS。 cssom-construction.png 字节 &#x3D;&gt; 字符 &#x3D;&gt; 令牌 &#x3D;&gt; 节点 &#x3D;&gt; CSSOM [scode type&#x3D;”blue”]为什么是树形结构，是为了样式的继承即规则: “向下级联”[&#x2F;scode] cssom-tree.png 生成渲染树在完成DOM和CSSOM各自的转换之后，浏览器会把两者整合为渲染树 DOM和CSSOM合并后形成渲染树 渲染树只包含页面需要显示的部分 计算布局每一个对象的精确位置和大小 最后一个将像素渲染到屏幕上 渲染细节 从DOM树的根节点开始遍历每一个可见节点 某些节点不可见(脚本标记，元标记等)会被跳过忽略 设置了css隐藏样式的节点也会被忽略，例如display: none 为每一个可见的节点匹配其对应的CSSOM规则并应用它 讲可见节点整合进渲染树，包含其CSSOM规则和内容 布局知道了需要渲染的内容，还需要匹配屏幕，即将节点转换为屏幕上的像素点，这一步称为“栅格化”或“绘制” 执行渲染树构建、布局、绘制所需的时间取决于文档的大小、应用的样式以及硬件性能。 文档大小和时间成正比、样式复杂度和时间成正比、性能和时间成反比 总结步骤 处理HTML标记并构建DOM树 处理CSS标记并构建CSSOM树 将DOM和CSSOM合并为一个渲染树 根据渲染树来布局，并计算每个节点的几何信息 将节点绘制到屏幕上 [scode type&#x3D;”red”]请注意当CSSOM和DOM发生更改，上述所有步骤将会重新执行！[&#x2F;scode] 优化的关键就是最大限度缩短上述5步的时间开销 导致阻塞的原因阻塞渲染的CSS默认情况下，CSS会导致渲染的阻塞，即直至CSSOM构建完毕完成前，浏览器都不会渲染任何已处理的内容！ 我们知道在构建渲染树时，DOM和CSSOM必须同时存在。 HTML和CSSd都是阻塞渲染的资源, 但是从实际状况出来，HTML的优先级是强于CSS的,因为没有HTML等于没有需要展示的实质内容。 [scode type&#x3D;”share”]CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。[&#x2F;scode] 诚然，有些CSS样式只在某些特殊的情况下需要，比如打印和媒体查询,我们可以通过特殊的标识符来通知浏览器此资源不阻塞渲染 123&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;&lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 40em)&quot;&gt; [scode type&#x3D;”share”]请注意“阻塞渲染”仅是指浏览器是否需要暂停网页的首次渲染，直至该资源准备就绪。无论哪一种情况，浏览器仍会下载 CSS 资产，只不过不阻塞渲染的资源优先级较低罢了。[&#x2F;scode] 阻塞渲染的Javascriptjavascript可以修改页面的内容和样式和用户交互，当然它也会阻塞DOM构建和延缓页面的渲染，所以为了最佳的性能，我们应该让javascript异步执行，并使得页面渲染的关键路径中不要出现任何JavaScript [scode type&#x3D;”share”]一个重要事实：我们的脚本在文档的何处插入，就在何处执行。所以绝大多数JavaScript脚本的位置都在body标志的尾部[&#x2F;scode] 脚本在文档中的位置很重要 当浏览器遇到一个script标志时，DOM构建讲暂停，直至脚本运行结束 JavaScript可以查询DOM和CSSOM，并修改他们 JavaScript会在CSSOM就绪之后运行！ 默认情况下，内联和外部JavaScript都会暂停DOM的渲染，通过添加async关键字，可以大幅提升渲染性能 1&lt;script src=&quot;app.js&quot; async&gt;&lt;/script&gt; 如何监听网页渲染关键步骤通过浏览器的Navagation Timing Api捕获所有相关时间戳配合页面加载时其他浏览器事件，我们可以捕获并计算出到浏览器从获取第一批文档资源到页面展示完整的完整时间损耗 相关时间戳的含义 domLoading: 整个过程的起始时间戳，浏览器即将开始解析接受到的第一批HTML文档文件 domInteractive: 表示浏览器完成对所有HTML的解析并且DOM构建完成的时间点 domContentLoaded: 表示DOM准备继续并且没有样式表阻止JavaScript执行的时间点，即开始构建渲染树 许多JavaScript框架在等待此事件发生后再运行其本身的逻辑 domComplete: 顾名思义，所有事件完成，所有资源加载完成，即页面转环停止转动 loadEvent: 做为每个网页加载的最后一步，浏览器会触发onload事件 HTML 规范中规定了每个事件的具体条件：应在何时触发、应满足什么条件等等。对我们而言，我们将重点放在与关键渲染路径有关的几个关键里程碑上： domInteractive： 表示DOM准备就绪的时间点 domContentLoaded ： 一般表示DOM和CSSOM均准备就绪的时间点 如果没有阻塞解析器的JavaScript, 则DOMContentLoaded 将在domInteractive 后立即触发 因为一般来说css在文件中比JavaScript先获取 domComplete : 表示网页以及其所有子资源都加载完毕的时间点 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Critical Path: Measure&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script&gt; function measureCRP() &#123; var t = window.performance.timing, interactive = t.domInteractive - t.domLoading, dcl = t.domContentLoadedEventStart - t.domLoading, complete = t.domComplete - t.domLoading; var stats = document.createElement(&#x27;p&#x27;); stats.textContent = &#x27;interactive: &#x27; + interactive + &#x27;ms, &#x27; + &#x27;dcl: &#x27; + dcl + &#x27;ms, complete: &#x27; + complete + &#x27;ms&#x27;; document.body.appendChild(stats); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;measureCRP()&quot;&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 优化pageSpeed为了尽快完成首次渲染，我们需要最大限度减少以下三种可变因素: 关键资源的数量 关键路径的长度 关键字节的长度 关键资源是可能阻止网页首次渲染的资源 同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。 最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。 优化关键渲染路径的常规步骤如下： 对关键路径进行分析和特性描述：资源数、字节数、长度。 最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。 优化关键字节数以缩短下载时间（往返次数）。 优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。 JavaScript优化建议 优先异步JavaScript 避免使用同步服务器调用 延迟解析JavaScript 避免运行长时间的JavaScript CSS优化建议 将CSS置于Head标志内 避免使用CSS import 适当情况下使用内联CSS 优化关键渲染路径 补充: 回流和重绘在之前说到的浏览器绘制步骤中 回流:改变DOM的布局 重绘:改变DOM除布局以外的部分（颜色，透明度） 那么什么时候会触发回流和重绘呢？ 回流一定会触发重绘，而重绘不一定会触发回流！"},{"title":"TypeScript-interface和type的区别","path":"/2020/03/25/TypeScript-interface和type的区别/","content":"在ts中，定义类型由两种方式：接口（interface）和类型别名（type alias）interface只能定义对象类型，type声明的方式可以定义组合类型，交叉类型和原始类型如果用type alias 声明的方式，会导致一些功能的缺失1.interface方式可以实现接口的extends&#x2F;implements，而type 不行 2.interface可以实现接口的merge，但是type不行"},{"title":"Angular-监听文件上传进度","path":"/2020/03/20/Angular-监听文件上传进度/","content":"获取文件1&lt;input type=&quot;file&quot; (input)=&quot;inputFile(file.files[0])&quot; #file&gt; 服务12345678910111213141516171819202122232425262728293031323334uploadFile(file): Observable&lt;any&gt; &#123; const req = new HttpRequest(&#x27;POST&#x27;, &#x27;/upload/file&#x27;, file, &#123; reportProgress: true &#125;); return this.http.request(req).pipe( map(event =&gt; this.getEventMessage(event as HttpEvent&lt;any&gt;, file)), //这里ts编译时出了点类型错误，使用强制声明 tap(message =&gt; console.log(message)), last(), // return last (completed) message to caller catchError(this.handleError(file)) ); //也可以不用HttpRequest, 需要额外的ovserve: &#x27;events&#x27; return this.http.request(&#x27;POST&#x27;, &#x27;URL&#x27;, &#123; reprtProgress: true, ovserve: &#x27;events&#x27; , body: file&#125;).pipe(同上)&#125;private getEventMessage(event: HttpEvent&lt;any&gt;, file: File) &#123; switch (event.type) &#123; case HttpEventType.Sent: return `Uploading file &quot;$&#123;file.name&#125;&quot; of size $&#123;file.size&#125;.`; case HttpEventType.UploadProgress: // Compute and show the % done: const percentDone = Math.round(100 * event.loaded / event.total); return `File &quot;$&#123;file.name&#125;&quot; is $&#123;percentDone&#125;% uploaded.`; case HttpEventType.Response: return `File &quot;$&#123;file.name&#125;&quot; was completely uploaded!`; default: return `File &quot;$&#123;file.name&#125;&quot; surprising upload event: $&#123;event.type&#125;.`; &#125;&#125; 调用1this.uploadFile(file).subscribe( res =&gt; &#123;&#125;, error? =&gt; &#123;&#125;, compplete? =&gt; &#123;&#125;) 说点别的 RXJS操作符还有点不太熟悉，先会用，再考虑深入！ 下一篇文章写在下进度吧,应该同理，在options里面增加参数，并监听progress"},{"title":"逻辑运算符","path":"/2020/03/05/逻辑运算符/","content":"扒一扒逻辑运算符 第一阶段刚开始学逻辑运算符的时候 我们知道与或非 &#x3D;&gt; &amp;&amp; || ! [scode type&#x3D;”blue”]复杂点的与非或非以及相互转换这些我们暂时不去讨论[&#x2F;scode] 第二阶段熟悉了基础操作之后，我们又知道数据类型是可以相互转换的 数字，字符串，对象，函数，表达式，这些都可以使用使用逻辑运算符 1234let number: Number = 2020;if ((number &gt; 2019) === true) &#123; // ...ToDo&#125; 这样的基础表达式我们已经不屑于用了，会直接演变为 123if (number &gt; 2019) &#123; // ..ToDo&#125; 第三阶段用多了之后我们发现逻辑运算符还能进行短路操作，顿时感觉逼格高了，我也要这样玩 expr1 &amp;&amp; expr2 如果expr1为false则直接返回false,不进行expr2expr1 || expr2 如果expr1为true则直接返回true，不进行expr2 第四阶段1234console.log( null || &#x27;123&#x27;) // &#x27;123&#x27;console.log( null &amp;&amp; &#x27;123&#x27;) // nullconsole.log( undefined || &#x27;123&#x27;) // &#x27;123&#x27;console.log( undefined &amp;&amp; &#x27;123&#x27;) // undefined 上面的代码如果放在判断条件中，你肯定能一下说出来答案，但是输出呢？ 运算符 语法 说明 逻辑与，AND（&amp;&amp;） expr1 &amp;&amp; expr2 若 expr1 可转换为 true，则返回 expr2；否则，返回 expr1。 逻辑或，OR（丨丨） expr1 丨丨 expr2 若 expr1 可转换为 true，则返回 expr1；否则，返回 expr2。 逻辑非，NOT（!） !expr 若 expr 可转换为 true，则返回 false；否则，返回 true。 逻辑运算符-MDN"},{"title":"TS之this形参-即指定this类型","path":"/2020/03/03/TS之this形参-即指定this类型/","content":"在VS code 中 使用ts编码时写了一个很简单的代码: 1window.onmousedown = xxx 此时鼠标移动上来会出现类型推断的提示： 批注 2020-03-03 220407.png 这个时候我就在想： 两个参数吗？ 可是我们平时调用不就是一个Event对象传入吗？ 于是我就去翻阅资料 结论TS中可以使用this形参来指定当前函数的this对象 举个栗子 12345678function demo() &#123; console.log(this.length); //this并没有length这一方法，所以不会自动弹出联想&#125;function demo2(this: Array&lt;any&gt;)&#123; console.log(this.length)&#125; 但是需要注意的是，this形参只能在参数列表的第一个出现，并且只会在ts文件中出现，编译成js后并会有这个形参，只是辅助TS校验用 即：传递参数的时候跳过this 12345678function demo(this: void, arg:any) &#123; //这种情况即告诉编译器this不存在，无法调用this console.log(arg);&#125;//调用demo(&#x27;测试&#x27;); 所以图1的情况就是TS编译器在告诉我们此时函数的this上下文是什么(图中为GlobalEventHandlers或者重载的Window对象) 批注 2020-03-03 220913.png 说点别的 win10自带的截屏除了原来的PrintScrn 还可以使用win + shift + s 调出更加复杂的截图界面"},{"title":"查询字符串路由未传查询字符串会导致angular匹配不到路由","path":"/2020/03/02/查询字符串路由未传查询字符串会导致angular匹配不到路由/","content":"今天遇到一个搞笑的事情，项目里有一个路由 这个路由是需要传路由参数的，而路由参数由URL导入，因为我未传URL的相关参数，导致路由匹配时未匹配到我的参数，所以一直报错：“为匹配到路由” 我还在想怎么上周五还能运行，周一就不行了。 原来是angular的路由匹配的带路由参数匹配和不带路由参数匹配的问题（因为项目中我只写了带路由参数的匹配方式，所以不带路由参数的路由匹配不到） ps：补充一下官方的传递查询字符串的方式 12// Navigate to /results?page=1this.router.navigate([&#x27;/results&#x27;], &#123; queryParams: &#123; page: 1 &#125; &#125;); 路由参数直接在commands数组中一起传就行 又水了一篇文章走你 说点别的 好消息是国内新冠病毒提升的大趋势是放缓了怀消息是世界范围开始传播了 希望诸位2020活着度过！"},{"title":"前端接口二进制流文件保存文件","path":"/2020/02/28/前端接口二进制流文件保存文件/","content":"12345678910xxx.subscribe( (res) =&gt; &#123; let file = new Blob([result.body], &#123; type: result.body.type&#125;); let link = this.renderer2.createElement(&#x27;a&#x27;); let tempFile = window.URL.createObjectURL(file); this.renderer2.setAttribute(link, &#x27;href&#x27;, tempFile); this.renderer2.setAttribute(link, &#x27;download&#x27;, result.headers.get(&#x27;Content-Disposition&#x27;).split(&#x27;filename=&#x27;)[1]); link.click(); window.URL.revokeObjectURL(tempFile); //手动释放内存，必须&#125;) 服务层代码： Angular post 中 需要加上 &#123;responseType: &#39;blob&#39;, observe: &#39;response&#39;&#125; &#x2F;&#x2F;observe 返回完整的返回体 1234exportData(body: any): Observable&lt;HttpResponse&lt;Blob&gt;&gt; &#123; let url = &#x27;example.com/downloadApi&#x27;; return this.http.post(url, body, &#123; responseType: &#x27;blob&#x27; ， observe: &#x27;response&#x27;&#125;);&#125;"},{"title":"瞎猜抖音广告推广的算法","path":"/2020/02/27/瞎猜抖音广告推广的算法/","content":"起因今天早些时候，有妹子询问我想买电脑有什么推荐？我就在京东上帮着看了几个笔记本电脑。本来这是一件可有可无的事情。在下班路上刷抖音时，就变得不一样了起来。 竟然马上抖音就推到了我京东的广告，上面还精准的播放着我搜索以及停留的商品，这就引起了我的思考（当然可能还是我闲的） 抖音是怎么能精准的定位我的商品，包含切不仅限于京东。 猜测软件相互通信（打报告）因为接触过APP调用外部的APP的协议等类似方式，我怀疑是我查看商品时，被京东手机APP商品的埋点所定位了。然后京东APP后台调用抖音软件，进行私下传递信息 但是这种情况很快被我否决，这样的话，那哪天出来一个xxx软件都要这样传，软件不是臃肿的不行 账号关联很快我的猜测方向便转到了账号关联，我这些软件有什么相互关联的点呢？ 很快我就想到了手机号！现在很多软件都是需要绑定手机号的，或者干脆直接就只需要你手机接受验证码就能登录， 一般人肯定就主用一个手机号，那么会不会是我在浏览商品的时候，京东后台的埋点功能记录了我的需求，同步的推送的到抖音相关的推送环节。 很快我就开始了测试，在电脑端登录我的京东账号，并有规律的浏览一些我平时根本不会浏览的东西，然后开始刷抖音。 并不是 那么是不是因为网页版本的代码太老旧，以至于埋点功能还未完善呢？ 于是我又做出了一个假设：那我换个京东账号，不过还是在手机版本京东上进行测试 这样，我就能知道是在手机上的软件之间背着我进行了偷偷交流 ，还是我的浏览记录被传到了云端，为了防止失效性的问题，我接下来浏览的内容有意识的换了另外一块我完全不会接触的东西 并不是 好的。刷了大概5-10分钟，也并没有在抖音上推送我想了解的东西 还是猜测我想应该是通过账号关联，毕竟推送的内容是云端发送到本地的，还是得通过云端，本地只是记录数据。 电脑端和APP端都会有埋点，不过可能PC端的网站冗余度过高，没有APP端时效性快，所以导致推送不及时 杂谈这些内容只是瞎猜的，毕竟只是我一个人在试。"},{"title":"void操作符","path":"/2020/02/24/void操作符/","content":"今天在看ts转换JS的代码时 看到了一串代码 1a === void 0 ? x : m 顿时心生困惑，按照逻辑 void 0 应该等价于undefined ，可是我并没有遇到过void 0 这种情况，于是查阅了一下相关资料 void运算符可以执行右侧的表达式，返回值始终为undefined。 利用此运算符可以很便利的完成一些小操作，比如最为常见的取消链接跳转动作。 可以举一个极端的栗子： 123456console.log(void function()&#123; return &#x27;假装有输出&#x27;&#125;)// undefined 再举个耳熟能详的例子 1&lt;a href=&quot;javascript:void(0);&quot;&gt;Lindo&lt;/a&gt; 上述代码大家一定都不会陌生，点击它可以阻止链接的跳转动作。 用法非常简单，但是很多朋友并不太清楚其中的原理，下面分步进行一下介绍。 1.”JavaScript:”是一个协议，当触发元素时，会执行它后面的代码。2.如果协议后面代码返回undefined，则阻止元素的默认行为，比如点击链接，页面跳转就是默认行为。3.如果协议后面没有任何代码，相当于返回值为undefined，阻止元素的默认行为。4.如果协议后面有代码，那么将执行代码，用执行的代码替换页面中的内容，可能在不同的浏览器有所差别，比如&lt;a href=&quot;javascript:0;&quot;&gt;Lindo&lt;/a&gt;，在谷歌浏览器中没有任何动作，在火狐浏览器中会将页面内容替换为0，其他浏览器效果大家自行测试。"},{"title":"小试牛刀之使用指令完成clickOutSide功能","path":"/2020/02/19/小试牛刀之使用指令完成clickOutSide功能/","content":"前面提到了Angular的Directive指令。现在用指令完成一个小功能。 新建指令ng genrate directive directiveName 12345678@Directive(&#123; selector: &#x27;[appClickOutSide]&#x27;&#125;)export class ClickOutSideDirective &#123; constructor( ) &#123; &#125;&#125; 在构造函数中导入ElementRef来获取对实际DOM的引用 改造后👇 123456789@Directive(&#123; selector: &#x27;[appClickOutSide]&#x27;&#125;)export class ClickOutSideDirective &#123; constructor( private el: ElementRef ) &#123; &#125;&#125; [scode type&#x3D;”blue”]因为官方不推荐直接操控DOM，如果非要操控也建议使用Renderer2，这里因为只涉及判断是否当前宿主DOM所以不冲突[&#x2F;scode] 事件发射监听到宿主DOM以外的点击事件时。需要朝外部发射信号需要用到EventEmitter() 12@Output()public clickOutSide = new EventEmitter(); 绑定监听点击事件需要监听宿主外的点击事件这里需要用到 @Hostlisener修饰器,因为需要全局监听，这里用到@Hostlistener的document： || window:指令因为还需要判断当前点击DOM是否在宿主DOM内。用到了DOM-API的contains代码如下 12345678910111213141516171819202122import &#123; Directive, ElementRef, HostListener, Output, EventEmitter &#125; from &#x27;@angular/core&#x27;;@Directive(&#123; selector: &#x27;[appClickOutSide]&#x27;&#125;)export class ClickOutSideDirective &#123; constructor( private el: ElementRef ) &#123; &#125; @Output(&#x27;appClickOutSide&#x27;) public clickOutside = new EventEmitter(); @HostListener(&#x27;document:click&#x27;, [&#x27;$event.target&#x27;]) public onMouseClick(targetElement) &#123; const clickedInside = this.el.nativeElement.contains(targetElement); if(!clickedInside) &#123; this.clickOutside.emit(null); &#125; &#125;&#125; 调用html:&lt;p appHighlight (appClickOutSide)=&quot;demo(&#39;xxx&#39;)&quot;&gt;测试代码&lt;/p&gt;TS: 123demo(xx)&#123; console.log(&#x27;点击了外部&#x27;, xx); &#125; 因为指令中的EventEmitter弹出为NUll，这里可以附加自定义参数做更多事情."},{"title":"Angular中指令(directive)的初试","path":"/2020/02/19/Angular中指令-directive-的初试/","content":"指令的概要在Angular中有三种类型的指令： 组件–拥有模板的指令 结构型指令– 通过添加和移除DOM元素改变DOM布局的指令（NgFor、NgIf） 属性型指令 – 改变元素、组件或其他指令的外观和行为的指令（NgStyle） 创建一个简单的属性型指令1ng generate directive directive/hightlight //添加前置文件夹便于逻辑清理 @Directive 装饰器的配置属性中指定了该指令的 CSS 属性型选择器 [appHighlight] 这里的方括号([])表示它的属性型选择器。 Angular 会在模板中定位每个拥有名叫 appHighlight 属性的元素，并且为这些元素加上本指令的逻辑。 正因如此，这类指令被称为 属性选择器 。 把生成的指令控制器代码修改成这样： 12345678910import &#123; Directive, ElementRef &#125; from &#x27;@angular/core&#x27;;@Directive(&#123; selector: &#x27;[appHighlight]&#x27;&#125;)export class HighlightDirective &#123; constructor(el: ElementRef) &#123; el.nativeElement.style.backgroundColor = &#x27;yellow&#x27;; &#125;&#125; import 语句从 Angular 的 core 库中导入了一个 ElementRef 符号。 [post cid&#x3D;”358” &#x2F;] 你可以在指令的构造函数中使用 ElementRef 来注入宿主 DOM 元素的引用，也就是你放置 appHighlight 的那个元素。 ElementRef 通过其 nativeElement 属性给你了直接访问宿主 DOM 元素的能力。 这里的第一个实现把宿主元素的背景色设置为了黄色。 使用属性型指令1&lt;p appHighlight&gt;Highlight me!&lt;/p&gt; 相应用户使用的事件@HostListener 装饰器让你订阅某个属性型指令所在的宿主 DOM 元素的事件，在这个例子中就是 &lt;p&gt;。 [scode type&#x3D;”blue”]当然，你可以通过标准的 JavaScript 方式手动给宿主 DOM 元素附加一个事件监听器。 但这种方法至少有三个问题： 必须正确的书写事件监听器。 当指令被销毁的时候，必须拆卸事件监听器，否则会导致内存泄露。 必须直接和 DOM API 打交道，应该避免这样做。[&#x2F;scode] 下面是修改后的指令代码 directive.ts1234567891011121314151617181920import &#123; Directive, ElementRef, HostListener &#125; from &#x27;@angular/core&#x27;;@Directive(&#123; selector: &#x27;[appHighlight]&#x27;&#125;)export class HighlightDirective &#123; constructor(private el: ElementRef) &#123; &#125; @HostListener(&#x27;mouseenter&#x27;) onMouseEnter() &#123; this.highlight(&#x27;yellow&#x27;); &#125; @HostListener(&#x27;mouseleave&#x27;) onMouseLeave() &#123; this.highlight(null); &#125; private highlight(color: string) &#123; this.el.nativeElement.style.backgroundColor = color; &#125;&#125; 但是这样子并不灵活！这不可取。 使用@Input 数据绑定向指令传递值先从@angular&#x2F;core 中导入input 1import &#123; Directive, ElementRef, HostListener, Input &#125; from &#x27;@angular/core&#x27;; 然后把highlightColor属性添加到指令中 like this: 1@Input() hightColor: string; 绑定@Input 属性@Input 装饰器，它的作用是往类上添加了一些元数据，从而让该指令的lightLight 能用于绑定 模板代码： 12&lt;p appHighlight highlightColor=&quot;yellow&quot;&gt;Highlighted in yellow&lt;/p&gt;&lt;p appHighlight [highlightColor]=&quot;&#x27;orange&#x27;&quot;&gt;Highlighted in orange&lt;/p&gt; 问题来了，为什么要重复写，能不能整合呢？可以！@Input 提供了别名功能 最终版本控制器代码1234567891011121314151617181920212223242526import &#123; Directive, ElementRef, HostListener, Input &#125; from &#x27;@angular/core&#x27;;@Directive(&#123; selector: &#x27;[appHighlight]&#x27;&#125;)export class HighlightDirective &#123; @Input(&#x27;appHighlight&#x27;) highlightColor: string; constructor( private el: ElementRef ) &#123; &#125; @HostListener(&#x27;mouseenter&#x27;) onMouseEnter() &#123; this.highlight(this.highlightColor || &#x27;yellow&#x27;); //这里防止有些小可爱忘记传值OωO &#125; @HostListener(&#x27;mouseleave&#x27;) onMouseLeave() &#123; this.highlight(null); &#125; private highlight(color: string):void &#123; this.el.nativeElement.style.backgroundColor = color; &#125;&#125; 改动之后的调用方法 1&lt;p [appHighlight]=&quot;&#x27;red&#x27;&quot;&gt;Highlight me!&lt;/p&gt;"},{"title":"angular2+中使用renderer2代替原生js方法创建以及操控DOM对象","path":"/2020/02/13/angular2-中使用renderer2代替原生js方法创建以及操控DOM对象/","content":"[scode type&#x3D;”green”]今天遇到一个需要类似右击然后创建一个菜单的时候，陷入了误区，为什么要自己操控dom呢？angular明明优势就是数据操控视图，直接在页面的定义好对应的组件（不显示），直接通过数据控制不就行了吗？[&#x2F;scode] 1window.document.createElement() 这个基本大家都使用过虽然在angular中也能使用，不过因为逻辑上Angular以组件为单位划分，这其实是很不合理的，所以官方提供个封装好的方法给我们使用 let demo = this.renderer2.createElement(&#39;a&#39;);this.renderer2.appendChild(this.el.nativeElement, demo); [post cid&#x3D;”358” &#x2F;] 这里的el.nativeElement替代当前控制器所操控的实际DOM结构 请看下文 &#x2F;&#x2F;这里可以理解为当前组件ts 逻辑上的body部分 123456import &#123; Component, OnInit, AfterViewInit, ViewChild, ElementRef, Renderer2, OnDestroy &#125; from &#x27;@angular/core&#x27;;constructor( private renderer2: Renderer2, private el: ElementRef, ) &#123; &#125; 然后就是控制属性的code： 1this.renderer2.setAttribute(demo, &#x27;download&#x27;, this.pdfName); 移除DOM： 1this.renderer2.removeChild(this.el.nativeElement, tempLink); 聊点别的 从过年前的的不到一万，现在已经6w了。 2020计划: &#x3D;&gt; 活着"},{"title":"CSS控制页面的文字换行 &&  文本内容过多导致超出显示范围而使用省略号替代","path":"/2020/01/19/CSS控制页面的文字换行-文本内容过多导致超出显示范围而使用省略号替代/","content":"在一开始的学习过程中，我们遇到换行这种情况，大多都是采用强制换行就行。 但是在实际的生产环境中，难免需要考虑单词是否被换行所切割、单词间距、空格等因素。 现在来理一下那些控制文字的CSS3样式 文字种类“常识”CJK 文字和 !CJK 文字有各自的排版规则。 在这里，CJK 代表 Chinese, Japanese, and Korean，即东亚文字，!CJK 就是非东亚文字，大多数情况下是西欧文字。 在文字的呈现规则上，两者很不相同，CJK 文字中，一个字母就是一个字素（单词），独立成义，!CJK 文字中，一些字母组成一个字素，并且字素们由连接符“-”连接，或由空格“ ”分隔。 有关 CJK 文字更多的排版规则上，比较有代表性的是：对中文来说，标点符号不能成为行首（特殊除外）；双字长的标点符号（省略号、破折号）不能断开。对于 !CJK，主要是：单词不能在中间不合法地断开（合法情况例如从连接符处断开）；标点符号不能成为行首（特殊除外） 基础属性 属性 概要 word-brak 指定了怎样在单词内断行 overflow-wrap(别名word-warp) 用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。 white-space 设置如何处理元素中的 空白。 line-break 处理如何断开（break lines）带有标点符号的中文、日文或韩文（CJK）文本的行。 word-break normal 使用默认的断行规则。 break-all 对于non-CJK (CJK 指中文&#x2F;日文&#x2F;韩文) 文本，可在任意字符间断行, 即强制换行。 keep-all CJK 文本不断行。 Non-CJK 文本表现同 normal。 break-word 若剩下空间不够下一个单词，直接换行 overflow-wrap(word-warp) normal 表示在正常的单词结束处换行。 break-word 表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。 white-space normal 连续的空白符会被合并，换行符会被当作空白符来处理。换行在填充「行框盒子(line boxes)」时是必要。 nowrap 和 normal 一样，连续的空白符会被合并。但文本内的换行无效。 pre 连续的空白符会被保留。在遇到换行符或者元素时才会换行。 即照常输出 pre-wrap 连续的空白符会被保留。在遇到换行符或者元素，或者需要为了填充「行框盒子(line boxes)」时才会换行。 pre-line 连续的空白符会被合并。在遇到换行符或者元素，或者需要为了填充「行框盒子(line boxes)」时会换行。 break-spaces 与 pre-wrap的行为相同，除了: 任何保留的空白序列总是占用空间，包括在行尾。 每个保留的空格字符后都存在换行机会，包括空格字符之间。 这样保留的空间占用空间而不会挂起，从而影响盒子的固有尺寸（最小内容大小和最大内容大小）。 下面的表格总结了各种 white-space 值的行为： 换行符 空格和制表符 文字转行 normal 合并 合并 转行 nowrap 合并 合并 不转行 pre 保留 保留 不转行 pre-wrap 保留 保留 转行 pre-line 保留 合并 转行 break-spaces 保留 保留 转行 line-break auto 使用默认的断行规则分解文本。 loose 使用尽可能松散（least restrictive）的断行规则分解文本。一般用于短行的情况，如报纸。 normal 使用最一般（common）的断行规则分解文本。 strict 使用最严格（stringent）的断行原则分解文本。 anywhere 在每个印刷字符单元（typographic character unit）的周围，都有一个自动换行（soft wrap）的机会，包括任何标点符号（punctuation character）或是保留的空白字符（preserved white spaces），或是单词之间。但忽略任何用于阻止换行的字符，即使是来自 GL、WJ 或 ZWJ 字符集的字符，或是由 word-break 属性强制的字符。不同的换行机会拥有相同的优先级。也不应用断字符（hyphenation，可能是 “-“）。 英文原文：There is a soft wrap opportunity around every typographic character unit, including around any punctuation character or preserved white spaces, or in the middle of words, disregarding any prohibition against line breaks, even those introduced by characters with the GL, WJ, or ZWJ character class or mandated by the word-break property. The different wrapping opportunities must not be prioritized. Hyphenation is not applied. 总结用得到的还是 12word-break: break-word;overflow-wrap: break-word; 附带·文本超出附加省略号css 123456789101112131415161718多行.ellipsis&#123; text-overflow: -o-ellipsis-lastline; overflow: hidden; text-overflow: ellipsis; //省略号 display: -webkit-box; // -webkit-line-clamp: 1; //行数 -webkit-box-orient: vertical;&#125;单行：.new &#123; overflow:hidden; white-space: nowrap; text-overflow:ellipsis; width:100%; //或者具体大小&#125; 说点别的上海20号晚上确认已经确证2019新型冠状病毒这个年过的不平静啊赶紧买了点n95口罩狗命要紧(ó﹏ò｡) 链接: word-wrap 解惑"},{"title":"Angular4+中使用jsonp获取API数据","path":"/2020/01/09/Angular4-中使用jsonp获取API数据/","content":"导入AngularModule在 app.module.ts 中引入 HttpClientModule、HttpClientJsonpModule 并注入 1234567import &#123;HttpClientModule,HttpClientJsonpModule&#125; from &#x27;@angular/common/http&#x27;;imports: [ BrowserModule, HttpClientModule, HttpClientJsonpModule, ... needed-service.ts在用到的地方引入 HttpClient 并在构造函数声明 123456789import &#123; HttpClient &#125; from &#x27;@angular/common/http&#x27;;constructor( private http: HttpClient, ) &#123; &#125;demo(): Observable&lt;any&gt; &#123; return this.http.jsonp(`http://api.wipmania.com/jsonp`, &#x27;callback&#x27;) &#125; needed-component.tsjsonp 请求数据 123456789import &#123; needed-service &#125; from &#x27;xxx&#x27;;constructor( private needService: NeedService, ) &#123; &#125;demo() &#123;this.neededService.demo().subscribe( res =&gt; &#123;console.log(res);&#125;)&#125;"},{"title":"在Angular8中引入lodash","path":"/2019/12/25/在Angular8中引入lodash/","content":"npm安装1npm install lodash --save types定义TypeScript 的解決方案是另外使用 *.d.ts 。 一般来说，若是知名的 JavaScript library，都已经有人维护 type 定义包，其 package 的规则是 @types&#x2F;package 。 1npm install @types/lodash --save tsconfig.app.json1234567891011121314&#123; &quot;extends&quot;: &quot;./tsconfig.json&quot;, &quot;compilerOptions&quot;: &#123; &quot;outDir&quot;: &quot;./out-tsc/app&quot;, &quot;types&quot;: [&quot;swiper&quot;,&quot;lodash&quot;] //因为我项目还引入了swiper &#125;, &quot;include&quot;: [ &quot;src/**/*.ts&quot; ], &quot;exclude&quot;: [ &quot;src/test.ts&quot;, &quot;src/**/*.spec.ts&quot; ]&#125; ts文件中1import * as _ from &#x27;lodash&#x27;; 至此就能在ts中使用了 结论实际上若有 Angular 版本的 package，当然应优先使用；若遇到必须使用 JavaScript package 不可的场合，除了安装 package 外，还要安装 type 定义包，并在 tsconfig.json 设定，如此才可以在 Angular 正确使用并通过编译"},{"title":"Angular项目中引入Swiper轮播插件","path":"/2019/12/17/Angular项目中引入Swiper轮播插件/","content":"在网上找了很多资料，有的正确有的错误，当然最简单就是在index.html引入cdn 然后在ts文件中declare 一下，不过这种方法看上去就有点不是很正确，于是找一下相对正确的办法 npm 安装 swipernpm install swiper --save或者yarn add swiper --save 导入静态资源angular.json中添加css和js 1234567891011... &quot;styles&quot;: [ ... &quot;./node_modules/swiper/css/swiper.min.css&quot;, ... ], &quot;scripts&quot;: [ ... &quot;./node_modules/swiper/js/swiper.min.js&quot;, ... ] 安装模组定义档（暂时不知什么意思）npm install @types/swiper --save or yarn add @types/swiper --save 为你的库下载类型信息（npm install @types&#x2F;jquery），并按照库的安装步骤进行操作。这让你可以访问该库暴露出来的全局变量。2020&#x2F;7&#x2F;1 有了这个类型信息，就不用使用类似’declare var libraryName: any;’来申明类型了 配置tsconfig文件123&quot;typeRoots&quot;: [ &quot;node_modules/@types&quot;, ], tsconfig.app.json1&quot;types&quot;: [&quot;swiper&quot;] conponment.html12345678910111213141516&lt;div class=&quot;swiper-container&quot;&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot; *ngFor=&quot;let data of slides&quot;&gt; &lt;img [src]=&quot;data&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class=&quot;swiper-button-prev&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-next&quot;&gt;&lt;/div&gt; &lt;!-- 如果需要滚动条 --&gt; &lt;div class=&quot;swiper-scrollbar&quot;&gt;&lt;/div&gt; &lt;/div&gt; component.ts1234567891011121314151617181920212223242526272829303132333435363738394041424344import &#123; Component, OnInit, AfterViewInit &#125; from &#x27;@angular/core&#x27;;import Swiper from &quot;swiper&quot;;@Component(&#123; selector: &#x27;app-index&#x27;, templateUrl: &#x27;./index.component.html&#x27;, styleUrls: [&#x27;./index.component.css&#x27;]&#125;)export class IndexComponent implements OnInit,AfterViewInit &#123; swiper: Swiper; slides = [ &#x27;https://via.placeholder.com/300x200/FF5733/ffffff&#x27;, &#x27;https://via.placeholder.com/300x200/C70039/ffffff&#x27;, &#x27;https://via.placeholder.com/300x200/900C3F/ffffff&#x27; ]; constructor() &#123; &#125; ngOnInit() &#123; &#125; ngAfterViewInit() &#123; this.swiper = new Swiper(&#x27;.swiper-container&#x27;, &#123; direction: &#x27;horizontal&#x27;, loop: true, // 如果需要分页器 pagination: &#123; el: &#x27;.swiper-pagination&#x27;, &#125;, // 如果需要前进后退按钮 navigation: &#123; nextEl: &#x27;.swiper-button-next&#x27;, prevEl: &#x27;.swiper-button-prev&#x27;, &#125;, // 如果需要滚动条 scrollbar: &#123; el: &#x27;.swiper-scrollbar&#x27;, &#125;, &#125;); &#125;&#125; [scode type&#x3D;”blue”]具体的配置文档请移步官方[&#x2F;scode]API文档"},{"title":"在Angular中使用RxJS完成接口数据的缓存","path":"/2019/12/16/在Angular中使用RxJS完成接口数据的缓存/","content":"在实际项目中，很多共用的接口返回的数据是一样的，这样许多页面多次调用会造成性能浪费，可以使用RxJS的ReplaySubject(size)发送之前的旧值给新的订阅者。 用ReplaySubject(size)可以发送之前的旧值给新的订阅者，size是定义发送具体多少个旧值给新的订阅者。 shareReplay这个操作符会自动创建一个ReplaySubject，一旦http request执行一次以后，就会在后续的订阅和源头Observable之间建立一个ReplaySubject，ReplaySubject是一个多播的Hot Observable，后续订阅都是从这个中间ReplaySubject拿到最后一个值，从而达到缓存效果。 方法与正常调用服务层，相差无几，只是多了一个”中间商” 在cacheServices.ts中 1234567891011121314151617181920212223242526272829303132333435363738import &#123; Injectable &#125; from &quot;@angular/core&quot;;import &#123; HttpClient &#125; from &quot;@angular/common/http&quot;;import &#123; map, catchError, shareReplay &#125; from &#x27;rxjs/operators&#x27;;import &#123; of, Observable &#125; from &#x27;rxjs&#x27;;const CACHE_SIZE = 1;@Injectable()export class cacheServices&#123; private cacheTemp:Observable&lt;any&gt;; constructor(private http: HttpClient) &#123; &#125; chache() &#123; if(!this.cacheTemp)&#123; this.cacheTemp= this._chache() .pipe( shareReplay(CACHE_SIZE) ); &#125; return this.cacheTemp; &#125; private _chache() &#123; return this.http.get&lt;any&gt;(&quot;xxx&quot;) .pipe( map(respone =&gt; respone), catchError(error =&gt; &#123; console.log(&quot;something went wrong &quot; + error) return of([]); &#125;) ) &#125;&#125; 页面的第一个请求是调用API拿到信息，第二个调用，直接从cacheTemp拿到这个缓存信息。cacheTemp是ReplaySubject(1)把最后一个旧值（api return）发送给新的订阅者，从而实现了缓存效果。 RxJS：如何通过RxJS实现缓存"},{"title":"Angular8 创建惰性加载的特性模块","path":"/2019/12/10/Angular8-创建惰性加载的特性模块/","content":"借着这次重构项目的机会，复习一下以前并不怎么熟悉的方法步骤 建立应用 ： ng new customer-app --routing 建立一个带路由的特性模块 ： ng genetare module customer--routing CustomerModule CustomerRoutingModle CLI 会自动在CustomerModule中导入CustomerRoutingModule 主路由中配置路由 123456789101112const routes:Routes = [ &#123; path: &#x27;customer&#x27;, loadChildren: () =&gt; import(&#x27;./customers/customer.module&#x27;).then( mod =&gt; mod.CustomerModule) &#125;, ... &#123; path: &#x27;&#x27;, redirectTo: &#x27;&#x27;, pathMath: &#x27;full&#x27; &#125; ] 配置该特性模块的路由 123456789101112131415161718import &#123; NgModule &#125; from &#x27;@angular/core&#x27;;import &#123; Routes, RouterModule &#125; from &#x27;@angular/router&#x27;;import &#123; CustomerListComponent &#125; from &#x27;./customer-list/customer-list.component&#x27;;const routes: Routes = [ &#123; path: &#x27;&#x27;, component: CustomerListComponent &#125;];@NgModule(&#123; imports: [RouterModule.forChild(routes)], exports: [RouterModule]&#125;)export class CustomersRoutingModule &#123; &#125; [scode type&#x3D;”blue”]注意，path 被设置成了空字符串。这是因为 AppRoutingModule 中的路径已经设置为了 customers，所以 CustomersRoutingModule 中的这个路由定义已经位于 customers 这个上下文中了。也就是说这个路由模块中的每个路由其实都是子路由。[&#x2F;scode]"},{"title":"记录下工作中需要用到的GIT命令","path":"/2019/12/06/记录下工作中需要用到的GIT命令/","content":"这里记录一下日常工作中使用的到的git命令 git-zoom.png [scode type&#x3D;”blue”]关于git flow，新版本git已默认附带，使用需要初始化[&#x2F;scode] 指令 作用 git branch -d branch-name 删除本地分支 git branch -D branch-name 强制删除本地（没有合并的）分支 git push origin --delete name 删除远程分支 git tag -d v1.0 删除本地标签 git push origin --delete v1.0 删除远程标签 git remote prune origin –dry-run 清理无效的远程引用 git flow feature start branchname 开始 开发特性分支xxx git flow feature finish branchname 结束 开发特性分支xxx git flow release start releasename 开始 版本发布 git revert xx 撤销某一次提交 git merge --no-ff branchname 合并分支（禁用快进方式） git rebase branchname 变基， 优化提交次数，使用后切换分支再使用merge会变为快进提交！(只能在未发布远程的分支使用，否则人民会唾弃你)"},{"title":"前端捕获和抛出错误 try catch throw","path":"/2019/12/06/前端捕获和抛出错误-try-catch-throw/","content":"throw 抛出的问题是如何被捕获的？ 12345try &#123; // code&#125; catch (error) &#123; // 此时的error为上面try的错误信息, PS 在try中手动使用throw也会被catch 捕获到而进入到catch&#125; 如果，我再嵌套一层呢？ 1234567891011121314151617181920212223242526try &#123; //上面代码原封不动复制下来 try &#123; // code &#125; catch (error) &#123; // 此时的error为上面try的错误信息 &#125;&#125;catch (error) &#123; // 不会捕获到问题，因为错误已经正确抛出。try正常执行&#125;// 正确的调用顺序try &#123; try &#123; throw &#x27;error1&#x27; &#125; catch (error) &#123; // console.log(error) // error =&gt; error1 throw &#x27;error2&#x27; //下面的部分不会执行 code... // end &#125;&#125; catch (error) &#123; console.log(error) // error =&gt; error2&#125;"},{"title":"一个关于谷歌浏览器与其他浏览器图片显示有差异的问题","path":"/2019/11/26/一个关于谷歌浏览器与其他浏览器图片显示有差异的问题/","content":"今天在网站上发现有一张图片，在浏览器中显示是带有一丝黄色的背景色，下载后本地打开就是预期的蓝色背景色。 后来研究发现是谷歌浏览器的图片显示问题(后期可能修复)。应该是图片的RGB设置问题，用火狐浏览器查看相应图片显示正常！ [scode type&#x3D;”blue”]可以用不同浏览器查看本图片[&#x2F;scode] 49b8b710-ac2c-432c-a120-41514ecc3637.jpg 解决方案"},{"title":"一些JS的小技巧","path":"/2019/11/21/一些JS的小技巧/","content":"javascript.jpg 快速生成6位验证码1Math.random().toString(36).substr(2, 6); 转换数字123const number = &#x27;10&#x27;;number = +number;console.log(number); // 10 1234// 强制取整 ， 带有强制的类型转换，非法的转换之后取0const number = &#x27;10&#x27;;number = ~~number;console.log(number); // 10 快速浮点转整型123// 浮点不能进行或运算，所以会取整，或0保持不变console.log(10.9 | 0); // 10console.log(-10.9 | 0); // -10 123// 强制取整 ， 带有强制的类型转换，非法的转换之后取0console.log(~~10.9);console.log(~~-10.9); 数组降维二维数组12345678910let arr = [ [1], [2], [3] ];arr = Array.prototype.concat.apply([], arr);console.log(arr);// [1, 2, 3]//flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。//var newArray = arr.flat([depth])let array = [ [1], [2], [3] ];array = array.flat(2);console.log(array); // [1, 2, 3] 多维数组123let arrMore = [1, 2, [3], [[4]]];arrMore = arrMore.flat(Infinity); ///全局属性 Infinity 是一个数值，表示无穷大。console.log(arrMore); 判断小数是否相等12345// 原理为判断实际差值是否小于阈值function equal(number1, number2) &#123; return Math.abs(number1 - number2) &lt; Math.pow(2, -52);&#125;console.log(equal(0.1 + 0.2, 0.3)); 判断变量是否为数组123451. instanceof2. array.__proto__.constructor === Array3. array.constructor === Array4. Array.isArray（兼容性问题）5. Object.prototype.toString.call([]) === &quot;[object Array]&quot;（最通用） //同理和可以判断任意其他类型 PS：instanceof和constructor判断的变量，必须在当前页面声明。例如：父页面是一个框架，框架中引入一个页面（子页面），在子页面中申明的array，并将其复制给父元素的一个变量，这时instanceof和constructor判断该变量，将返回false。—————————————————————————————————————– 原因： array是复合类型。在传递的过程中，仅仅是引用地址的传递。每个页面的array原生对象引用的地址是不一样的，在子页面中声明的array，所对应的构造函数，是子页面的array对象，在父页面进行判断时，使用的并不是子页面的array。 数组去重12345Array.prototype.unique = function() &#123; return [...new Set(this)];&#125;var array = [1, 2, 3, 43, 45, 1, 2, 2, 4, 5];array.unique(); 短路运算符 &amp;&amp; ||使用&amp;&amp;将返回第一个条件为假的值。如果每个操作数的计算值都为true，则返回最后一个计算过的表达式。123let one = 1, two = 2, three = 3;console.log(one &amp;&amp; two &amp;&amp; three); // 3console.log(0 &amp;&amp; null); // 0 使用||将返回第一个条件为真的值。如果每个操作数的计算结果都为false，则返回最后一个计算过的表达式。123let one = 1, two = 2, three = 3;console.log(one || two || three); // 1console.log(0 || null); // null 过滤空值12let result1 = [1, 2, 0, undefined, null, false, &#x27;&#x27;].filter(Boolean);console.log(result1); 合并对象12345const person = &#123; name: &#x27;David Walsh&#x27;, gender: &#x27;Male&#x27; &#125;;const tools = &#123; computer: &#x27;Mac&#x27;, editor: &#x27;Atom&#x27; &#125;;const attributes = &#123; handsomeness: &#x27;Extreme&#x27;, hair: &#x27;Brown&#x27;, eyes: &#x27;Blue&#x27; &#125;;const summary = &#123; ...person, ...tools, ...attributes &#125;;console.log(summary); 字符串去空格123String.prototype.trim = function()&#123;return this.replace(/^\\s+|\\s+$/g, &quot;&quot;);&#125;;//去两端 string.trim()"},{"title":"对象转原始类型是根据什么流程运行的？","path":"/2019/11/08/对象转原始类型是根据什么流程运行的？/","content":"对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下： 1.如果Symbol.toPrimitive()方法，优先调用再返回2.调用valueOf()，如果转换为原始类型，则返回3.调用toString()，如果转换为原始类型，则返回4.如果都没有返回原始类型，会报错 12345678910111213var obj = &#123; value: 3, valueOf() &#123; return 4; &#125;, toString() &#123; return &#x27;5&#x27; &#125;, [Symbol.toPrimitive]() &#123; return 6 &#125;&#125;console.log(obj + 1); // 输出7 ps:如何让if(a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2)条件成立？ 12345678var a = &#123; value: 0, valueOf: function() &#123; this.value++; return this.value; &#125;&#125;;console.log(a == 1 &amp;&amp; a == 2);//true"},{"title":"使用JS检测协议是否存在","path":"/2019/11/08/使用JS检测协议是否存在/","content":"[scode type&#x3D;”yellow”]移动点击打开软件或跳转至应用商城推荐使用，PC端使用不多[&#x2F;scode] 移动端开发，一个绕不开的问题就是，如何在H5页面中，把用户引流到自家的APP中，现通用的方法如下图所示： 微信图片_20191108101934.jpg 最上方可关闭提示，为Safari自带的应用商店功能标签，实现方法为添加&lt;meta&gt;标签。↓ 123&lt;meta name=&#x27;apple-itunes-app&#x27; content=&#x27;app-id=477927812&#x27;&gt; &lt;!-- 上面的方法仅限于iOS设备，且无法定义Banner的形式。另外打开应用时也无法告诉App端要做什么操作。 --&gt; &lt;!-- app-id 对应 App Store里面ID，我使用的百度贴吧的ID--&gt; 页面浮动在底部App内打开为普遍方法，样式可能会因站而异，但原理相同，话不多说直接上code [scode type&#x3D;”share”]protocolcheck[&#x2F;scode] Examp.html 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Custom Protocol Detection&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Click one of these labels:&lt;/h1&gt; &lt;div href=&quot;blahblah:randomstuff&quot;&gt;虚假url &lt;/div&gt; &lt;div href=&quot;mailto:johndoe@somewhere.com&quot;&gt;真实url &lt;/div&gt; &lt;script src=&quot;https://code.jquery.com/jquery-1.11.2.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;protocolcheck.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;example.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Example.js 123456789$(function () &#123; $(&quot;div[href]&quot;).click(function (event) &#123; window.protocolCheck($(this).attr(&quot;href&quot;), function () &#123; alert(&quot;url无效！&quot;); &#125;); event.preventDefault ? event.preventDefault() : event.returnValue = false; &#125;);&#125;); [scode type&#x3D;”blue”]是否需要使用Jquery因人而异，请根据自身项目自行决定，事件绑定方法，也请根据页面情况自行修改！[&#x2F;scode]"},{"title":"GET和POST两种基本请求方法的区别","path":"/2019/10/22/GET和POST两种基本请求方法的区别/","content":"GET和POST两种基本请求方法的区别GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。 最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。 你可能自己写过无数个GET和POST请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。 当你在面试中被问到这个问题，你的内心充满了自信和喜悦。 640.jpg 你轻轻松松的给出了一个“标准答案”： GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 （本标准答案参考自w3schools） “很遗憾，这不是我们要的回答！” 640 (3).jpg 请告诉我真相。。。 如果我告诉你GET和POST本质上没有区别你信吗？ 让我们扒下GET和POST的外衣，坦诚相见吧！ 640 (4).jpg GET和POST是什么？HTTP协议中的两种发送请求的方法。 HTTP是什么？HTTP是基于TCP&#x2F;IP的关于数据如何在万维网中如何通信的协议。 HTTP的底层是TCP&#x2F;IP。所以GET和POST的底层也是TCP&#x2F;IP，也就是说，GET&#x2F;POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 那么，“标准答案”里的那些区别是怎么回事？ 640 (2).jpg 在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。 但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？ 640 (1).jpg 在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。 好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 你以为本文就这么结束了？ 0.png 我们的大BOSS还等着出场呢。。。 这位BOSS有多神秘？当你试图在网上找“GET和POST的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢。。。 GET和POST还有一个重大区别，简单的说： GET产生一个TCP数据包；POST产生两个TCP数据包。 长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 现在，当面试官再问你“GET与POST的区别”的时候，你的内心是不是这样的？ 640.jpg 结束！！！ 来源：99%的人都理解错了HTTP中GET与POST的区别"},{"title":"在Angular中定位原生html元素","path":"/2019/10/09/在Angular中定位原生html元素/","content":"基于某些特殊情况，在使用框架时，或者历史遗留问题，还是需要操作DOM对象 此时可在DOM上添加模板引用变量 # 来标识DOM对象 1&lt;input #phone placeholder=&quot;phone number&quot; (click)=&quot;method(phone.value)&quot;&gt; 在控制器TS文件中怎么引用呢？ @viewChild(‘phone’) private phone: any; &#x2F;&#x2F;这里实际类型为下文的ElementRef 1this.phone.nativeElement.setAttribute(&#x27;style&#x27;, `margin-left:$&#123;-(this.selectedIndex + 1 - this.showNumber) * 70&#125;px`); this.phone.nativeElement即为DOM对象 信息补全ElementRef 对视图中某个原生元素的包装器。 1234class ElementRef&lt;T&gt; &#123; constructor(nativeElement: T) nativeElement: T&#125; 属性 说明 nativeElement: T [scode type&#x3D;”red”]当需要直接访问 DOM 时，请把本 API 作为最后选择。优先使用 Angular 提供的模板和数据绑定机制。或者你还可以看看 Renderer2，它提供了可安全使用的 API —— 即使环境没有提供直接访问原生元素的功能。 如果依赖直接访问 DOM 的方式，就可能在应用和渲染层之间产生紧耦合。这将导致无法分开两者，也就无法将应用发布到 Web Worker 中。[&#x2F;scode]"},{"title":"在angualr8.0版本使用echarts插件","path":"/2019/10/09/在angualr8-0版本使用echarts插件/","content":"公司需求使用到图标功能，正好水一篇文章→_→ 1.npm 安装 ECharts 在 3.1.1 版本之前 ECharts 在 npm 上的 package 是非官方维护的，从 3.1.1 开始由官方 EFE 维护 npm 上 ECharts 和 zrender 的 package。你可以使用如下命令通过 npm 安装 ECharts npm install echarts --save 2.引入 ECharts 通过 npm 上安装的 ECharts 和 zrender 会放在node_modules目录下。可以直接在项目代码中 require(‘echarts’) 得到 ECharts。 1234567891011121314151617181920import * as echarts from &#x27;echarts&#x27;// 基于准备好的dom，初始化echarts实例var myChart = echarts.init(document.getElementById(&#x27;main&#x27;));// 绘制图表myChart.setOption(&#123; title: &#123; text: &#x27;ECharts 入门示例&#x27; &#125;, tooltip: &#123;&#125;, xAxis: &#123; data: [&#x27;衬衫&#x27;, &#x27;羊毛衫&#x27;, &#x27;雪纺衫&#x27;, &#x27;裤子&#x27;, &#x27;高跟鞋&#x27;, &#x27;袜子&#x27;] &#125;, yAxis: &#123;&#125;, series: [&#123; name: &#x27;销量&#x27;, type: &#x27;bar&#x27;, data: [5, 20, 36, 10, 10, 20] &#125;]&#125;); 有些教程需要本地加载静态文件在.angular-cli.json中的scrtpt 或者在 index.html 中导入js文件。不过并不是所有的页面都需要用到，所以并不是太聪明的办法。不过大多与情况下，Done is better than perfect."},{"title":"假如自己完成一个抖音的推送算法，该如何实现","path":"/2019/09/12/假如自己完成一个抖音的推送算法，该如何实现/","content":"初级版本（自我设想）昨天无意间和朋友聊到了算法，就猜想了一下抖音的推送算法。 在没有研究过抖音的算法的前提下，首先就是联想到标签分类制；视频被打了n中标签，根据对应标签，推送至对应的用户。 视频如何打标签？（标签都有自身的权重，具体权重的多少不进行探讨）我的解决方案是：根据图像识别进行初步的判断视频属于风景、人文、科普、歌曲； 根据音频进行分类； 根据音频内容转义语言内容获取关键字（一般视频开头就有整个视频的主题）；这是初步的标签； 后期用户体量上升，用户就会自带一些用户标签，视频根据何种类别的用户观看比例，进行分类标签。 这样视频和用户即完成了双向辅助标签分类。 如何推送？解决了视频以及用户的标签打分之后。 推送的最高级肯定是标签符合率最高的视频和用户进行串联，不过这样的情况肯定是属于少数。所以就要考虑模糊匹配。 比如本次推送5个视频，算法根据用户标签，得出用户标签的权重中： 狗（40%），风景（20%），人物（10%），其他（30%）[其他这里不做具体展开，肯定还是具体的标签]，当然想到这里，人总是会变得：所以我可能今天喜欢你的视频，明天我又喜欢别人的视频了。 所以标签的权重需要根据所展开的视频所预留的锚点进行重新计算&amp;更改（当然肯定是一个时间周期所要进行的）。 这样推荐算法模拟出该用户本次推送5条视频（其中包括3条狗狗视频，1条风景视频，一条人物视频），从本次推送周期的数据库（下文描述何为本次推送周期）中拉取相关联的视频数据进行推送。 当然我描述的标签肯定太过于简单。不过只是数量级别的不同。或许会有大类小类的关系。不过核心是一致的。 如何解决推送重复？中所周知：用户肯定不希望重复的东西出现，我这里的重复是指一模一样的视频，而不是类似的视频。 所以在一番思考之后我引入了本次推送周期这个概念：用户推送的数据库是在一定周期内发生改变的。比如24小时、6小时、甚至15分钟？这就需要具体情况具体分析。就我个体用户而言，在一个推送周期内的视频总量已经足够多，以至于不会发生重复（当然可以扩展至每个分类都有其推送周期库）&lt;推送周期不会推送旧内容，需考虑时效性&gt; 想推送周期这个概念的时候，我本意是防止用户单独点开某个短视频博主的作品集去观看作品，这个时候用户肯定不希望在首页推送的时候，推送到该条视频。 但推送必然会导致所关注的用户发布或曾发布内容推送到用户手上 初步设想是进行用户关注的博主以及其发布作品，观看记录保存在客户机，推送时，先进行校验，若重复，则重新拉取相同性质的其他视频重复进行校验判断； 当然，用户本次推送周期所观看的所有视频ID都会进行保存，在进行推送的时进行校验，这样双重保护，基本可以杜绝视频重复的问题（推送周期库的内容不会重复，单独关注的用户的视频也不会重复） 至此初级版本的算法过程已经完成。之后看情况进行后续跟进φ(￣∇￣o)"},{"title":"angualr4创建统一http拦截器","path":"/2019/09/05/angualr4创建统一http拦截器/","content":"意义很多API都需要权限校验，所以在全局设置一个http的拦截器进行权限控制 intercept.ts[scode type&#x3D;”blue”]AuthService 、NzMessageService 是项目中的权限组件和消息提示组件。[&#x2F;scode] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import &#123; Injectable &#125; from &#x27;@angular/core&#x27;import &#123; HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpResponse, HttpErrorResponse &#125; from &#x27;@angular/common/http&#x27;;import &#123; Observable &#125; from &#x27;rxjs&#x27;;import &#123; tap &#125; from &#x27;rxjs/operators&#x27;;import &#123; AuthService &#125; from &#x27;../service/auth/auth.service&#x27;;import &#123; Router &#125; from &#x27;@angular/router&#x27;;import &#123; NzMessageService &#125; from &#x27;ng-zorro-antd&#x27;;@Injectable()export class Interceptor implements HttpInterceptor &#123; constructor( private authService : AuthService, private router: Router, private message: NzMessageService, )&#123;&#125; intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; // -1- 从auth服务中获取用户信息 const authToken = this.authService.getInfo()?this.authService.getInfo().token : null; // -2- 克隆请求并替换掉(前提是获取到用户信息) let authReq = req.clone();; if (authToken) &#123; authReq = req.clone(&#123; headers: req.headers.set(&#x27;Authorization&#x27;, authToken), &#125;); &#125; return next.handle(authReq).pipe( tap((event: HttpEvent&lt;any&gt;) =&gt; &#123; if (event instanceof HttpResponse) &#123; // do stuff with response if you want // 接口错误 if (event.body[&#x27;Success&#x27;] === false) &#123; this.message.error(event.body.Message == &#x27;&#x27; ? &#x27;Interface error&#x27; : event.body.Message); &#125; &#125; &#125; , (err: any) =&gt; &#123; if (err instanceof HttpErrorResponse) &#123; if (err.status === 401 || err.status === 400) &#123; // redirect to the login route // or show a modala // console.log(&#x27;401&#x27;); this.router.navigate([&#x27;/welcome&#x27;]); // window.location.href=&quot;https://eip.bestwaycorp.com/&quot;; &#125; &#125; &#125; ) ); &#125;&#125; index.ts(模块化)目录结构 http-intercept index.tsintercept.ts 1234567import &#123; HTTP_INTERCEPTORS &#125; from &#x27;@angular/common/http&#x27;;import &#123; Interceptor &#125; from &#x27;./intercept&#x27;;export const httpInterceptorProviders = [ &#123; provide: HTTP_INTERCEPTORS, useClass: Interceptor, multi: true &#125;,] 然后在app.module.ts的providers 123import &#123; httpInterceptorProviders &#125; from &#x27;./http-intercept/index&#x27;;providers: [httpInterceptorProviders] 或者无须index.ts直接在app.module.ts中 12345import &#123;HTTP_INTERCEPTORS&#125; from &quot;@angular/common/http&quot;;providers: [ &#123;provide:HTTP_INTERCEPTORS,useClass:Interceptor ,multi:true&#125; ], [scode type&#x3D;”blue”]以上内容Angular4支持，其他版本请测试后使用！[&#x2F;scode]"},{"title":"尝试自己调用原生JS完成控制table的相关操作，配合H5的自定义属性完成条件控制","path":"/2019/09/04/尝试自己调用原生JS完成控制table的相关操作，配合H5的自定义属性完成条件控制/","content":"入行也快一年了，用的最多都是第三方的插件，虽然最近也有在看源码，不过刚好有个类似的需求，花了个把小时做了个demo然后水篇博客😁 因为热爱，所以热爱。 创建元素一般比如说自己手动创建一个表格 创建table 创建tr 创建td 追加td到tr ps:防止多次重绘影响性能，一次性在js中完成DOM然后一次添加 追加tr到table或tbody中 这是我所知道的流程。使用的到的原生js也不过几个 window.document.createElement(&#39;elementName&#39;); Element.appendChild()| Element.append 后者可以一次多个，不过还有些缺陷问题，建议appendchild 模块化既然准备自己造轮子，那么就肯定得灵活一点。那我就传入一个数组对象。一个对象是其中的一行，或者数组数组，能支持遍历，有规律就行 函数：创建行数组1234567891011121314151617// 创建tr 根据数组对象创建对应的列 function _create_tr(dataList)&#123; let _trNodeList = []; // 这里应该是NodeList对象的，不过我不会创建。也比较赶时间做demo就用数组代替了 for(let _i = 0; _i &lt; Object.keys(dataList).length; _i++)&#123; // 这里先循环出tr行 // 先创建行 let _tr = window.document.createElement(&#x27;tr&#x27;); // 创建列, 遍历属性创建列 let tdList = Object.keys(dataList[_i]); //列名集合 for( let __i = 0; __i &lt; tdList.length; __i ++)&#123; let __td = window.document.createElement(&#x27;td&#x27;); __td.innerHTML = `$&#123;dataList[_i][tdList[__i]]&#125;`; _tr.appendChild(__td); &#125; _trNodeList.push(_tr); //推进数组 &#125; return _trNodeList; &#125; 函数：在表格某一行下方添加表格行[scode type&#x3D;”share”]关于下方用到的API https://www.w3.org/TR/html50/tabular-data.html#dom-tr-rowindex[/scode] 1234567891011121314151617/** *获取Nodelist 添加至 目标元素下方 *targetNode 目标行tr */ function _append_tr(NodeList, targetNode) &#123; // 1. 获取targetNode 在第几行 let _trIndex = targetNode.rowIndex; // 2. 获取targetNode 的父元素 let _trParent = targetNode.parentNode; // 3. 记录下添加了几行，以及相对应的状态 targetNode.dataset.isExpend = true; targetNode.dataset.rowsCount = NodeList.length; NodeList.forEach( Node =&gt; &#123; let tempTr = _trParent.insertRow(_trIndex++); tempTr.innerHTML = Node.innerHTML; &#125;) &#125; 函数：删除某一行开始的几行为了满足需求的添加和删除行 123456789101112131415161718192021/** *删除对应行下面的 某些行 * */ function _remove_tr(targetNode, rowsCount = 0) &#123; // 1. 判断是否传值 rowsCount,本程序是先添加再删除。这里的步骤对应上面的第三步 if (rowsCount === 0 &amp;&amp; targetNode.dataset.rowsCount) &#123; rowsCount = targetNode.dataset.rowsCount; &#125; // 2. 定位父元素 let _trParent = targetNode.parentNode; // 3. 定位当前元素 let _trIndex = targetNode.rowIndex; // 4. 删除行 for( let _i = 0; _i &lt; rowsCount; _i++) &#123; _trParent.deleteRow( _trIndex); //这里index不需要动。因为删除之后后面的会自动前移 &#125; // 5. dataset参数设置 targetNode.dataset.isExpend = false; delete targetNode.dataList.rowsCount; &#125; demo12345678910111213let demoData = [&#123;name: &#x27;C&#x27;, age: &#x27;3&#x27;&#125;, &#123;name: &#x27;D&#x27;, age: &#x27;4&#x27;&#125;]; // 绑定点击事件 let trs = window.document.querySelectorAll(&#x27;tr&#x27;); trs.forEach( Node =&gt; &#123; Node.addEventListener(&#x27;click&#x27;, function($event)&#123; if ($event.target.parentNode.dataset.isExpend === &quot;true&quot;) &#123; _remove_tr($event.target.parentNode); &#125; else &#123; _append_tr(_create_tr(demoData), $event.target.parentNode); &#125; &#125;) &#125;) 小总结一下虽然第三方的库基本可以覆盖到方方面面了。几年前会jQuery好像就可以走遍天下都不怕了。但是现在ui库，js库多如牛毛。框架功能也越来越强大。但是归根到底还是取决于浏览器的API。希望在以后的开发和学习中。不忘最基本的原生JS，当然不会后端的前端不是一个好光头（再底层就先不考虑了😂）"},{"title":"「交叉观察者」实现懒加载、触底、吸顶等操作","path":"/2019/08/29/「交叉观察者」实现懒加载、触底、吸顶等操作/","content":"说到 懒加载、 菜单吸顶、触底等操作，一般方法是监听浏览器的滚动条，满足条件触发相应的事件。 IntersectionObserver 交叉观察者，现在可以优雅的完成类似的操作。 介绍 IntersectionObserver接口 (从属于Intersection Observer API) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。祖先元素与视窗(viewport)被称为根(root)。 大白话就是异步的监听被观察对象与其祖先元素或者顶级视窗（默认）是否交叉. 用法1.构造函数1new IntersectionObserver(callback, options); 2.callbackcallback 接受2个参数 entries &amp; observer entries: 当前已监听并且发生了交叉的目标集合observer:被调用的IntersectionObserver实例本身 一般用不到，可以不传 1234new IntersectionObserver((entries, observer) =&gt; &#123; entries.forEach(item =&gt; console.log(item, observer)); // ...&#125;); 看看 item 的常用属性及其说明 属性 说明 boundingClientRect 目标元素的边界信息 intersectionRatio 元素可见区域的占比 isIntersecting 目标元素与交叉区域观察者对象的根是否相交 time 从时间原点(time origin)到交叉被触发的时间的时间戳 target 目标元素 [scode type&#x3D;”yellow”]页面初始化时会触发一次callback， entries 为所有目标元素的集合[&#x2F;scode] 2.option参数列表，非必填 属性 说明 root 指定父元素，默认为视窗 rootMargin 触发交叉的偏移值，默认为”0px 0px 0px 0px”（上左下右，正数为向外扩散，负数则向内收缩） 1234new IntersectionObserver(callback, &#123; root: document.querySelector(&quot;xx&quot;), rootMargin: &quot;0px 0px -100px 0px&quot;&#125;); 如果设置rootMargin为”20px 0px 30px 30px”，那么元素未到达视窗时，就已经切换为可见状态了： 3.方法 方法名 说明 disconnect() 停止监听工作（参数节点） observe() 开始监听一个目标元素（参数节点） takeRecords() 返回entris所有数组对象 unobserve() 停止监听特定目标元素 举个栗子1. 假设页面上有一个class=&quot;box&quot;的盒子且父元素为视窗：12345678910let box = document.querySelector(&quot;.box&quot;);let observer = new IntersectionObserver(entries =&gt; &#123; entries.forEach(item =&gt; &#123; let tips = item.isIntersecting ? &quot;进入了父元素的内部&quot; : &quot;离开了父元素的内部&quot;; console.log(tips); &#125;);&#125;);observer.observe(box); // 监听一个box 2. 假设页面上有多个class=&quot;box&quot;的盒子且父元素为视窗：12345let box = document.querySelectorAll(&quot;.box&quot;);let observer = new IntersectionObserver(entries =&gt; console.log(`发生交叉行为，目标元素有$&#123;entries.length&#125;个`));box.forEach(item =&gt; observer.observe(item)); // 监听多个box [scode type&#x3D;”yellow”]如果三个box高度相同，大家都一起发生交叉，固每次返回的集合长度都为三；高度不同的情况则是每个目标元素轮流发生交叉，且当前只触发了一个，所以每次返回的集合长度只有一[&#x2F;scode] 3.指定父元素html如下 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt; javascript 1234567891011let child = document.querySelector(&quot;.child&quot;);let observer = new IntersectionObserver(entries =&gt; &#123; entries.forEach(item =&gt; &#123; console.log(item.isIntersecting ? &quot;可见&quot; : &quot;不可见&quot;); &#125;);&#125;, &#123; root: document.querySelector(&quot;.parent&quot;)&#125;);observer.observe(child); // 开始监听child 与视图情况无差别 实际应用懒加载123456789101112let images = document.querySelectorAll(&quot;img.lazyload&quot;);let observer = new IntersectionObserver(entries =&gt; &#123; entries.forEach(item =&gt; &#123; if (item.isIntersecting) &#123; item.target.src = item.target.dataset.origin; // 开始加载图片 observer.unobserve(item.target); // 停止监听已开始加载的图片 &#125; &#125;);&#125;);images.forEach(item =&gt; observer.observe(item)); 触底我们在列表底部放一个参照元素，然后让交叉观察者去监听； 假设html结构如下： 1234567&lt;!-- 数据列表 --&gt;&lt;ul&gt; &lt;li&gt;index&lt;/li&gt;&lt;/ul&gt;&lt;!-- 参照元素 --&gt;&lt;div class=&quot;reference&quot;&gt;&lt;/div&gt; javascript 1234new IntersectionObserver(entries =&gt; &#123; let item = entries[0]; // 拿第一个就行，反正只有一个 if (item.isIntersecting) console.log(&quot;滚动到了底部，开始请求数据&quot;);&#125;).observe(document.querySelector(&quot;.reference&quot;)); // 监听参照元素 3. 吸顶实现元素吸顶的方式有很多种，如css的position: sticky，兼容性较差；如果用交叉观察者实现也很方便，同样也要放一个参照元素； 假设html结构如下： 1234&lt;!-- 参照元素 --&gt;&lt;div class=&quot;reference&quot;&gt;&lt;/div&gt;&lt;nav&gt;我可以吸顶&lt;/nav&gt; 假设css如下 123456.nav .fixed &#123; position: fixed; top: 0; left: 0; width: 100%; &#125; javascript 12345678910111213let nav = document.querySelector(&#x27;nav&#x27;);let reference = document.querySelector(&quot;.reference&quot;);new IntersectionObserver(entries =&gt; &#123; let item = entries[0]; let top = item.boundingClientRect.top; // 当参照元素的的top值小于0，也就是在视窗的顶部的时候，开始吸顶，否则移除吸顶 if (top &lt; 0) nav.classList.add(&quot;fixed&quot;); else nav.classList.remove(&quot;fixed&quot;);&#125;).observe(reference); 兼容与IE不兼容不过有官方的polyfill 最后必须是子元素跟父元素发生交叉，如果你想检查两个非父子关系的交叉，那是不行的嘻嘻😊 [scode type&#x3D;”yellow”]本文参考了下文的连接，并稍微自行增加或删减了一些部分[&#x2F;scode][scode type&#x3D;”share”]利用”交叉观察者”这个小宝贝儿，轻松实现懒加载、吸顶、触底 ❗ https://juejin.im/post/5d665133e51d4561c83e7c83#heading-12[/scode]"},{"title":"ToDo-List","path":"/2019/08/29/ToDo-List/","content":"十几二十岁，你就一口一句“老了”；大学刚毕业，你就将人生目标设定为：“如何抓紧时间偷懒”；工作尚未有起色，你就盼着换一个“铁饭碗”；异地恋了半个月，你就觉得度日如年；聚会才过了二十分钟，你就别扭得想停止心跳…… 那结果必然是，所有你暂时追求不到的目标，都轻而易举被你归类为“痴心妄想的目标”；一切你伸手够不着的位置，都成了你遥不可及的“远方”…… 待看文章 前端开发知识系统 【手把手】15分钟搭一个企业级脚手架 前端工程师如何持续保持热情（一） 如何拿到9家大厂的前端校招offer 如何写出一个惊艳面试官的深拷贝? 浏览器的一些“滚动”行为鉴赏 if 我是前端团队 Leader，怎么制定前端协作规范? 解密初、中、高级程序员的进化之路（前端） Angular中使用热补丁 待看书籍 《黑客与画家》 《人间便利店》 《夜航船》 《穷查理宝典》 《图解HTTP》 《贫穷的本质》 《外婆的道歉信》 待研究技术 TypeScript webpack lodash source rxjs node.js flutter 小程序 如何发布一个npm 如何发布一个angular插件 待看电影 遗愿清单 教父 小丑2019 误杀 送你一朵小红花 横空出世 唐人街探案3 哥斯拉 宇宙时空之旅 为什么贫穷"},{"title":"18岁想做的事情，到了30岁就算做了也没什么意义了","path":"/2019/08/27/18岁想做的事情，到了30岁就算做了也没什么意义了/","content":"回顾自己的过往，其实很多事情现在想想可以避免，也很蠢。 或许你会想，要是我能和过去的自己交谈，我一定会告诉自己一定要干嘛干嘛的~ 两年前我觉得我十有八九是会这么想的，但是，现在经历了一些事情以后，人总是在成长的，有些事情，必须得自己经历了以后才会更加了解，才会更加完善自己的世界观。 或许在看视频的时候，觉得哇！他这件事情好酷，我也想做。我现在更多的想到是做了这件事情会对自己产生什么影响？当然，还是那句话，3岁想要的玩具。你20岁再得到时的感觉是完全不能比得上三岁的快乐的。 大家都是第一次做人，没什么值不值得的，你觉得你这辈子值，就值了！٩(ˊᗜˋ*)و"},{"title":"轻量级的marmode插件实现网站的黑夜模式","path":"/2019/08/23/轻量级的marmode插件实现网站的黑夜模式/","content":"简单的几步实现网站的黑暗模式 先贴出官方网站Darkmode.Js 简单模式很简单，甚至只需要三步。 1234&lt;script src=&quot;https://cdn.jsdelivr.net/npm/darkmode-js@1.4.0/lib/darkmode-js.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Darkmode().showWidget();&lt;/script&gt; 带配置参数12345678910111213141516var options = &#123; bottom: &#x27;64px&#x27;, // default: &#x27;32px&#x27; right: &#x27;unset&#x27;, // default: &#x27;32px&#x27; left: &#x27;32px&#x27;, // default: &#x27;unset&#x27; time: &#x27;0.5s&#x27;, // default: &#x27;0.3s&#x27; mixColor: &#x27;#fff&#x27;, // default: &#x27;#fff&#x27; backgroundColor: &#x27;#fff&#x27;, // default: &#x27;#fff&#x27; buttonColorDark: &#x27;#100f2c&#x27;, // default: &#x27;#100f2c&#x27; buttonColorLight: &#x27;#fff&#x27;, // default: &#x27;#fff&#x27; saveInCookies: false, // default: true, label: &#x27;☹️&#x27;, // default: &#x27;&#x27; autoMatchOsTheme: true // default: true&#125;const darkmode = new Darkmode(options);darkmode.showWidget(); 配合pio插件食用 在自定义JavaScript中添加cdn文件 1234&lt;script src=&quot;https://cdn.jsdelivr.net/npm/darkmode-js@1.4.0/lib/darkmode-js.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const darkmode = new Darkmode(); &lt;/script&gt; 在pio相应的黑夜模式中填写触发开关的函数 darkmode.toggle(); 实际handsome主题使用中还需要自定义css添加 123.darkmode-layer, .darkmode-toggle &#123; z-index: 1; //1就行了，高了会有层级错误. &#125;"},{"title":"如何通过浏览器调用APP的方法及问题","path":"/2019/08/23/如何通过浏览器调用APP的方法及问题/","content":"导语经常遇到浏览某些网站的页面时，提示你下载他的APP。 已经发现封装好的通用JS方法 /2019/11/08/%E4%BD%BF%E7%94%A8JS%E6%A3%80%E6%B5%8B%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/ 下列方法为自己摸索。 因为单纯个人兴趣，本博客中的代码只在IOS（ios 12.4， xs max）实测过，Android端需要自己实测，并不完全保证其正确性，如果IOS端如果问题也请自己查看官方safari的文档。Safari的版本根据ios版本而有所不同，本人遇到过低版本的Safari与高版本Safari支持的浏览器不同的情况，故，若需要实际开发，请多多测试 原理粗略了解下来，安装APP后你的终端设备就会多一个APP相对应的协议，通过这个协议你可以打开APP，当然也可以附带一些参数，从而实现更加复杂的操作，比如支付宝或者微信的支付功能。 想深入了解的下面有简书上找到的解释（我没太看懂） 简书： https://www.jianshu.com/p/977ad259124f[/scode] 实现IOSIOS 因为浏览器内核强制为safari所以方法统一，只需要在添加一个meta就可以了 123&lt;meta name=&#x27;apple-itunes-app&#x27; content=&#x27;app-id=477927812&#x27;&gt; &lt;!-- 上面的方法仅限于iOS设备，且无法定义Banner的形式。另外打开应用时也无法告诉App端要做什么操作。 --&gt; &lt;!-- app-id 对应 App Store里面ID，我使用的百度贴吧的ID--&gt; 通用方法1234&lt;a href=&quot;weixin://&quot;&gt;打开微信&lt;/a&gt; &lt;a href=&quot;com.baidu.tieba://&quot;&gt;打开贴吧&lt;/a&gt; &lt;!-- 相对应的协议对应相应的APP --&gt; &lt;!-- 引出问题，我没安装软件怎么办？如何合理的校验以及提示 --&gt; 优化用户没有安装你的软件，怎么办呢？常用的办法就是，在页面中出现一个按钮，提示你‘在App中打开’，点击按钮，如果APP已安装，则直接打开，若没安装，则跳转到相应的安装页面 code12345678910function openApp()&#123; let loadDateTime = Date.now(); setTimeout(function () &#123; var timeOutDateTime = new Date(); if (!loadDateTime || timeOutDateTime - loadDateTime &lt; 2010) &#123; if (document.visibilityState === &#x27;visible&#x27;) &#123; window.location = &#x27;http://a.app.qq.com/o/simple.jsp?pkgname=com.diaox2.android&amp;ckey=CK1308661595241&#x27;; &#125; &#125; &#125;,2000); window.location = &#x27;weixin://&#x27;; &#125; 理论上这些提示内容都是可以修改的，应该需要去看Safari的开发文档。不过我就不深入了，只是好奇研究一下。 参考文献 H5外部浏览器直接调起微信——通过url协议 weixin:&#x2F;&#x2F; 判断是否安装微信及启动微信 在手机浏览器中判断App是否已安装 在移动端浏览器内判断用户是否安装了某个app weixin:&#x2F;&#x2F;xxx 分析 在web浏览器中判断app是否安装并直接打开"},{"title":"如何判断浏览器是否在前台展示","path":"/2019/08/23/如何判断浏览器是否在前台展示/","content":"有的时候需要检测当前页面是否还在前台展示，比如说移动端通过浏览器打开了APP已经跳转了APP中，此时就是需要判断是否还留在当前页面，或者某些提供tab功能的浏览器，你已切换到其他tab，也可以通过这个方法来鉴定。 Document.visibilityState （只读属性）, 返回document的可见性, 即当前可见元素的上下文环境. 由此可以知道当前文档(即为页面)是在背后, 或是不可见的隐藏的标签页，或者(正在)预渲染.可用的值如下： &#39;visible&#39; : 此时页面内容至少是部分可见. 即此页面在前景标签页中，并且窗口没有最小化. &#39;hidden&#39; : 此时页面对用户不可见. 即文档处于背景标签页或者窗口处于最小化状态，或者操作系统正处于 ‘锁屏状态’ . &#39;prerender&#39; : 页面此时正在渲染中, 因此是不可见的 (considered hidden for purposes of document.hidden). 文档只能从此状态开始，永远不能从其他值变为此状态.注意: 浏览器支持是可选的. &#39;unloaded&#39; : 页面从内存中卸载清除. 注意: 浏览器支持是可选的. [scode type&#x3D;”blue”]MDN官方文档： https://developer.mozilla.org/zh-CN/docs/Web/API/Document/visibilityState[/scode]"},{"title":"给Typecho（任意网站）添加鼠标点击出现“富强”民主“富强”特效","path":"/2019/08/21/给Typecho（任意网站）添加鼠标点击出现“富强”民主“富强”特效/","content":"为了中华民族之伟大复兴而努力奋斗！ 将代码放在主题的footer.php中的之前即可。 123456789101112131415161718192021222324252627282930&lt;script type=&quot;text/javascript&quot;&gt; /* 鼠标特效 */let a_idx = 0; jQuery(document).ready(function($) &#123; $(&quot;body&quot;).click(function(e) &#123; let a = new Array(&quot;富强&quot;, &quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;, &quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot; ,&quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;, &quot;诚信&quot;, &quot;友善&quot;); let $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]); a_idx = (a_idx + 1) % a.length; let x = e.pageX, y = e.pageY; $i.css(&#123; &quot;z-index&quot;: 999999999999999999999999999999999999999999999999999999999999999999999, &quot;top&quot;: y - 20, &quot;left&quot;: x, &quot;position&quot;: &quot;absolute&quot;, &quot;font-weight&quot;: &quot;bold&quot;, &quot;color&quot;: &quot;#ff6651&quot; &#125;); $(&quot;body&quot;).append($i); $i.animate(&#123; &quot;top&quot;: y - 180, &quot;opacity&quot;: 0 &#125;, 1500, function() &#123; $i.remove(); &#125;); &#125;); &#125;); &lt;/script&gt; 版权归知言笔记所有"},{"title":"图片悬浮放大图效果","path":"/2019/08/12/图片悬浮放大图效果/","content":"原生JS1234567891011121314151617181920212223242526272829@Input() src: string; //图片资源地址 @Input() isShowTip = true; //是否展示 @Input() preSize = 100; // 缩略图尺寸 @Input() showSize = 700; //展示尺寸 //@Input是封装成angular组件了，纯js 可以当成 let src = &#x27;&#x27;; // 绑定在悬浮事件 onmouseover showPreview($event)&#123; let pageHeight = $event.pageY; // 图片在body中的高度位置 let pageWidth = $event.pageX; // 图片在body中的宽度位置 let preTip = document.createElement(&#x27;div&#x27;); preTip.setAttribute(&#x27;id&#x27;, &#x27;preTip&#x27;); preTip.style.zIndex = &#x27;99&#x27;; preTip.style.bottom = window.document.body.scrollHeight - pageHeight - 250 + &#x27;px&#x27;; preTip.style.left = pageWidth &gt; window.document.body.clientWidth/2 ? pageWidth - this.showSize - 50 + &#x27;px&#x27; : pageWidth + 50 + &#x27;px&#x27;; preTip.style.position = &#x27;absolute&#x27;; let preImg = document.createElement(&#x27;img&#x27;); preImg.setAttribute(&#x27;src&#x27;, this._src); preImg.style.width = &#x27;700px&#x27;; preImg.style.height = &#x27;700px&#x27;; preTip.appendChild(preImg) window.document.querySelector(&#x27;body&#x27;).appendChild(preTip); //把它追加到文档中 &#125; // onmouseout 同理 removePreview() &#123; window.document.body.removeChild(window.document.querySelector(&#x27;#preTip&#x27;)); &#125; 考虑到复用就封装了简易的angular组件 TS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import &#123; Component, OnInit, Input &#125; from &#x27;@angular/core&#x27;;@Component(&#123; selector: &#x27;app-mypreview&#x27;, templateUrl: &#x27;./mypreview.component.html&#x27;, styleUrls: [&#x27;./mypreview.component.css&#x27;]&#125;)export class MypreviewComponent implements OnInit &#123; @Input() src: string; //图片资源地址 @Input() isShowTip = true; //是否展示 @Input() preSize = 100; // 缩略图尺寸 @Input() showSize = 700; //展示尺寸 constructor() &#123; &#125; ngOnInit() &#123; this.changeSize(); &#125; private _src = &#x27;&#x27;; private changeSize() &#123; this._src = this.src.replace(`/$&#123;this.preSize&#125;x$&#123;this.preSize&#125;/`, `/$&#123;this.showSize&#125;x$&#123;this.showSize&#125;/`); &#125; showPreview($event): boolean &#123; if (this.isShowTip === false) &#123; return false; &#125; let pageHeight = $event.pageY; // 图片在body中的高度位置 let pageWidth = $event.pageX; // 图片在body中的宽度位置 let preTip = document.createElement(&#x27;div&#x27;); preTip.setAttribute(&#x27;id&#x27;, &#x27;preTip&#x27;); preTip.style.zIndex = &#x27;99&#x27;; preTip.style.bottom = window.document.body.scrollHeight - pageHeight - 250 + &#x27;px&#x27;; preTip.style.left = pageWidth &gt; window.document.body.clientWidth/2 ? pageWidth - this.showSize - 50 + &#x27;px&#x27; : pageWidth + 50 + &#x27;px&#x27;; preTip.style.position = &#x27;absolute&#x27;; let preImg = document.createElement(&#x27;img&#x27;); preImg.setAttribute(&#x27;src&#x27;, this._src); preImg.style.width = &#x27;700px&#x27;; preImg.style.height = &#x27;700px&#x27;; preTip.appendChild(preImg) window.document.querySelector(&#x27;body&#x27;).appendChild(preTip); //把它追加到文档中 return true; &#125; removePreview() &#123; this.isShowTip !== false &amp;&amp; window.document.body.removeChild(window.document.querySelector(&#x27;#preTip&#x27;)); &#125;&#125; HTML1&lt;img [src]=&quot;src&quot; alt=&quot;&quot; (mouseover)=showPreview($event) (mouseout)=&quot;removePreview()&quot; appErrSrc&gt; 父组件module引入1234567import &#123; MypreviewComponent &#125; from &#x27;../../../../../component/mypreview/mypreview.component&#x27;@NgModule(&#123;declarations: [ MypreviewComponent]&#125;) 父组件HTML1&lt;app-mypreview [isShowTip]=&quot;true&quot; [preSize]=&quot;100&quot; [src]=&quot;xxx&quot;&gt;&lt;/app-mypreview&gt;"},{"title":"setTimeout、Promise、Async/Await 的区别","path":"/2019/08/02/setTimeout、Promise、Async-Await-的区别/","content":"1、setTimeout 还记得一开始接触到此类问题是setTimeout 0ms也会放在下一轮操作中 引出 -&gt; 宏观任务队列微观任务队列的区别（埋坑，下一篇文章写） 123456console.log(&#x27;script start&#x27;) //1. 打印 script start setTimeout(function()&#123; console.log(&#x27;settimeout&#x27;) // 4. 打印 settimeout &#125;) // 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数 console.log(&#x27;script end&#x27;) //3. 打印 script start // 输出顺序：script start-&gt;script end-&gt;settimeout 此处因为setTimeout所以必然会最后一个执行（就算时间为0ms也会延迟到下一个宏观任务队列 macro queue） 2、 Promise Promise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then&#x2F;catch等， 当主栈完成后，才会去调用resolve&#x2F;reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。 12345678910111213console.log(&#x27;script start&#x27;)let promise1 = new Promise(function (resolve) &#123; console.log(&#x27;promise1&#x27;) resolve() console.log(&#x27;promise1 end&#x27;)&#125;).then(function () &#123; console.log(&#x27;promise2&#x27;)&#125;)setTimeout(function()&#123; console.log(&#x27;settimeout&#x27;)&#125;)console.log(&#x27;script end&#x27;)// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout"},{"title":"使用A标签下载文件","path":"/2019/08/01/使用A标签下载文件/","content":"A的资源是浏览器可以识别的资源时，浏览器会默认打开。所以如果是单纯想打开资源可以加上 [target&#x3D;”_blank”] 若是ZIP这种无法识别的文件会默认下载，但是有的时候我们就是想下载比如jpg等资源,那么可以加上 [download&#x3D;”文件名.后缀”],也可以单独使用download这样下载的文件名就是默认的文件名 注意！此种方法下载的文件必须是通源文件，若是跨域还是按照正常的打开链接方式打开资源，download属性无效 若是需要现在后端发送的流文件such as表格之类。可以接收后使用相应的函数转成href可以识别的资源符进行下载 [scode type&#x3D;”blue”]MDN-a： https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a[/scode]"},{"title":"深度优先遍历和广度优先遍历","path":"/2019/07/31/深度优先遍历和广度优先遍历/","content":"深度优先遍历例图123A B C D E F G H 1从启点出发，找到其一个子元素，然后继续找到子元素的一个子元素，直至没有子元素。然后这个没有子元素的父元素开始继续依次找到其子元素。直到全部。 12341.从顶点A触发，找到其第一个子元素B然后再向下找到B的第一个子元素E，此时E已没有子元素。 （一层一层深入下去，顾算法名为深度遍历）2.因E没有子元素，所以返回到E的父元素B，找至其领一个子元素F。发现F也无子元素3.因F无子元素。所以返回F的父元素B，因B无其他元素。所以返回至B的父元素A4.继续从A找寻未定位过的元素。C和D方法同 codeHTML 123456789101112131415161718192021222324252627282930&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child-1&quot;&gt; &lt;div class=&quot;child-1-1&quot;&gt; &lt;div class=&quot;child-1-1-1&quot;&gt; a &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;child-1-2&quot;&gt; &lt;div class=&quot;child-1-2-1&quot;&gt; b &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;child-1-3&quot;&gt; c &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;child-2&quot;&gt; &lt;div class=&quot;child-2-1&quot;&gt; d &lt;/div&gt; &lt;div class=&quot;child-2-2&quot;&gt; e &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;child-3&quot;&gt; &lt;div class=&quot;child-3-1&quot;&gt; f &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; JS 12345678910let deepTraversal1 = (node, nodeList = []) =&gt; &#123; if (node !== null) &#123; nodeList.push(node) let children = node.children for (let i = 0; i &lt; children.length; i++) &#123; deepTraversal1(children[i], nodeList) &#125; &#125; return nodeList &#125; 广度优先遍历与深度相反，广度优先匹配兄弟节点（元素） codejS 123456789101112131415161718192021let widthTraversal2 = (node) =&gt; &#123; let nodes = [] let stack = [] if (node) &#123; stack.push(node) while (stack.length) &#123; let item = stack.shift() let children = item.children nodes.push(item) // 队列，先进先出 // nodes = [] stack = [parent] // nodes = [parent] stack = [child1,child2,child3] // nodes = [parent, child1] stack = [child2,child3,child1-1,child1-2] // nodes = [parent,child1,child2] for (let i = 0; i &lt; children.length; i++) &#123; stack.push(children[i]) &#125; &#125; &#125; return nodes &#125; [scode type&#x3D;”blue”]参考第 5 题：介绍下深度优先遍历和广度优先遍历，如何实现？[&#x2F;scode]"},{"title":"「1, 2, 3」.map(parseInt) what & why ?","path":"/2019/07/25/「1-2-3」-map-parseInt-what-why/","content":"说来惭愧一开始看到这个问题，我甚至还没反应过来是什么问题。 map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 [scode type&#x3D;”share”]https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map[/scode] parseInt(string, radix) string为字符串，radix为介于2-36之间的数。使用者告诉这个函数string（比如11）是radix（比如2）进制的，函数将固定返回string以十进制时显示的数。 [scode type&#x3D;”share”]https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt[/scode] iterator一般JS中能迭代的函数一般都有三个参数： currentValue, Index, Array 分别代表当前项，索引，整个数组 parseInt接受两个参数，此题传入currentValue和Index分别为： (1, 0) 0或不传为十进制 (2, 1) 1不在[2,36]所以 &#x3D;&gt; NaN (3, 2) 2&lt; [2,36]， 但是3不是二进制数，所以 &#x3D;&gt; NaN [scode type&#x3D;”yellow”]如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制). 如果字符串 string 以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。 如果字符串 string 以其它任何值开头，则基数是10 (十进制)。[&#x2F;scode]"},{"title":"写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？","path":"/2019/07/25/写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么？/","content":"[scode type&#x3D;”share”]壹题 https://github.com/Advanced-Frontend/Daily-Interview-Question[/scode] for 循环时有id无id的区别。 1234567891011121314151617181920vm.dataList = [3, 4, 5, 6, 7] // 数据进行增删 // 1. 没有key的情况， 节点位置不变，内容也更新了 [ &#x27;&lt;div&gt;3&lt;/div&gt;&#x27;, // id： A &#x27;&lt;div&gt;4&lt;/div&gt;&#x27;, // id: B &#x27;&lt;div&gt;5&lt;/div&gt;&#x27;, // id: C &#x27;&lt;div&gt;6&lt;/div&gt;&#x27;, // id: D &#x27;&lt;div&gt;7&lt;/div&gt;&#x27; // id: E ] // 2. 有key的情况， 节点删除了 A, B 节点，新增了 F, G 节点 // &lt;div v-for=&quot;i in dataList&quot; :key=&#x27;i&#x27;&gt;&#123;&#123; i &#125;&#125;&lt;/div&gt; [ &#x27;&lt;div&gt;3&lt;/div&gt;&#x27;, // id： C &#x27;&lt;div&gt;4&lt;/div&gt;&#x27;, // id: D &#x27;&lt;div&gt;5&lt;/div&gt;&#x27;, // id: E &#x27;&lt;div&gt;6&lt;/div&gt;&#x27;, // id: F &#x27;&lt;div&gt;7&lt;/div&gt;&#x27; // id: G ] vue官方推荐for循环时。必须加上id，除非您的数据非常简单或者仅做展示。 其中涉及到dom的“定位“，加上了id才会按照你所想的进行实际上的变换 如果不加id可能只是您看上去进行了变化，但是本质没有变化"},{"title":"父页面操控iframe的方法","path":"/2019/07/25/父页面操控iframe的方法/","content":"因为业务需要需要在父页面操控iframe调用的页面。这里坐下记录。 1234567891011121314151617181920/* *父页面通过 iframe id 调用子页面的函数或者获取子页面元素的内容 */ function one() &#123; //var ifreame = window.frames[&quot;childPage1&quot;]; var fifreame = window.document.getElementById(&#x27;childPage1&#x27;); if (ifreame != null &amp;&amp; ifreame != undefined) &#123; ifreame.childFunction(); &#125; &#125; function two() &#123; //var ifreame = window.frames[&quot;childPage1&quot;]; var fifreame = window.document.getElementById(&#x27;childPage1&#x27;); if (ifreame != null &amp;&amp; ifreame != undefined) &#123; var myValue = ifreame.contentWindow.document.getElementById(&quot;childPage&quot;); alert(myValue.innerHTML); &#125; &#125; [scode type&#x3D;”blue”]来源–全面兼容的Iframe 与父页面交互操作：https://www.cnblogs.com/web100/p/iframe-ok.html[/scode] 2019-07-29 [scode type&#x3D;”yellow”]警告：window.frames[] IE专用，实测safari新版本手机可用，老版本会出错 [&#x2F;scode][scode type&#x3D;”share”]JS获取并操作iframe中元素的方法 https://www.jb51.net/article/34942.htm[/scode]"},{"title":"滚动条的过渡效果","path":"/2019/07/23/滚动条的过渡效果/","content":"需求在页面刚启动时，滚动到指定位置（1秒内，过渡效果） code12345678window.onload = function() &#123; let tempTop = 0; let timeOut = setInterval( () =&gt; &#123; tempTop += 10; window.document.querySelector(&#x27;body&#x27;).scrollTop = tempTop; tempTop &gt; 700 &amp;&amp; clearInterval(timeOut); //前面不为真后面不执行，just cool &#125;, 16.7) // 60帧下的建议刷新频率，别问为什么，百度的? &#125; 优化细节过渡时间一秒，但是像我这样的急性子，就是想让它提前停下来？ 1234567window.document.querySelector(&#x27;body&#x27;).onscroll = () =&gt; &#123; // 因为设置滚动就会触发此事件，所以需要加判断条件 window.document.querySelector(&#x27;body&#x27;).scrollTop&lt;tempTop &amp;&amp; clearInterval(timeOut); // 类似的移动端顶部菜单下拉隐藏，上拉显示，也可根据此原理顺势展开 // 下拉情况： scrollTop &gt; xxx =&gt; 隐藏菜单 // 上拉显示: 出现上拉操作，记录当前高度，知道超过某一阀值，则进行菜单弹出操作 &#125; 自动化元素的高度是我手动测出来的，但是实际上应该可以程序自动给出的[scode type&#x3D;”green”]element.offsetTop &#x3D;&gt; 元素到父元素的顶部的距离[&#x2F;scode] 123456function getElementToPageTop(el) &#123; if(el.parentElement) &#123; return this.getElementToPageTop(el.parentElement) + el.offsetTop &#125; return el.offsetTop&#125; [scode type&#x3D;”share”]原文：https://blog.csdn.net/u013764814/article/details/83825479 [&#x2F;scode] 模块化也可封装成模块，运用到类似ToTop功能上"},{"title":"如何在浏览器中调用系统通知API","path":"/2019/07/09/如何在浏览器中调用系统通知API/","content":"接口介绍构造方法1let notification = new Notification(title, options) 参数title 一定会被显示的通知标题 options|可选 dir : 文字的方向；它的值可以是 auto（自动）, ltr（从左到右）, or rtl（从右到左） lang: 指定通知中所使用的语言。 body: 通知中额外显示的字符串 tag: 赋予通知一个ID，以便在必要的时候对通知进行刷新、替换或移除。 icon: 一个图片的URL，将被用于显示通知的图标。 属性Notification.permission | 只读 一个用于表明当前通知显示授权状态的字符串。可能的值包括：denied (用户拒绝了通知的显示), granted(用户允许了通知的显示), 或 default (因为不知道用户的选择，所以浏览器的行为与 denied 时相同). 方法Notification.requestPermission() 用于当前页面向用户申请显示通知的权限。这个方法只能被用户行为调用（比如：onclick 事件），并且不能被其他的方式调用。 Notification.onclick 处理 click 事件的处理。每当用户点击通知时被触发。 Notification.onshow 处理 show 事件的处理。当通知显示的时候被触发。 Notification.onerror 处理 error 事件的处理。每当通知遇到错误时被触发。 Notification.onclose 处理 close 事件的处理。当用户关闭通知时被触发。 实例单一消息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849window.addEventListener(&#x27;load&#x27;, function()&#123; if (window.Notification &amp;&amp; window.Notification.permission !== &quot;granted&quot;) &#123; Notification.requestPermission(function(status) &#123; if (Notification.permission !== status) &#123; Notification.permission = status; &#125; &#125;) &#125; let button = document.getElementsByTagName(&#x27;button&#x27;)[0]; button.addEventListener(&#x27;click&#x27;, function()&#123; // 如果用户同意就创建通知 if(window.Notification.permission === &#x27;granted&#x27;)&#123; let n = new Notification(&quot;Hi!&quot;); n.onclick = function()&#123; alert(&#x27;你点击了通知！&#x27;); &#125; &#125; // 如果用户没有选择是否通知 // 注：因为在Chrom中我们无法确定permission属性是否有值，因此 // 检查该属性是否是default 是不安全的。 // default 用户还未被询问是否授权，所以通知不会被显示。 // granted 表示之前已经询问过用户，并且用户已经授予了显示通知的权限。 // denied 用户已经明确的拒绝了显示通知的权限。 else if (window.Notification &amp;&amp; window.Notification !== &#x27;denied&#x27;) &#123; Notification.requestPermission(function(status)&#123; if (Notifacation.permission !== status) &#123; Notification.permission = status; &#125; // 如果用户同意了 if (status === &quot;granted&quot;) &#123; let n = new Notification(&quot;hi&quot;); &#125; // 否则 else &#123; alert(&#x27;Hi&#x27;); &#125; &#125;); &#125; // 如果用户拒绝接受通知 else &#123; // 我们可以让步使用常规模态的alert alert(&quot;hi&quot;); &#125; &#125;);&#125;) N条消息（tag属性，只会显示一个，会覆盖）12345678910111213141516171819202122232425262728293031323334353637383940414243444546window.addEventListener(&#x27;load&#x27;, function()&#123; if (window.Notification &amp;&amp; window.Notification.permission !== &quot;granted&quot;) &#123; Notification.requestPermission(function(status) &#123; if (Notification.permission !== status) &#123; Notification.permission = status; &#125; &#125;) &#125; let button2 = document.getElementsByTagName(&#x27;button&#x27;)[1]; button2.addEventListener(&#x27;click&#x27;, function()&#123; // 如果用户同意通知，尝试通知10次 if (Notification.permission === &#x27;granted&#x27;) &#123; for (let index = 0; index &lt; 10; index++) &#123; // 感谢标记，我们应该只看到内容为 &quot;Hi! 9&quot; 的通知 let n = new Notification(&quot;Hi!&quot; + index, &#123;tag: &#x27;soManyNotification&#x27;&#125;); &#125; &#125; // 如果用户没有同意通知权限 // 有值chrome不能检查permission知否有值 // 所以检查值为default是不安全的 else if (Notification &amp;&amp; Notification.permission !== &#x27;denied&#x27;) &#123; Notification.requestPermission(function(status)&#123; if (status != Notification.permission) &#123; Notification.permission = status; &#125; // 同意 if (status === &#x27;granted&#x27;) &#123; for (let index = 0; index &lt; 10; index++) &#123; // 感谢标记，我们应该只看到内容为 &quot;Hi! 9&quot; 的通知 let n = new Notification(&quot;hi&quot; + index, &#123;tag: &#x27;soManyNotification&#x27;&#125;) &#125; &#125; // 否则改用alert else &#123; alert(&quot;hi!&quot;); &#125; &#125;); &#125; else &#123; // 改用alert alert(&#x27;Hi!&#x27;); &#125; &#125;);&#125;） [scode type&#x3D;”blue”]移动端尚未支持[&#x2F;scode]"},{"title":"JS防抖动和节流（debounce & throttle）","path":"/2019/05/22/JS防抖动和节流（debounce-throttle）/","content":"防抖动 debounce由于种种原因，可能某一个函数会在很短的时间内触发N次，但是我们并不想这样，只想触发一次，可能是因为性能原因，也可能逻辑原因。 这个时候就需要防抖动了。 [scode type&#x3D;”blue”]去抖和节流是不同的，因为节流虽然中间的处理函数被限制了，但是只是减少了频率，而去抖则把中间的处理函数全部过滤掉了，只执行规判定时间内的最后一个事件。[&#x2F;scode] 举个例子： 监听滚动事件 只有用户停止滚动滚轮delay毫秒后才会触发事件（1次） 1234567891011121314151617window.onscroll = debounce(scrollListen, 100); function scrollListen() &#123; let scrollTop = document.body.scrollTop || document.documentElement.scrollTop; console.log(scrollTop,); &#125; function debounce(func, delay) &#123; let timeout = null; return function() &#123; let context = this; let args = arguments; timeout &amp;&amp; clearTimeout(timeout); // &amp;&amp;运算符，若前为假，则不计算后者，不喂呼奇技淫巧 timeout = setTimeout(function()&#123; func.apply(context, args); &#125;,delay); &#125; &#125; PS：请注意，实际浏览器触发onscroll时是这样调用的 debounce(scrollListen, 100)(event),即arguments是这里的event.详情请了解函数返回值为函数的注意点。 节流 throttle 在1秒内只触发一次 1234567891011121314151617181920212223242526272829303132333435window.onscroll = throttle(scrollListen, 1000); function scrollListen() &#123; let scrollTop = document.body.scrollTop || document.documentElement.scrollTop; console.log(scrollTop); &#125; /** * 节流函数 * @param func事件触发的操作 * @param wait 间隔多少毫秒需要触发一次事件 */ function throttle(func, wait) &#123; let lastTime = null; let timeout = null; return function() &#123; let context = this; let now = new Date(); // 如果上次执行的时间和这次触发的时间大于一个执行周期，则执行 if (now - lastTime - wait &gt; 0) &#123; // 如果之前有了定时任务则清除 if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; func.apply(context, arguments); lastTime = now; &#125; else if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; // 改变执行上下文环境 func.apply(context, arguments); &#125;, wait); &#125; &#125;; &#125;"},{"title":"IOS在桌面添加web站点图标以及增加启动动画来模仿原生App","path":"/2019/05/07/IOS在桌面添加web站点图标以及增加启动动画来模仿原生App/","content":"web应用的意义公司计划上线一款样本App，安卓端因为盛和不严格，很容易就上架了，但是万恶的IOS端，一直审核不通过。原因种种，所以需要我前端把现有的网站配合Safari的添加到桌面图标功能伪造一个原生App。 开发步骤第一步：添加图标到主屏幕在Safari上点击添加到主屏幕，默认的icon是当前页面的缩略图，但是用屁股想想也知道这不行啊，老大拿着40米的大刀让你先跑39米那么就需要下面的Safari的私有属性来设置icon了。 1234&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;57x57&quot; href=&quot;icon-57.png&quot;&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;72x72&quot; href=&quot;icon-72.png&quot;&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;icon-114.png&quot;&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;icon-144.png&quot;&gt; 添加图标到主屏幕有两个属性值：apple-touch-icon 和 apple-touch-icon-precomposed，后者会应用IOS自动给图标添加的那层高光 由于iPhone以及iPad都有两种分辨率的设备存在，图标的尺寸就需要做4个：144×144(iPad Retina)、72×72(iPad)、114×114(iPhone Retina)、57×57(iPhone)。 使用size来告诉设备调用哪一个图标 第二步：启动动画几乎所有的App都有启动动画，我们要以假乱真怎么可以没有启动动画呢？? 下面是表示启动动画的Safari私有属性 12345&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;2048x1496&quot; href=&quot;icon-2048x1496.png&quot; media=&quot;screen and (min-device-width: 1025px) and (max-device-width: 2048px) and (orientation:landscape) and (-webkit-min-device-pixel-ratio: 2)&quot;&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1536x2008&quot; href=&quot;icon-1536x2008.png&quot; media=&quot;screen and (min-device-width: 1025px) and (max-device-width: 2048px) and (orientation:portrait) and (-webkit-min-device-pixel-ratio: 2)&quot;&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1024x748&quot; href=&quot;icon-1024x748.png&quot; media=&quot;screen and (min-device-width: 481px) and (max-device-width: 1024px) and (orientation:landscape)&quot;&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;768x1004&quot; href=&quot;icon-768x1004.png&quot; media=&quot;screen and (min-device-width: 481px) and (max-device-width: 1024px) and (orientation:portrait)&quot;&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;640x920&quot; href=&quot;icon-640x920.png&quot; media=&quot;screen and (max-device-width: 480px) and (-webkit-min-device-pixel-ratio: 2)&quot;&gt; apple-touch-startup-image是用来标示启动画面的，但它不像apple-touch-icon可以指定sizes来告诉设备该使用哪个图片（也有一种说法是在iOS5中已经支持sizes识别了，但没有测试成功），所以只能通过media里的媒体查询来识别，而iPhone Retina的分辨率值界于取值之间，所以需要通过webkit的私有属性-webkit-min-device-pixel-ratio:2来鉴别像素密度以进行识别。 启动画面的图片尺寸并非完全等于设备的尺寸，比如iPad2的尺寸是1024×768，但它的启动画面尺寸横向是1024×748，竖向尺寸是768×1004，因为需要减去系统状栏的高度20px，而使用的Retina屏幕的iPhone4以及iPad3则需要减去状态栏的高度40px。 第三步：隐藏工具栏桌面图标有了，启动动画也有了，但是一打开还是浏览器，那不是一下子全暴露了？ 所以我们还需要把Safari的工具栏给藏起来，当然Safari也提供了这个私有方法。 ::aru:cheer:: 1234&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; //全屏&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt; //全屏前提下的状态栏&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; //是否禁用电话号码&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1, minimum-scale=1.0, maximum-scale=1, user-scalable=no&quot;&gt; //viewport并非Safari的私有属性，width用于指定宽度，initial-scale指定初始化的缩略比例，minimum-scale指定缩小的比例，而maximum-scale则是放大的比例，当然这些缩放都取决于user-scalable——决定用户是否能缩放页面。 阻止iOS Web APP中点击链接跳转到Safari 浏览器新标签页一切都已经就绪，至少外观看上去和真的没什么不一样了，but，点开某个链接。what，又调用了另一个Safari浏览器，这不就全暴露我是一个假货了？那不行，你得给我在内部进行跳转。 123456789101112131415161718&lt;script type=&quot;text/javascript&quot;&gt; //iOS Web APP中点击链接跳转到Safari 浏览器新标签页的问题 devework.com //stanislav.it/how-to-prevent-ios-standalone-mode-web-apps-from-opening-links-in-safari if((&quot;standalone&quot; in window.navigator) &amp;&amp; window.navigator.standalone)&#123; var noddy, remotes = false; document.addEventListener(&#x27;click&#x27;, function(event) &#123; noddy = event.target; while(noddy.nodeName !== &quot;A&quot; &amp;&amp; noddy.nodeName !== &quot;HTML&quot;) &#123; noddy = noddy.parentNode; &#125; if(&#x27;href&#x27; in noddy &amp;&amp; noddy.href.indexOf(&#x27;http&#x27;) !== -1 &amp;&amp; (noddy.href.indexOf(document.location.host) !== -1 || remotes)) &#123; event.preventDefault(); document.location.href = noddy.href; &#125; &#125;,false); &#125;&lt;/script&gt; 大功告成，以假乱真的IOS端web应用出炉了。"},{"title":"初试MarkDown?","path":"/2019/04/29/初试MarkDown/","content":"首先附上官方文档： 教程-MarkDown Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 因为发布文章支持markdown，所以接触了这种语法，一上手就发现了他的妙处。比起一般的文本编译器，方便了太多。 优点 因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。 操作简单。一般编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可。 缺点 需要记一些语法（当然，是很简单。五分钟学会）。 有些平台不支持Markdown编辑模式。（基本一些主流网站皆支持markdown，印象笔记、有道笔记也都支持） 一、 标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字，不过有些平台貌似不加空格也行。 示例：123456# 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 二、字体·加粗要加粗的文字左右分别用两个*号包起来 ·斜体要倾斜的文字左右分别用一个*号包起来 ·斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 ·删除线要加删除线的文字左右分别用两个~~号包起来 示例： 1234**这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 效果如下： 这是加粗的文字这是倾斜的文字&#96;这是斜体加粗的文字这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 实例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或以上-或*都可以 示例： 1234-------******** 效果： 五、图片资源语法： 12345678910&#123;% image 图片地址 &#x27;&#x27;图片title&#x27;&#x27; 图片alt %&#125;或者![图片alt][序号]（默认文章末尾位置）[序号]: 图片地址图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 示例图片 六、超链接语法（同图片基本一致）： 12345[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加或[超链接名][序号][序号]: 链接地址 实例： Markdown语法-简述 七、列表-无序列表 语法：无序列表用 - + * 任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 示例： 列表内容 列表内容 列表内容 注意：- + * 跟内容之间都要有一个空格 1. 有序列表 语法：数字加点 示例： 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 ·列表嵌套 上一级和下一级之间敲四个空格即可 1234- 一级无序 1.一级有序 2.一级有序 3.一级有序 一级无序1.一级有序2.一级有序3.一级有序 八、表格语法： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 实例： 表头 表头 表头 内容 内容 内容 内容 内容 内容 九、代码语法：单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码... (```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行：代码内容 多行 123代码... 代码... 代码... 十、流程图流程图效果typecho不支持。各位自己尝试吧٩(ˊᗜˋ)و 写法： 123456789```flow st=&gt;start: 开始 op=&gt;operation: My Operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op &amp;```"},{"title":"关于Typeecho出现Database Query Error 问题的汇总","path":"/2019/04/29/关于Typeecho出现Database-Query-Error-问题的汇总/","content":"刚刚部署完网站的时候，总是会时不时在各种场景出现Database Query Error 这个问题。 初步排查下来是数据库格式未支援UTF-8（因为想支援EMOJI符号表情，所以这里选择最近的UTF-8） 这样下来，大部分情况下的错误没有了（其实也就是评论+文章发布的时候） 后来因为需要用到时光机的发送定位功能，发现还是出现Database Query Error 错误 查阅资料，因为我数据库创建的时候数据库编码没有正确选择，所以需要额外的步骤去修改数据格式 我的因为数据涉及比较少，所以直接navicat里面设计表中修改了内容。 附上文档（ps：官方网站的文档是真的简陋啊） Typecho数据库错误Database-Query-Error解决办法"},{"title":"你喜欢什么？ 忘了。","path":"/2019/04/29/你喜欢什么？-忘了。/","content":"很久之前疑惑的一个问题。今天算是解决了1/3的解惑。 总有朋友和我说：“我想逃，我想离开这里，这根本不是我喜欢的专业&#x2F;工作。” 我往往会回复：“那你逃啊。” 他们又总是会退一步，说离开后，不知道下一步该往哪里走。 然后开始问我：“我应该怎么办？” 每每到这种时候，我总是多少有些无奈。 因为我会觉得，大家内心深处知道自己喜欢什么讨厌什么，但因为选择和离开总是具备“风险”，于是慢慢地，我们只敢去选一些很多人都选的选择。 有时候，人会把“害怕做选择”，美化成，“不知道怎么做选择”。很复杂对吧？ 于是才想告诉你，简单点，把注意力放在自己身上。 即使失败了，也不过回到原地而已。 但至少你眼里还有自己最想靠近的地方。 以上。祝好。 灼见"},{"title":"移动前端开发之viewport的深入理解","path":"/2019/04/28/移动前端开发之viewport的深入理解/","content":"在移动设备上进行网页的重构或开发，首先得搞明白的就是移动设备上的viewport了，只有明白了viewport的概念以及弄清楚了跟viewport有关的meta标签的使用，才能更好地让我们的网页适配或响应各种不同分辨率的移动设备。 直接贴CODE 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; width 设置layout viewport 的宽度，为一个正整数，或字符串”width-device”initial-scale 设置页面的初始缩放值，为一个数字，可以带小数minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数height 设置layout viewport 的高度，这个属性对我们并不重要，很少使用user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许 这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。 此外，在安卓中还支持 target-densitydpi 这个私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素 target-densitydpi 值可以为一个数值或 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个 特别说明的是，当 target-densitydpi&#x3D;device-dpi 时， css中的1px会等于物理像素中的1px。 因为这个属性只有安卓支持，并且安卓已经决定要废弃target-densitydpi 这个属性了，所以这个属性我们要避免进行使用 。 具体的内容篇幅移步：无双大神的移动前端开发之viewport的深入理解"},{"title":"Z-index失效的几种原因","path":"/2019/04/26/Z-index失效的几种原因/","content":"Tips: z-index属性只作用在被定位了的元素上。所以如果你在一个没被定位的元素上使用z-index的话，是不会有效果的. 同一个父元素下的元素的层叠效果会受父元素的z-index影响,如果父元素的z-index值很小,那么子元素的z-index值很大也不起作用 失效的情况： 父标签 position属性为relative； 问题标签无position属性（不包括static）； 问题标签含有浮动(float)属性。 问题标签的祖先标签的z-index值比较小 解决办法： 第一种: position:relative改为position:absolute； 第二种:浮动元素添加position属性（如relative，absolute等）； 第三种:去除浮动。 第四种:提高父标签的z-index值"},{"title":"让我们优雅的扩大点击区域","path":"/2019/04/25/让我们优雅的扩大点击区域/","content":"在互联网上闲逛时，发现了一个小技巧，现在分享给大家 优雅地扩大点击区域 每个和产品撕过逼的开发都应该知道，产品除了想要 ui 把按钮设计的再大、更大、还可以大之外，就希望开发把点击区域变得大大 大一点，让用户瞎着都能点中按钮。 恩可怜的开发如果撕不过，只能可怜的再把所有定位再重新计算一遍吗？ヾ(´･ ･｀｡)ノ” 那么今天也来优雅的解决一下。 今天这个方法学自 ionic 框架中的样式，后又在《CSS 秘密花园》这本书里也有讲到，今天在此普及一下。 想要在不影响现有布局的情况下，不增加多余元素的情况下，增大点击区域，我们可以使用 CSS 中的伪元素来实现。 ::before ::after ::before和::after两个伪元素，可以不用在 .html 文件中显式插入元素的情况下，增加两个dom节点。 12345678910&lt;!-- 在 html 中 --&gt;&lt;div&gt;Hello World&lt;/div&gt;/* 在 css 中 */div::before,div::after &#123;content: &#x27;❤&#x27;;&#125; 在浏览器中显示为： 1❤ Hello World ❤ 在浏览器检查器中显示为： 12345&lt;div&gt;::after&#x27; Hello World &#x27;::before&lt;/div&gt; 所以我们利用这种特性，在 CSS 中设置伪元素来扩大点击区域，显然是最划得来的。 12345改造前:&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;改造后:&lt;div class=&quot;demo extend&quot;&gt;&lt;/div&gt; 配合CSS代码： 12345678.extend::after&#123; content:&#x27;&#x27;; position:absolute; top:-10px; right: -10px; bottom: -10px; left: -10px;&#125; 实现原理 由于点击事件是绑定在元素上的，所以通过在内部添加伪元素的好处是: 伪元素使用绝对定位不会改变现有的文档流和布局尺寸 伪元素继承了元素的 cursor 属性，鼠标指针显示与元素保持一致 伪元素能触发事件并冒泡给元素 所以通过这样的方式，让我们不改变现有代码，仅添加一小段代码就可以优雅地扩大点击区域了。"}]